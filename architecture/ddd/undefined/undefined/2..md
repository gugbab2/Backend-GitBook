# 2. 아키텍처 개요

## 2.1 네 개의 영역&#x20;

* '표현', '응용', '도메인', '인프라스트럭처' 는 아키텍처를 설계할 때 출현하는 전형적인 네 가지 영역이다.&#x20;

### 표현 영역&#x20;

* 네 영역 중 '표현' 영역은 사용자의 요청을 받아 응용 영역에 전달하고 응용 영역의 처리 결과를 다시 사용자에게 보여주는 역할을 한다.&#x20;
  * 웹 애플리케이션에서 가장 많이 사용하는 스프링 MVC 패턴이 표현 영역을 위한 기술에 해당한다.&#x20;
  * 웹 애플리케이션의 경우 표현 영역의 사용자는 웹 브라우저를 사용하는 사람일 수도 있고, REST API 를 호출하는 외부 시스템일 수도 있다.&#x20;

<figure><img src="../../../../.gitbook/assets/image.png" alt=""><figcaption></figcaption></figure>

* 표현 영역을 통해 사용자의 요청을 전달받는 응용 영역은 시스템이 사용자에게 제공해야 할 기능을 구현하는데, '주문등록', '주문취소', '상품상세조회' 와 같은 기능 구현을 예로 들 수 있다.&#x20;

### 응용 영역&#x20;

* 응용 영역은 기능을 구현하기 위해 도메인 영역의 도메인 모델을 사용한다. 주문 취소 기능을 제공하는 응용 서비스를 예로 살펴보면 다음과 같이 주문 도메인 모델을 사용해서 기능을 구현한다.&#x20;
  * 응용 서비스는 로직을 직접 수행하기 보다는 도메인 모델에 로직 수행을 위임한다.&#x20;
  * **아래 코드도 주문 취소 로직을 직접 구현하지 않고 `order` 객체에 최소 처리를 위임하고 있다.**&#x20;

```java
public class CancelOrderService {
    @Transactional
    public void cancelOrder(String orderId) {
        Order order = findOrderById(orderId);
        if(order == null) throw new ORderNotFoundException(orderId); 
        order.cancel(); 
    }
    ...
}
```

<figure><img src="../../../../.gitbook/assets/image (1).png" alt=""><figcaption></figcaption></figure>

### 도메인 영역

* 도메인 영역은 도메인 모델을 구현한다. 1장에서 봤던 Order, OrderLine, ShippingInfo 와 같은 도메인 모델이 이 영역에 위치한다. 도메인 모델은 도메인의 핵심 로직을 구현한다.&#x20;
  * 예를 들어, 주문 도메인은 '배송지 변경', '결제 완료', '주문 총액 계산' 과 같은 핵심 로직을 도메인 모델에서 구현한다.&#x20;

### 인프라스트럭처 영역&#x20;

* 인프라스트럭처 영역은 구현 기술에 대한 것을 다룬다.&#x20;
  * 이 영역은 RDBMS 연동을 처리하고, 메시징 큐에 메시지를 전송하거나, 수신하는 기능을 구현하고, MongoDB, Redis 와 데이터 연동을 처리한다.&#x20;
  * 이 영역은 SMTP 를 이용한 메일 발송 기능을 구현하거나 HTTP 클라이언트를 이용해 REST API 를 호출하는 것도 처리한다.&#x20;
* 인프라스트럭처 영역은 논리적인 개념을 표현하기보다는 실제 구현을 다룬다.&#x20;
* 도메인 영역, 응용 영역, 표현 영역은 구현 기술을 사용한 코드를 직접 만들지 않는다. 대신 인프라스트럭처 영역에서 제공하는 기능을 사용해서 필요한 기능을 개발한다.&#x20;
  * 예를 들어, 응용 영역에서 DB 에 보관된 데이터가 필요하면 인프라스트럭처 영역의 DB 모듈을 사용하여 데이터를 읽어온다.&#x20;
  * 비슷하게 외부에 메일을 발송해야 한다면, 인프라스트럭처가 제공하는 SMTP 연동 모듈을 이용해서 메일을 발송한다.&#x20;

## 2.2 계층 구조 아키텍처&#x20;

<figure><img src="../../../../.gitbook/assets/image (2).png" alt="" width="312"><figcaption></figcaption></figure>

* 네 영역을 구성할 때, 상위 계층에서 하위 계층으로의 의존만 존재하고, 하위 계층은 상위 계층에 의존하지 않는다.&#x20;
* 계층 구조를 엄격하게 적용한다면 상위 계층은 바로 아래 계층에만 의존을 가져야 하지만, 구현의 편리함을 위해서 계층 구조를 유연하게 적용하기도 한다.&#x20;
  * 예를 들어, 응용 계층은 바로 아래 계층인 도메인 계층에 의존하지만 외부 시스템과의 연동을 위해 더 아래 계층인 인프라스트럭처 계층에 의존하기도 한다.&#x20;

### 계층 구조 아키텍처 문제점&#x20;

* 응용 영역과 도메인 영역은 DB 나 외부 시스템 연동을 위해 인프라스트럭처 기능을 사용하므로 이런 계층 구조를 사용하는 것은 직관적으로 이해하기 쉽다.&#x20;
* 하지만 짚고 넘어가야 할 점이 있는데 바로 표현, 응용, 도메인 계층이 상세한 구현 기술을 다루는 인프라스트럭처 계층에 종속된다는 점이다.&#x20;
* 도메인 가격 계산 규칙을 예로 들어보자. 다음은 할인 금액을 계산하기 위해서 `Drools` 라는 룰 엔진을 사용해서 계산 로직을 수행하는 인프라스트럭처 영역의 코드를 만들어본 것이다.&#x20;

```java
public class DroolsRuleEngine {
    private KieContainer kContainer;
    
    public DroolsRuleEngine() {
        KieSertvices ks = KieServices.Factory.get(); 
        kContainer = ks.getKieClassPathContainer();
    }
    
    public void evalute(String sessionName, List<?> facts) {
        KieSession kSession = kContainer.newKieSession(sessionName); 
        try {
            facts.forEach(x -> kSession.insert(x)); 
            kSession.fireAllRules(); 
        } finally {
            kSession.dispose(); 
        }
    }    
}
```

* 응용 영역은 가격 계산을 위해서 인프라스트럭처 영역의 `DroolsRuleEngine` 을 사용한다.&#x20;

```java
public class CalculateDiscountService {
    private DroolsRuleEngine ruleEngine; 
    
    public CalculateDiscountService () {
        ruleEngine = new DroolsRuleEngine();
    }
    
    public Money calculateDiscount(List<OrderLine> orderLines, String customerId) {
        Customer customer = findCustomer(customerId); 
        
        MutableMoney money = new MultableMoney(0); 
        List<?> facts = Arrays.asList(customer, moeny); 
        facts.addAll(orderLines); 
        ruleEngine.evalute("discountCalculation", facts); 
        return money.toImmutableMoney(); 
    }
    ...
}
```

#### 해당 코드에는 두 가지 문제가 있다.&#x20;

1. `CalculdateDiscountService` 만 테스트하기 어렵다. **(테스트 어려움)**
   1. `CalculdateDiscountService` 를 테스트하려면 `ruleEngine` 이 완벽하게 동작해야 한다.&#x20;
   2. `ruleEngine` 클래스와 관련 성정 파일을 모두 만든 후 비로서 `CalculdateDiscountService` 가 올바르게 동작하는지 확인할 수 있다.&#x20;
2. 두번째 문제는 구현 방식을 변경하기가 어렵다. **(기능 확장의 어려움)**
   1. 해당 코드는 `discountCalculation`, `MutableMoney` 등 `Drools`라는 인프라스트럭처 영역의 기술에 완전하게 의존하고 있다.
   2. 이런 상황에서 `Drools` 가 아닌 다른 구현 기술을 사용하려면 코드의 많은 부분을 고쳐야 한다.&#x20;

## 2.3 DIP(의존 역전의 원칙)&#x20;

<figure><img src="../../../../.gitbook/assets/image (3).png" alt=""><figcaption></figcaption></figure>

* 여기서 `CalculdateDiscountService` 는 고수준 모듈이다.&#x20;
* 고수준 모듈은 의미 있는 단일 기능을 제공하는 모듈로 `CalculdateDiscountService` 는 '가격 할인 계산' 이라는 기능을 구현한다.&#x20;
* 이런 고수준 모듈의 기능을 구현하려면 여러 하위 기능이 필요하다.&#x20;
  * **가격 할인 계산 기능을 구현하려면 고객 정보를 구해야 하고,**&#x20;
  * **룰을 실행해야 한다.**&#x20;
* 저수준 모듈은 하위 기능을 실제로 구현한 것이다.&#x20;
  * **JPA 를 통해서 고객 정보를 읽어오는 모듈**&#x20;
  * **Drools 로 룰을 실행하는 모듈**&#x20;
* 고수준 모듈이 제대로 동작하려면 저수준 모듈을 사용해야 한다. 그런데 고수준 모듈은 저수준 모듈을 사용하면 앞서 언급했던 두 가지 문제점을 가지게 된다. (테스트가 어려움, 구현 변경에 어려움)&#x20;
* DIP 는 이 문제를 해결하기 위해서 저수준 모듈이 고수준 모듈에 의존하도록 바꾼다. \
  &#xNAN;**(추상화 한 인터페이스 사용)**

#### 추상화 한 인터페이스 사용

* `CalculateDiscountService` 입장에서 봤을 때 룰 적용을 `Drools` 로 구현했는지 자바로 직접 구현했는지는 중요하지 않다. '고객 정보와 구매 정보에 룰을 적용해서 할인 금액을 구한다' 라는 것만 중요할 뿐이다. 이를 추상화한 인터페이스는 다음과 같다.&#x20;

```java
public interface RuleDiscounter {
    Money applyRules(Customer customer, List<OrderLine> orderLines); 
}
```

* 이제 `CalculateDiscountService` 가 `RuleDiscounter` 를 이용하도록 바꾸어보자.&#x20;
  * `CalculateDiscountService` 에는 `Drools` 에 의존하는 코드가 없다.&#x20;
  * 단지 `RuleDiscounter` 가 룰을 적용한다는 사실만 알뿐이다.&#x20;
  * 실제 `RuleDiscounter` 의 구현 객체는 생성자를 통해서 전달받는다.&#x20;
  * 룰 적용을 구현한 클래스는 `RulsDiscounter` 인터페이스를 상속받아 구현한다.&#x20;

```java
public class CalculateDiscountService {
    private RuleDiscounter ruleDiscounter;
    
    // 의존성 주입
    public CalculateDiscountService(RuleDiscounter ruleDiscounter) {
    	this.ruleDiscounter = ruleDiscounter;
    }
    
    public Money calculateDiscount(List<OrderLine> orderLines, String customerId) {
    	Customer customer = findCustomer(customerId);
        return ruleDiscounter.applyRules(customer, orderLines);
    }
}
```

* `RuleDiscounter` 가 등장하면서 바뀐 의존 관계를 아래 그림에서 확인할 수 있다.&#x20;
* 아래 그림과 같이, `DroolsRuleDiscounter` 과 같이 저수준 모듈이 `RuleDiscounter` 과 같은 고수준 모듈에의존한다고해서 DIP(의존역전원칙) 이라고 부른다.&#x20;

<figure><img src="../../../../.gitbook/assets/image (4).png" alt=""><figcaption></figcaption></figure>

#### 자유로운 테스트 가능&#x20;

* DIP 를 적용하면 테스트가 어려웠던 문제를 해결할 수 있다.&#x20;
* 실제 사용할 저수준 구현 객체는 다음 코드처럼 의존 주입을 이용해서 전달받을 수 있다.&#x20;

```java
// 사용할 저수준 객체 생성
RuleDiscounter ruleDiscounter = new DroolsRuleDiscounter(); 

// 생성자 방식의 주입
CalculateDiscountService disService = new CalculateDiscountService(ruleDiscounter); 
```

* 테스트에 대해서 더 언급하기 전에 `CalculateDiscountService` 가 제대로 동작하려면 `Customer` 를 찾는 기능도 구현해야 한다.&#x20;
* 이를 위한 고수준 인터페이스를 CustomerRepository 라고 하고 CalculateDiscountService 는 다음과 같이 두 인터페이스인 CustomerRepository, RuleDiscounter 를 사용해서 기능을 구현한다.&#x20;

```java
public class CalculateDiscountService {
    private CustomerRepository customerRepository; 
    private RuleDiscounter ruleDiscounter;
    
    // 의존성 주입
    public CalculateDiscountService(
            CustomerRepository customerRepository, RuleDiscounter ruleDiscounter) {
        this.customerRepository = customerRepository; 
    	this.ruleDiscounter = ruleDiscounter;
    }
    
    public Money calculateDiscount(List<OrderLine> orderLines, String customerId) {
    	Customer customer = findCustomer(customerId);
        return ruleDiscounter.applyRules(customer, orderLines);
    }
    
    private Customer findCustomer(String customerId) {
        Customer customer = customerRepository.findById(customerId); 
        if(customer == null) throw new NoCustomerException(); 
        return customer; 
    }
    ...
}
```

* 기존에는 저수준 모듈을 직접 의존하기 때문에, 저수준 모듈이 만들어지기 전까지 테스트를 할 수 없었겠지만, 현재는 인터페이스를 의존하기 떄문에, Mock 객체를 사용해 테스트를 진행할 수 있다.&#x20;

#### 자유로운 기능 확장

* DIP 를 적용하면 구현 객체를 바꾸기가 자유로워져 코드의 변경 없이 기능을 확장할 수 있다.&#x20;
* 스프링 같은 의존 주입을 지원하는 프레임워크를 사용하면 설정 코드를 수정해서 쉽게 구현체를 변경할 수 있다.&#x20;

```java
// 사용할 저수준 객체 생성
RuleDiscounter ruleDiscounter = new SimpleRuleDiscounter(); 

// 생성자 방식의 주입
CalculateDiscountService disService = new CalculateDiscountService(ruleDiscounter);
```

### 2.3.1 DIP 주의사항&#x20;

* DIP 를 잘못 생각하면 단순히 인터페이스와 구현 클래스를 분리하는 정도로만 받아들일 수 있다..&#x20;
* DIP 핵심은 고수준 모듈이 저수준 모듈에 의존하지 않도록 하기 위함인데, DIP 를 적용한 결과 구조만 보고 저수준 모듈에서 인터페이스를 추출하는 경우가 있다.&#x20;
* **DIP 를 적용할 때 하위 기능을 추상화한 인터페이스는 고수준 모듈 관점에서 도출한다.**&#x20;
* **`CalculateDiscountService` 입장에서 봤을 때 할인 금액을 구하기 위해 룰 엔진을 사용하는지 직접 연산하는지는 중요하지 않다. 단지 규칙에 따라 할인 금액을 계산한다는 것이 중요할 것이다.**&#x20;
  * **즉, '할인 금액 계산' 을 추상화한 인터페이스는 저수준 모듈이 아닌 고수준 모듈에 위치해야 한다.**&#x20;

### 2.3.2 DIP 와 아키텍처&#x20;

<figure><img src="../../../../.gitbook/assets/image (7).png" alt="" width="422"><figcaption></figcaption></figure>

* DIP 적용시 인프라스트럭처 영역이 응용 영역과 도메인 영역에 의존하는 구조가 된다.&#x20;

<figure><img src="../../../../.gitbook/assets/image (9).png" alt="" width="563"><figcaption></figcaption></figure>

* **인프라스트럭처 영역에 위치한 클래스가 도메인이나 응용 영역에 정의된 인터페이스를 상속 받아 구현하는 구조가 되므로 도메인과 응용 영역에 대한 영향을 주지 않거나 최소화하면서 구현 기술을 변경하는 것이 가능하다.**&#x20;

##
