# 3. 애그리거트

## 3.1 애그리거트&#x20;

* 온라인 쇼핑몰 시스템을 개발할 때 상위 수준 개념을 이용해서 전체 모델을 정리하면 전반적인 관계를 이해한는 데 도움이 된다.&#x20;
* 아래 그림을 보면 주문은 회원, 상품, 결제와 관련이 있다는 것을 쉽게 파악할 수 있다.&#x20;

<figure><img src="../../../../.gitbook/assets/image (5).png" alt="" width="563"><figcaption></figcaption></figure>

* 상위 수준 모델을 개별 객체 단위로 다시 그리면 다음과 같다.&#x20;
  * 상위 모델에 대한 이해 없이 아래 그림만 보고서 새념을 파악하려면 오랜 시간이 걸린다.&#x20;
* 백 개 이상의 테이블을 한 장의 ERD 에 모두 표시하면 개별 테이블 간의 관계를 파악하느라 큰 틀에서 데이터 구조를 이해하는 데 어려움을 겪게 되는 것처럼, 도메인 객체 모델이 복잡해지면 개별 구성요소 위주로 모델을 이해하게 되고, 전반적인 구조나 큰 수준에서 도메인 간의 관계를 파악하기 어려워진다.&#x20;

<figure><img src="../../../../.gitbook/assets/image (6).png" alt="" width="563"><figcaption></figcaption></figure>

* 복잡한 도메인을 이해하고 관리하기 쉬운 단위로 만드려면 상위 수준에서 모델을 조망할 수 있는 방법이 필요한데, 그 방법이 바로 애그리거트이다.&#x20;
* 아래 그림은 애그리거트를 사용한 그림으로 이해하기도 쉽고, 애그리거트가 일관성을 관리하는 기준도 된다.&#x20;

<figure><img src="../../../../.gitbook/assets/image (7).png" alt="" width="563"><figcaption></figcaption></figure>

* 애그리거트는 관련된 모델을 하나로 모았기 때문에, 한 애그리거트에 속한 객체는 유사하거나 동일한 라이프 사이클을 갖게 된다. 주문 애그리거트를 만들려면 `Order`, `OrdeLine`, `Orderer` 와 같은 관련 객체를 함께 생성해야 한다.&#x20;
  * `Order` 는 생성했는데, `ShippingInfo` 는 만들지 않거나, `ShippingInfo` 를 생성하면서 `Orderer` 를 생성하지 않는 경우는 없다.&#x20;
  * **도메인 규칙에 따라 최초 주문 시점에 일부 객체를 만들 필요가 없는 경우도 있지만 애그리거트에 속한 구성요소는 대부분 함께 생성하고 함께 제거한다.**&#x20;
* **위 그림과 같이 한 애그리거트에 속한 객체는 다른 애그리거트에 속하지 않는다. 애그리거트는 독립된 객체 군이며 각 애그리거트는 자기 자신을 관리할 뿐 다른 애그리거트를 관리하지 않는다.**&#x20;
* **경계를 설정할 때 기본이 되는 것은 규칙과 요구사항이다. 도메인 규칙에 따라 생성되는 구성요소는 한 애그리거트에 속할 가능성이 높다.**&#x20;

#### 애그리거트 설정 시 주의점 : 'A 가 B 를 갖는다' 라는 요구사항에서 반드시 B 는 A 에 애그리거트에 소속되지 않는다.&#x20;

* 좋은 예시 : **상품과 리뷰**
* 상품 상세 페이지에 들어가면 상품 상세 정보와 함께 리뷰 내용을 보여주어야 한다는 요구사항이 있을 때, `Product`, `Review` 엔티티가 같은 애그리거트 내에 소속되어야 한다고 생각할 수 있다.&#x20;
* 하지만 `Product` 와 `Review` 는 함께 생성되지 않고, 함께 변경되지도 않는다.&#x20;
* 게다가 `Product` 를 변경하는 주체가 상품 담당자라면 `Review` 를 생성하고 변경하는 주체는 고객이다.&#x20;
* **서로의 use case 에서 관계가 없다면 애그리거트를 분리시키자.**

## 3.2 애그리거트 루트&#x20;

* 주문 애그리거트는 다음을 포함한다.&#x20;
  * 총 금액인 `totalAmounts` 를 갖고 있는 `Order` 엔티티&#x20;
  * 개별 구매 상품인 개수인 `quantity` 와 금액인 `price` 를 갖고 있는 `OrderLine` 밸류&#x20;
* 구매할 상품의 개수를 변경하면 한 `OrderLine` 의 `quantity` 도 변경하고 더불어 `Order` 의 `totalAmounts` 도 변경해야 한다. 그렇지 않으면 다음 도메인 규칙을 어기고 데이터 일관성이 깨진다.&#x20;
  * 주문 총 금액은 개별 상품의 주문 개수 X 가격의 합이다.&#x20;
* **애그리거트는 여러 객체로 구성되기 때문에, 한 객체만 상태가 정상이면 안된다. 도메인 규칙을 지키려면 애그리거트에 속한 모든 객체가 정상 상태를 가져야한다.**&#x20;
* 애그리거트에 속한 모든 객체가 일관된 상태를 유지하려면 애그리거트 전체를 관리할 주체가 필요한데 이 책임을 지는 것이 바로 애그리거트 루트 엔티티이다.&#x20;
  * 애그리거트에 속한 객체는 애그리거트 루트 엔티티에 직/간접적으로 속하게 된다.&#x20;

<figure><img src="../../../../.gitbook/assets/image (8).png" alt="" width="563"><figcaption></figcaption></figure>

### 3.2.1 도메인 규칙과 일관성&#x20;

* **애그리거트 루트의 핵심적인 목적은 애그리거트의 일관성이 깨지지 않도록 하는 것이다. 이를 위해서 애그리거트 루트는 애그리거트가 제공해야 할 도메인 기능을 구현한다.**&#x20;
  * 예를 들어, 주문 애그리거트는 배송지 변경, 상품 변경 과 같은 기능을 제공하고, 애그리거트 루트인 `Order` 가 이 기능 메서드를 구현한다.&#x20;
  * 배송이 시작되지 전까지만 배송지 정보를 변경할 수 있다는 규칙이 있다면, 애그리거트 루트인 `Order` 의 `changeShippingInfo()` 메서드는 이 규칙에 따라 배송 시작 여부를 확인하고 규칙을 충족할 때만 배송지 정보를 변경해야 한다.&#x20;

```java
public class Order {

    public void changeShippinInfo(ShippingInfo newShippingInfo) {
        verifyNotYetShipped(); 
        setShippingInfo(newShippingInfo);
    }
    
    private void verifyNotYetShipped(){
        if(state != OrderState.PAYMENT_WAITTING && state != OrderState.PREPARING)
            threw new IllegalStateException("aleady shipping");
    }
    ...
}
```

* 애그리거트 외부에서 애그리거트에 속한 객체를 직접 변경하면 안된다. 이것은 애그리거트 루트가 강제하는 규칙을 적용할 수 없어 모델의 일관성을 깨는 원인이 된다.&#x20;
  * 아래 코드에서는 애그리거트 루트인 Order 에서 ShippingInfo 를 가져와 직접 정보를 변경하고 있다. 주문 상태에 상관 없이 배송지 주소를 변경하는데, 이는 업무 규칙을 무시하고 직접 DB 테이블의 데이터를 수정하는 것과 같은 결과를 만들어낸다.&#x20;
  * 즉, 논리적인 데이터 연관성이 깨지게 되는 것이다.&#x20;
  * 일관성을 지키기 위해서 다음과 같이 상태 확인 로직을 응용 서비스에 구현할 수도 있다. 하지만 이렇게 되면 동일한 로직 검사를 여러 응용 서비스에서 중복으로 구현할 가능성이 높아져 유지 보수에 도움이 되지 않는다.&#x20;

```java
ShippingInfo si = order.getShippingInfo();
si.setAddress(newAddress); 
```





























