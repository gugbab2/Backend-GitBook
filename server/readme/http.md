---
description: HTTP 개요, HTTP 메시지
---

# HTTP 이해

## HTTP(Hypertext Transfer Protocol)

* WEB 상에서 발생하는 통신을 위한 가장 기본적인 프로토콜(규칙, 규약)
* 클라이언트-서버 프로토콜이기도 하다
* HTTP 는 OSI(Open Systems Interconnection) 7계층에서 마지막 7계층에 해당되는 프로토콜로 웹개발자의 입장에서는 2, 3, 4, 7 계층 정보를 이해하고 넘어가자
  * 2계층(데이터 링크 계층)\
    \-> 인터넷 프로토콜 스택 4계층에서 **네트워크 인터페이스 계층에 해당**\
    \- MAC Address 라는 물리 주소(유일)를 가지게 되고, 2계층부터 주소체계를 가지게 된다.
  * 3계층(네트워크 계층)\
    \-> 인터넷 프로토콜 스택 4계층에서 **인터넷 계층에 해당**\
    \- IP 라는 논리 주소(유일하지 않음)를 가지게 되고, 이는 네트워크 관리자에 의해 관리된다.
  * 4계층(전송 계층)\
    \-> 인터넷 프로토콜 스택 4계층에서 **전송 계층에 해당**\
    \- Port 를 가지게 되고, 각 IP 내부 특정 프로세스를 식별한다.\
    \- 일반적으로 TCP, UDP 프로토콜을 사용하며, TCP는 연결지향(올바른 패킷관리) 프로토콜이다.
  * 7계층\
    \-> 인터넷 프로토콜 스택 4계층에서\
    \- 1\~4계층까지는 운영체제 와 같이 사람이 아닌 곳에서 할당하고 관리하지만,\
    \- 7계층은 사람이 직접 개발하고 관리 해야한다.

## HTTP와 HTTPS의 차이(TLS)

* 위에서 말했듯이, HTTP 는 웹표준 프로토콜이고, HTTPS 는 중간에 TLS(SSL : TLS 전신) 를 함께 사용하는 보안이 강화된 프로토콜이다.
* 이를 통해서 웹 상에서, 통신 내부 정보가 평문으로 노출되지 않는다.\
  (와이어샤크와 같은 패킷분석툴을 통해서 암호화가 적용 된 패킷정보를 확인 할 수 있다)![](<../../.gitbook/assets/image (51).png>)

## 클라이언트-서버 모델

* HTTP 요청 대상을 리소스/서비스 라고 부르며 URL(URI) 을 통해서 요청을 보낸다.
* 클라이언트 -> 요청
* 서버 -> (처리, Optional) -> 응답

## stateless와 stateful

* #### stateful
* #### stateless(무상태 프로토콜)
  * HTTP 프로토콜은 상태를 유지하지 않는 stateless 프로토콜이다!
  * **때문에, 쿠키/세션/토큰이 필요하다.**
  * 무상태 프로토콜을 통해서 **무한한 서버 증설**이 가능하다.\
    \-> **마지막에 모든 응답에 필요한 모든 정보를 넘겨주기 때문에, 마지막 요청만으로도 정상적으로 처리가 된다.**

## 비연결성

* 서버가 모든 클라이언트와 연결되어 있다면, 연결을 위한 자원을 지속적으로 소모해야 한다.
* 때문에, **HTTP 는 한번의 통신 후 연결을 끊는다.**\
  \-> 서버의 자원을 효율적으로 사용할 수 있다.
* 하지만, **요청할 때마다 3 way handshake 시간이 추가된다.**\
  \-> Persistent Connections(지속 연결성)\
  \-> HTTP 2.0, 3.0 에서 최적화해 문제를 해결해나가고 있다.

## HTTP Cookie와 HTTP Session

* Cookie
  * 위와 같이 Stateless 상황에서 자신을 서버에 알리기 위한 정보를 쿠키에 담아서 서버에 전달한다.
  * 요청과 응답을 통해서 계속적으로 쿠키를 주고받게 된다.
* Session
  * 쿠키는 브라우저 개발자 도구 등 쉽게 변조가 가능하여 보안이 취약하다는 단점을 가지고 있다.
  * 이에 대한 해결책으로 나온 세션은, 데이터는 서버에서 관리하고 이를 사용할 수 있는 Key 값을 쿠키에 담아 요청과 응답을 통해 쿠키를 주고받는다.
  * 보통 Key 값으로는 예측할 수 없는 UUID 등을 많이 사용한다.

## HTTP 메시지 구조

![](<../../.gitbook/assets/스크린샷 2023-02-05 오후 5.36.49.png>)

* #### HTTP 요청(Reuqest)와 응답(Response
  * **요청과 응답의 구조**
    * Start line\
      \- 실행되어야 할 요청 OR 요청 수행에 대한 결과 값
    * HTTP headers\
      \- 요청과 응답에 대한 설명\
      \- Body 에 대한 설명
    * empty line
    * Body\
      \- 크기를 알기가 어렵다. 때문에 헤더 값 중 하나인 Content-Length 를 확인해야 한다.\
      \- 꼭 사람이 읽을 수 있는 텍스트일 필요는 없다. 바이너리 형태도 가능하다.\
      \- 하나가 아니라 여럿일 수 있다. 파일 업로드를 위한 multipart/form-data 가 대표적이다.
  * **multipart/form-data**
    * html \<form> 을 통해 데이터를 서버로 전송할 때 설정하지 않을 시 default 로 Content-Type: application/x-www-form-urlencoded 와 같은 Content-Type 을 사용하고, 전송되는 각각의 데이터들은 HTTP Body 에 '**&**' 로 구분 지어 전송되게 된다.\
      (문자열과 숫자의 조합일 때는 상관없다)
    * 하지만, 파일을 서버로 전송할 때는 바이너리 데이터를 전송해야 하고 수 많은 문자의 조합이 사용되어 '**&**' 로 구분하지 못한다.
    * 이때, multipart/form-data 를 사용하게 되면 임의로 생성되는 바운더리( ex)---xxx )를 통해서 구분되며 임의의 바운더리는 UUID 로 매번 임의로 생성된다.
* #### HTTP 요청 메서드(HTTP request methods)
  *   **멱등성 : 매번 같은 요청을 보내도 같은 결과를 나타내는 것을 뜻함**

      **-> 멱등해야지만 자동 복구 매커니즘에 사용할 수 있다!**\
      ex) DELETE 가 확인되지 않아서, 다시 DELETE 한다.
  * **GET → 조회**
    * 서버의 전달하고 싶은 데이터를 쿼리 파라미터를 통해서 전달
    * 최근 버전에서는 바디를 통해서 데이터를 전달 할 수 있지만, 지원하지 않는 버전이 많기에 권장하지 않는다.
  * HEAD → GET without body
  * **POST → 요청 데이터 처리, 주로 등록에 사용 (멱등성X)**
    * GET 은 URL 을 통해서 요청을 보내 데이터(개인정보)를 쿼리 파라미터로 평문 노출시킬 수도 있지만,
    * **POST 는 메시지 바디를 통해서 데이터를 보내기 때문에 한번 감추어준다. (완벽한 건 X)**
    * **주로 등록에 사용하지만, 변경하는 것을 넘어선 프로세스를 처리해야 하는 경우에도 사용하기 때문에, 수많은 용도로 사용한다.(결과로 새로운 리소스가 생겨나지 않을 수도 있다!)**
    * **컨트롤 URL : HTTP 메서드로 해결하기 애매한 경우 동사를 URI 포함하여 설계 할 수 있다.**\
      **ex) /new, /edit, /delete -> 무식하게 사용해서는 안된다;;**
    * **애매하면 POST 사용해라.**
  * **PUT → Update (+Create) ⇒ Overwrite!(리소스를 완전하게 대체한다)**
    * **POST 와 달리 클라이언트가 리소스를 식별한다!!**\
      ex) PUT /members/**100** HTTP/1.1
  * **PATCH → Update (멱등성X) => Particial!(리소스를 부분적으로 대체한다)**
    * 만약 서버에서 PATCH 가 지원되지 않는다면 POST 를 사용해라.\
      \-> **POST 는 무적이다..**
  * **DELETE → Delete**
  * OPTIONS → 리소스와의 통신 옵션을 확인하기 위해 사용
* #### HTTP 응답 상태 코드(HTTP response status code)
  * 1xx → 정보 ⇒ 우리가 직접 쓰는 일은 드믐.
  * 2xx → 성공 ⇒ 대부분 200, 201 정도를 많이 사용
    * **200 : OK**
    * **201 : Created** -> 새로운 리소스가 생성됨
    * 202 : Accepted -> 요청이 접수 되었으나, 처리되지 않음
    * 204 : No Content -> 서버가 요청을 성공적으로 수행했지만, 응답 페이로드 본문에 보낼 데이터가 없음
  * 3xx → 리다이렉션 ⇒ 웹 브라우저는 3xx 응답 결과에 Location 헤더가 있다면, Location 위치로 자동 이동한다.
    * 300 : Multiple Choices : 안씀;;
    * **301 : Moved Permanently(영구적 변화)** -> 리다이렉트시 요청 메서드가 GET 으로 바뀌고 Body가 제거될 수 있음(거의 다 Body 가 사라짐)
    * **302 : Found(일시적 변화)** -> 리다이렉트시 요청 메서드가 GET 으로 바뀌고 Body가 제거될 수 있음(거의 다 Body 가 사라짐)
    * 303 : See Other(일시적 변화) -> 302 와 기능은 같고 GET 으로 바뀌고, Body 가 제거된다.(명확함)
    * **304 : Not Modified(캐시)** -> 요청된 리소스를 재전송할 필요가 없음을 나타낸다. 캐시된 자원으로의 암묵적인 리디렉션이다.
    * 307 : Temporary Redirect(일시적 변화) -> 301과 같지만 요청 메서드가 변하지 않고 Body 도 유지 됨
    * 308 : Permanent Redirect(영구적 변화, **거의 사용하지 않음**) -> 301과 같지만 요청 메서드가 변하지 않고 Body 도 유지 됨
    * **일시적 리다이렉션 예시(PRG : Post/Redirection/Get) => 중복 주문 예방**
      * POST 로 주문 후 웹 브라우저를 새로고침 하면?
      * 새로고침은 다시 요청
      * 중복 주문이 될 수 있다.
      * 때문에, POST 주문후에 주문 결과 화면을 GET 메서드로 리다이렉트
      * 새로고침을 해도 GET 메서드(결과 화면)이기 때문에, 중복 주문을 예방 한다.
  * 4xx → 클라이언트 쪽 문제
    * **400 : Bad Request** -> 클라이언트가 잘못된 요청
    * **401 : Unauthorized** -> 클라이언트가 해당 리소스에 대한 인증이 필요함\*\*(인증)\*\*
      * Authentication : 인증 -> 본인이 누구인가(로그인)
      * Authorization : 인가 -> 리소스에 대한 인증(권한부여)
    * **403 : Forbidden** -> 서버가 요청을 이해했지만, 승인을 거부함\*\*(인가)\*\*
    * **404 : Not Found** -> 요청에 대한 리소스를 찾을 수 없음
  * 5xx → 서버 쪽 문제
    * **500 : Internal Server Error** -> 애매하면 500 오류
    * **503 : Service Unavailable** -> 서비스 이용 불가
* #### POST/PUT 을 사용한 신규 자원 등록시 차이점
  *   **POST (주문 관리 시스템)**

      \-> 실무에서 대부분 사용

      * 클라이언트는 등록될 리소스의 URI 를 모른다.
      * 서버가 새로 등록된 리소스 URI 를 생성해서 전달해준다.\
        ex) HTTP/1.1 201 Created\
        Location: **/members/100**
      * 컬렉션(Collection)
        * 서버가 관리하는 리소스 디렉토리
        * 서버가 리소스의 URI 를 생성하고 관리한다.
        * 위에서 컬렉션은 /members
  * **PUT (파일 관리 시스템)**\
    **-> 거의 사용하지 않는다..**
    * 클라이언트가 리소스의 URI 를 알고 있어야 한다.\
      ex) PUT /files/star.jpg
    * 클라이언트가 직접 리소스의 URI 를 지정한다.
    * 스토어(Store)
      * 클라이언트가 관리하는 리소스 저장소
      * 클라이언트가 리소스의 URI 를 알고 관리
      * 위에서 스토어는 /files
