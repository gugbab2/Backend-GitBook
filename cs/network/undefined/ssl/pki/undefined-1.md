# 공개키 신뢰를 위한 검증체계

## 공개키 신뢰를 위한 검증체계

<figure><img src="../../../../../.gitbook/assets/스크린샷 2024-01-19 15.35.07.png" alt="" width="563"><figcaption></figcaption></figure>

* 앞서 비대칭키 방식은 컴퓨팅 파워를 상당히 소모하는 방식이라고 설명한 바 있다.&#x20;
* **때문에, 한번 만들어진 비대칭키는 여러번 사용되어야 한다.**&#x20;
  * **일반적으로 1회 생성 시 6개월 \~ 1년 사용한다.**&#x20;
* 일반적으로 WEB(HTTP) 상에서는 비대칭키 형식이 아닌, X509 문서 형식의 SSL 인증서 형식으로 사용한다.&#x20;
  * X509 문서는 SSL 인증서 정보, 공개키, Hash 값 등 다양한 정보를 포함하고 있다.&#x20;
  * Hash 값은 CA 의 비공개키로 암호화 되어있다.&#x20;
* **SSL 인증서 발급 방식은 다음과 같다.**&#x20;
  * WEB Server 담당자가 인증서 발급을 위해 RA(인증서 등록 대행) 업체에 구매요청을 한다.&#x20;
  * 요청을 받은 RA 업체는 CA(인증서 발급) 업체에 인증서 발급 요청을 한다.&#x20;
  * CA 업체는 X509 문서 형식의 SSL 인증서와 비공개키를 발급해 RA 업체에 전달한다.&#x20;
  * RA 업체는 WEB Server 담당자에게 인증서와 비공개키를 전달하고, 담당자는 WEB Server 에 인증서와 비공개키를 등록한다.&#x20;

### HTTPS 통신방식

<figure><img src="../../../../../.gitbook/assets/스크린샷 2024-01-19 15.49.19.png" alt=""><figcaption></figcaption></figure>

1. **클라이언트의 인사 (Client Hello):**
   1. 클라이언트 브라우저가 웹사이트(서버)에 접속을 시도하면, "안녕? 우리 암호화된 통신할 건데, 나는 이런 암호화 방식들을 지원하고, 이것들은 내가 사용하는 임시 숫자야."라고 인사를 건낸다.&#x20;
2. **서버의 응답 및 신분증 제시 (Server Hello + Certificate):**
   1. 서버는 클라이언트의 인사를 받고 "그래, 안녕! 너랑 나는 이 암호화 방식을 쓸 거야. 그리고 이건 내 **신분증(SSL/TLS 인증서)**&#xC778;데, 이걸로 내가 진짜 이 웹사이트 주인인지 확인해봐."라고 응답한다.&#x20;
   2. **핵심:** 여기서 서버는 **자신의 '공개키'를 직접 주는 것이 아니라, '공개키'가 포함된 '인증서'를 준다.** 이 인증서는 서버의 신분을 증명하는 일종의 전자 신분증이다.
3. **클라이언트의 신분증 검증 (인증서 유효성 검사):**
   1. 클라이언트(브라우저)는 서버가 준 신분증(인증서)을 받아들고 바로 믿지 않는다. 먼저 신분증이 진짜인지 검증해야 한다.
   2. **"클라이언트는 기관인증서(CA의 공개키)를 통해 인증서 내 Hash 값을 복호화하고, Hash 값을 비교해 올바른 인증서인지 검증한다."**
      1. 이 부분이 중요하다. 서버의 신분증(인증서)은 **'공인된 기관(CA: Certificate Authority)'**&#xC774; "이 서버는 진짜입니다!"라고 서명한 것이다. 이 서명은 CA의 **'개인키'로 암호화**되어 인증서에 포함되어 있습니다.
      2. 클라이언트 컴퓨터에는 운영체제 업데이트 등을 통해 미리 **'신뢰할 수 있는 CA들의 공개키(기관인증서)'**&#xAC00; 잔뜩 심어져 있다.
      3. 클라이언트(브라우저)는 이 미리 심어져 있는 **CA의 공개키**를 사용하여 서버 인증서에 있는 CA의 서명을 **복호화한다.**&#x20;
      4. 복호화된 결과는 일종의 '해시(Hash) 값'이다. 브라우저는 서버 인증서의 내용을 바탕으로 똑같은 해시 값을 **스스로 다시 계산한다.**
      5. 만약 **미리 계산된 해시 값과 CA 서명을 복호화해서 얻은 해시 값이 일치한다면**, "아, 이 인증서는 CA가 진짜 서명한 게 맞네! 위조되지 않았군!"이라고 판단한다.&#x20;
      6. 여기에 더해, 인증서의 유효 기간은 지났는지, 이 인증서가 접속하려는 도메인과 일치하는지 등도 꼼꼼히 확인한다.
   3. **"운영체제 보안 업데이트 시 CA의 공개키를 컴퓨터에 심어주게 된다."**
4. **비밀 열쇠 만들기 및 전달 (Client Key Exchange):**
   1. 신분증이 진짜라고 확인되었다면, 이제 안전하게 '비밀 열쇠(세션 키)'를 만들어야 한다.&#x20;
   2. **"위 과정을 통해 올바른 인증서인지 검증이 되었다면, 인증서 내 공개키를 통해서 대칭키(Session Key)를 암호화 해 서버에 전달한다."**
      1. 클라이언트가 통신에 사용할 **실제 '비밀 열쇠(세션 키)'**&#xB97C; 하나 만든다.&#x20;
      2. 이 비밀 열쇠를 **서버의 '공개키'로 암호화**해서 서버에게 보낸다. (이 공개키는 오직 해당 서버의 '개인키'로만 복호화할 수 있으므로, 중간에 도청당해도 안전하다.)
5. **비밀 열쇠 공유 완료 및 암호화 통신 시작 (Change Cipher Spec + Finished):**
   1. 서버는 자신의 '개인키'로 클라이언트가 보낸 암호화된 비밀 열쇠를 **복호화**하여 실제 비밀 열쇠를 알아낸다.
   2. 이제 클라이언트와 서버는 둘 다 동일한 **'비밀 열쇠(세션 키)'**&#xB97C; 공유하게 된다.
   3. 서로 "이제부터 이 비밀 열쇠로 암호화해서 대화하자!"라고 최종 확인 메시지를 주고받는다.

> #### 인증서의 표준 형식은 **X.509**이며, 그 안에 포함되는 주요 정보들은 다음과 같다.
>
> 1. **웹사이트 주소:** 이 인증서가 누구(어떤 웹사이트 주소)의 신분증인지 알려준다. (예: `www.google.com`)
> 2. **웹사이트 공개키:** 웹사이트가 사용자에게 보내는 **'열쇠(공개키)'**&#xC774;다. 이 열쇠로 나중에 보낼 '비밀 열쇠(세션 키)'를 암호화하여 서버에 보내게 된다.
> 3. **발급 기관 이름:** 이 신분증을 발급해 준 **'공인된 기관(CA)'의 이름**이 적혀 있다. 브라우저는 이 기관을 믿을 수 있는지 확인한다.
> 4. **유효 기간:** 이 신분증이 **언제부터 언제까지 유효한지** 적혀 있다. 기간이 지나면 사용할 수 없다.
> 5. **발급 기관의 디지털 서명:** CA가 이 신분증이 **진짜라는 것을 보증하기 위해 찍은 '전자 도장'**&#xC774;다. \
>    브라우저는 이 도장이 진짜인지 확인하여 인증서가 위조되지 않았는지 검증한다.
>
>
>
> #### 클라이언트가 서버 인증서의 **진위 여부**를 확인하기 위해 자체적으로 해시값을 만든다. 이 과정은 다음과 같다.
>
> 1. **원본 내용 추출**: 클라이언트는 서버 인증서에서 **'CA(인증기관)의 디지털 서명' 부분을 제외한 나머지 모든 내용**을 가져온다. 이 부분이 CA가 서명한 원본 데이터이다.
> 2. **해시 함수 사용**: 인증서에 명시된 **동일한 해시 함수(예: SHA-256)**&#xB97C; 사용한다.
> 3. **해시값 계산**: 추출한 **원본 내용을 이 해시 함수에 넣어 계산**한다. 이 과정에는 어떤 키도 필요 없다.

## PKI 인증체계

<figure><img src="../../../../../.gitbook/assets/스크린샷 2024-01-19 16.00.52.png" alt=""><figcaption></figcaption></figure>

* 위와 같이 X509 형식의 SSL 인증서를 통한 인증체계를 PKI 인증체계라고 부른다.&#x20;
* **SSL 인증서의 Hash 값은 CA 의 Private Key 로 암호화 되어있다.**&#x20;
* CA 와 RA&#x20;
  * CA : 인증서 발급과 취소의 실질적인 업무를 하는 기관이다.
  * RA : 사용자의 신분을 확인하고, CA 간 인터페이스를 제공하는 기관이다.&#x20;
