# 섹션6. Django ORM 이해하기

## InconsistenMigrationHistoy 오류

### 문제 상황&#x20;

* Django `user` 모델을 사용하다가 추가적인 컬럼을 넣고 싶어서, `CustomUser(AbstractUser):` 를 추가했다.&#x20;
* 이후, `makemigrations`, `migration` 를 하니 `InconsistenMigrationHistoy` 오류 발생

### 원인&#x20;

* `settings.py` 내 `AUTH_USER_MODEL` 설정은 프로젝트의 첫 번째 `migrate` 명령(Django `user` 모델 사용)을 실행하기 전에 완료해야 한다.&#x20;
* 현재는 첫 번째 `migrate` 명령 후 `AUTH_USER_MODEL` 설정을 변경하였기 때문에, 발생

#### 1단계 : 프로젝트 생성 및 migrate (Django user 모델 적용)&#x20;

* 이때 발생하는 일 :&#x20;
  * Django는 `INSTALLED_APPS`를 순회하며 적용할 마이그레이션 파일들을 찾는다.&#x20;
  * `django.contrib.auth` 앱의 `0001_initial.py` 마이그레이션 파일을 실행한다.
  * 데이터베이스: 실제 `auth_user` 테이블이 생성된다.&#x20;
  * 기록부(DB): `django_migrations`라는 특별한 테이블에 "나 `auth` 앱의 `0001_initial` 파일 적용했음"이라고 영구 기록을 남긴다.&#x20;

#### 2단계 : `CustomUser` 추가 및 설정 변경 (설계도 변경)

* 이때 발생하는 일 :&#x20;
  * AUTH\_USER\_MODEL 설정 추가는 Django에게 "앞으로 'User' 모델의 **주인(Source of Truth)**&#xC740; `django.contrib.auth.models.User`가 아니라, `users.CustomUser`야" 라고 선언한 것이다.&#x20;
  * `AbstractUser`를 상속했기 때문에, Django는 `users.CustomUser`가 _기본 `auth_user` 테이블을 대&#xCCB4;_&#xD574;야 한다고 인지한다.

#### 3단계 : `makemigrations` (새로운 설계도 작성)

* 이때 발생하는 일:
  * Django가 `settings.py`의 `AUTH_USER_MODEL = 'users.CustomUser'` 설정을 읽습니다.
  * 아, User 모델의 주인이 `users` 앱이구나. 그럼 User 테이블을 만드는 새로운 '최초' 설계도가 필요하겠네."
  * `users/migrations/0001_initial.py` 파일을 생성합니다.
  * 중요: 이 `users.0001_initial` 파일은 `auth.0001_initial`과 **'대체 관계'**&#xC785;니다. 둘 다 User 테이블을 만들려는 목적을 가집니다.

#### 4단계 : `migrate` 실행과 `InconsistentMigrationHistory` (충돌 발생)

* Django의 생각 흐름 (오류 발생):
  * "좋아, 마이그레이션을 적용해 볼까."
  * "새로 생긴 `users.0001_initial` 파일을 적용해야겠군. 이 파일은 `CustomUser` 테이블을 만들라는군."
  * "잠깐... 확인 좀 하자. 내 건축 대장(`django_migrations` 테이블)을 보자."
  * "어? 대장에 이미 `auth.0001_initial`이 적용됐다고 기록되어 있네?"
  * "충돌 발생! `auth.0001_initial`(기본 설계도)과 `users.0001_initial`(커스텀 설계도)은 둘 다 '최초'의 `User` 테이블을 만들려는 것들인데, 어떻게 `auth.0001`이 _이미 적&#xC6A9;_&#xB418;어 있을 수가 있지? `users.0001`이 최초여야 하는데!"
  * `InconsistentMigrationHistory` 오류 발생: "마이그레이션 기록이 일치하지 않습니다. `users.0001_initial`을 적용해야 하는데, 이와 충돌하는 `auth.0001_initial`이 이미 적용되어 있습니다."

### 해결 방안

#### 그냥 처음부터 AbstractUser 를 상속받은 User 모델을 만들어라!&#x20;

* **이렇게 되면, `InconsistentMigrationHistory` 문제를 방지하고, 추후 요구사항에 유연하게 반응이 가능하다.**&#x20;
* Django 공식 문서에서도 **"프로젝트를 시작할 때(Start of the project), 커스텀 유저 모델을 설정하는 것을 강력히 권장(Highly recommended)"**&#xD55C;다고 명시하고 있다.&#x20;

## 다대다 관계 이슈

### 문제 상황&#x20;

```python
class Project(models.Model):
    name = models.CharField(max_length=20)
    users = models.ManyToManyField(CustomUser, through='ProjectUser')
```

* 다대다 관계에서 단순히 테이블관 연관 관계만 중요시 한다면 `ManyToManyField` 를 사용해서 단순히 관계만 설정할 수 있다.&#x20;
* 이후, 시간이 지나서 중간 테이블에 `create_at` 과 같은 새로운 컬럼을 추가하고 싶다면, 아래와 같이 중간 테이블 클래스를 생성하고, 기존 `ManyToManyField` 를 사용한 필드에 `through='ProjectUser'` 를 설정하면 된다.&#x20;
* **하지만, 이렇게 하는 경우 기존 중간 테이블에 있던 데이터를 활용하지 못하는 상황이 발생한다.**&#x20;
  * 새로운 테이블이 생성되고, Django 에서 기존 테이블을 사용하지 않도록 동작한다.&#x20;

```python
class ProjectUser(models.Model):
    customuser = models.ForeignKey(CustomUser, on_delete=models.CASCADE)
    project = models.ForeignKey(Project, on_delete=models.CASCADE)
    create_at = models.DateTimeField(auto_now_add=True)
```

### 원인&#x20;

**장고 입장에서는 `through='ProjectUser'` 설정 테이블이 새로운 테이블로 여겨진다.**&#x20;

* 사람 입장에서야 논리적으로 이전 테이블과 설정 테이블이 같은 테이블이라 생각하지만,&#x20;
* 장고는 아니다! (두 개의 테이블을 별개의 테이블로 인식한다)&#x20;

### 해결 방안

* 이런 경우! `SeparateDatabaseAndState` 기능을 사용한다!
  * 데이터베이스와 코드 상태 간의 불일치를 해결하거나 방지하기 위해서 사용한다.&#x20;

```python
dependencies = [
        ('orm', '0004_project'),
    ]

    operations = [
        migrations.SeparateDatabaseAndState(
            # 기존 테이블 이름을 변경
            database_operations=[
                migrations.RunSQL(
                    sql="ALTER TABLE orm_project_users RENAME TO orm_project_user;",
                    reverse_sql="ALTER TABLE orm_project_user RENAME TO orm_project_users;",
                ),
            ],
            state_operations=[
                # ProjectUser 클래스를 생성했고,
                migrations.CreateModel(
                    name='ProjectUser',
                    fields=[
                        ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                        # ('create_at', models.DateTimeField(auto_now_add=True)),
                        ('customuser', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to=settings.AUTH_USER_MODEL)),
                        ('project', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to='orm.project')),
                    ],
                    # 이 클래스를 통해서 orm_project_user 실제 테이블이 생겼다고 장고에게 속이는 것.
                    # 하지만, 실제로는 orm_project_users 테이블 이름을 바꿔서 사용하는 것이다.
                    options={
                        'db_table': 'orm_project_user',
                    },
                ),
                # 지금 만든 클래스를 중간 테이블로 활용하도록 알려준다.
                migrations.AlterField(
                    model_name='project',
                    name='users',
                    field=models.ManyToManyField(through='orm.ProjectUser', to=settings.AUTH_USER_MODEL),
                ),
            ],
        ),
        migrations.AddField(
            model_name="projectuser",
            name='created_at',
            field=models.DateTimeField(auto_now_add=True),
        )
    ]
```

#### `SeparateDatabaseAndState` 방식의 약점

1. 기본 M2M으로 운영하다 데이터가 10만 건 쌓임.
   1. **아예 새로운 테이블을 만들고 데이터를 이관할 수도 있지만, 해당 과정은 데이터가 많을수록 이관에 엄청난 비용이 소모된다.**&#x20;
   2. **때문에, `SeparateDatabaseAndState` 를 통해서 Django 의 state 와 실제 DB 액션을 분리하는 것이 핵심이다.**
2. 추가 요구사항 발생으로 `through` 모델 도입 결정.
3. 대공사 시작:
   1. 기존 테이블 이름 교체
   2. 장고에게 새로운 테이블을 만든다고 속인다.&#x20;
   3. 추가적인 요구사항 컬럼 추가 (약점)&#x20;
      1. **기존 요구 사항에서 없었던 내용이기 때문에, 의미 없는 값이 들어가거나 `null` 값이 들어가는 것을 감수해야 한다.**&#x20;
      2. 기본 M2M으로 운영했던 데이터 10만 건에 대해서 해당 컬럼은 의미가 없다.&#x20;

**결론 :** **처음부터 `through`를 썼다면? 이런 약점이 발생하지 않는다!**

* `InconsistenMigrationHistoy` 이슈 때처럼 유지보수를 고려한 유연한 설계가 필요하다.&#x20;

### BEST PRACTICE

#### 1. 모델을 깔끔하게 관리하고 싶다면, 중개 모델 직접 구현

* 특징 : 코드와 DB 의 내용이 일관적이다.&#x20;
* 장점 : 중개 테이블을 통해 원하는 필드와 메타 정보를 자유롭게 추가 가능&#x20;
* 단점 : 추가 코드 작성이 필요, ORM 기능 제한&#x20;

```python
class UserProjectRelation(models.Model):
    user = models.ForeignKey(CustomUser, on_delete=models.CASCADE)
    project = models.ForeignKey(Profile, on_delete=models.CASCADE)
    created = models.DateTimeField(auto_now_add=True)
```

#### 2. ManyToManyField 사용한다면, 처음부터 `through` 옵션 적용

* 특징 : 코드와 DB 내용의 불일치 발생
  * 코드 내 `Project` 클래스에는 `users` 가 있지만,&#x20;
  * DB 에는 `users` 와 관련된 컬럼이 존재하지 않는다.&#x20;
* 장점 : ORM 에서 최적화된 인터페이스 제공 (`add()`, `remove()`, `clear()`)
* 단점&#x20;
  * 반드시 관계를 나타내는 필드를 추가해야 함&#x20;
  * 확장성 부족(추가 필드가 필요하면 `through` 옵션 사용)

```python
class Project(models.Model):
    name = models.CharField(max_length=20)
    users = models.ManyToManyField(CustomUser, through='ProjectUser')
```

결론 : 2개의 방법 모두 장단점이 있다! \
때문에, 기술적인 우위보다는 **"팀의 약속(Convention)"**&#xACFC; **"코드의 일관성"**&#xC774; 훨씬 중요한 영역이다.&#x20;

## Lazy Loading&#x20;

* 쿼리를 곧바로 실행하지 않고, 객체가 필요한 시점에 가져오는 방식&#x20;
* 결과가 QeurySet 객체로 반환되는 경우, Lazy Loading 적용&#x20;
  * 예외 : `get()`, `count()`, `exixts()` 등&#x20;

> Lazy Loading 은 성능 향상을 위한 최적화&#x20;
>
> * lazy loading 이 적용된 코드는 쿼리가 바로 실행되지 않기 때문에 코드 변경에 따라 쿼리셋이 유연하게 변경 가능하다.&#x20;
> * 하지만, Lazy Loading 을 적용할 때 객체와 관계를 갖는 연관된 객체에 접근하는 경우 N+1 문제가 발생할 수 밖에 없다.&#x20;
> * Lazy Loading 과 N+1 문제는 필연적이다!&#x20;
>
>

```python
queryset = User.objects.filter(id=1) # lazy loading 적용, 아직 쿼리 실행 X 
users = list(queryset) # DB 쿼리 실행 

u1 = User.objects.get(id=1) # DB 쿼리 실행
```

## N+1 문제&#x20;

* Lazy Loading 사용시, 발생할 수 있는 대표적인 성능 저하 문제
* 예: QuerySet 을 순회하며 관계 모델 데이터를 조회할 때 추가 쿼리 발생&#x20;
  * 해결방법 : `select_related()` or `prefetch_related()` 사용

```python
profiles = list(Profile.objects.all()) # 프로필 목록 조회 : DB 쿼리 발생(1회) 

for profile in profiles:
    print(profile.user_id) # 추가 쿼리 발생 X 
    
for profile in profiles: 
    print(profile.user) # 프로필 개수만큼 추가 쿼리 발생(N회)
```

### select\_related()&#x20;

* 즉시 로딩(eager loading) 을 사용하여, 관련 객체들을 단일 쿼리로 한번에 조회&#x20;
* 1:1 관계나, Forward ForeignKey(N:1) 관계에 대해서 사용&#x20;
  * Forward ForeignKey : N의 기준에서 1에 대한 관계&#x20;

```python
# 1:1
profiles = list(Profile.objects.select_related('user').all()) # DB 쿼리 발생(1회)
for profile in profiles: 
    print(profile.user) # 추가 쿼리 발생 X
    
# Order(N) 에서 User(1) 조회하는 경우 
orders = list(Order.objects.select_related(user).all()) # DB 쿼리 발생(1회) 
for order in orders: 
    print(order.user) # 추가 쿼리 발생 X
```

### prefetch\_related()&#x20;

* 추가 쿼리를 통해 연관 객체를 조회, Django 에서 관련 객체 연결&#x20;
* M2M 관계나 Backward ForeignKey 관계에 대해서 사용&#x20;
  * Backward ForeignKey: 1의 기준에서 N에 대한 관계&#x20;

```py
# User(1) 에서 Order(N) 조회하는 경우 
users = list(User.objects.prefetch_related('order_set').all()) # DB 쿼리 발생 
for user in users: 
    for order in user.order_set.all():
        print(order.total_price) # 추가 쿼리 발생 X
        
# User(N) : Project(M) 관계이 경우 
users = list(User.objects.prefetch_related('project_set').all()
for user in users: 
    for project in user.project_est.all(): 
        print(project.name) # 추가 쿼리 발생 X
```

## Index&#x20;

### Django Index 생성&#x20;

1. `db_index=True`: 단일 컬럼 인덱스를 생성할 때 사용
2. &#x20;`Meta.indexs`: 여러 개의 인덱스를 만들 때, 다중 컬럼 인덱스를 만들 때 사용&#x20;

```python
class User(AbstractUser):
    name = models.CharField(max_length=100, db_index=True) 
    age = models.PositiveIntegerField(default=0)
    
    class Meta:
        indexes = [
             models.Index(fields=["name","age"],   
             models.Index(fields=["age"])
        ]
```

### Unique 제약&#x20;

* 중복 값을 허용하지 않도록 강제하는 규칙&#x20;
* **중복된 값이 있는지 빠르게 확인하기 위해 Index 와 동일하게 동작**&#x20;
  * DB 는 해당 Unique 제약이 걸린 컬럼을 기준으로 인덱스를 생성하여 빠르게 중복을 확인할 수 있는 구조를 만든다.&#x20;
  * 때문에, Unique 제약이 걸린 컬럼은 따로 Index 를 설정할 필요가 없다.&#x20;

<figure><img src="../../../../.gitbook/assets/image (259).png" alt=""><figcaption></figcaption></figure>

```python
class User(AbstractUser):
    name = models.CharField(max_length=100, unique=True)
    age = models.PositiveIntegerField(default=0)

    class Meta:
        constraints = [
            models.UniqueConstraints(fields=["name", "age"]),
            models.UniqueConstraints(fields=["age"])
        ]
```

## UUIDField (=Universally Unique Identifier)&#x20;

* 고유한 식별자를 필요로 하는 상황에서 사용
  * 32자리의 16진수이며, 매우 낮은 확률로 중복 발생(거의 0에 가까움)&#x20;
* 기본 PK 사용시 id 값이 URL 에 노출되는데 이를 방지하고 싶을 때 사용
  * 대신 검색 성능을 위해 index 를 생성하는 것이 좋음

```python
class User(AbstractUser): 
    uuid = models.UUIDField(default=uuid.uuid4, editable=False, db_index=True)
```

* 기존: GET `/users/1/`
* 변경: GET `/users/76415073-359f-418d-bbd0-72156561f01b/`

### 우리 예제 코드 적용

* `models.py` 를 아래와 같이 변경하고 `makemigrations` -> `migrate` 를 진행하면, 기존에 없었던 컬럼이 추가되는 것이기 때문에, 모든 로우에 동일한 UUID 값이 들어간다.&#x20;

```python
import uuid

from django.contrib.auth.models import AbstractUser
from django.db import models

class CustomUser(AbstractUser):
    uuid = models.UUIDField(
        default=uuid.uuid4,
        editable=False,
        db_index=True,
    )
```

* 이런 경우 `migrations` 코드를 수정해 각각의 로우에 서로 다른 UUID 값을 할당 받도록 코드를 수정할 필요가 있다.&#x20;

```python
# Generated by Django 5.2.8 on 2025-11-22 07:45

import uuid
from django.db import migrations, models

def add_uuid_to_existing_users(apps, schema_editor):
    CustomUser = apps.get_model('orm', 'CustomUser')

    to_update = []
    for user in CustomUser.objects.all():
        user.uuid = uuid.uuid4()
        to_update.append(user)

    CustomUser.objects.bulk_update(to_update, ["uuid"])

class Migration(migrations.Migration):

    dependencies = [
        ('orm', '0005_projectuser_alter_project_users'),
    ]

    operations = [
        ...
        migrations.AddField(
            model_name='customuser',
            name='uuid',
            field=models.UUIDField(db_index=True, default=uuid.uuid4, editable=False),
        ),
        migrations.RunPython(
            add_uuid_to_existing_users,
            reverse_code=migrations.RunPython.noop
        ),
        ...
    ]
```

* 코드 수정 후, `migrate` 를 실행하면 각각의 로우에 서로 다른 UUID 값이 할당된 것을 볼 수 있다.&#x20;

<figure><img src="../../../../.gitbook/assets/image (1) (1) (1).png" alt=""><figcaption></figcaption></figure>

## ImageField&#x20;

* Django 모델에 이미지를 저장할 수 있는 필드&#x20;
  * **실제 DB 에 이미지를 저장하는 것이 아니라,**&#x20;
  * **이미지가 저장된 경로를 저장한다.**&#x20;
* 컬럼에는 경로가 저장되고, 실제 파일은 Django MEDIA 시스템에 저장&#x20;
* `pip install Pillow`&#x20;

```python
class Profile(models.Model): 
    image = models.ImageField(upload_to='profiles/', null=True)
```

```python
# config/setting.py
MEDIA_ROOT = BASE_DIR/"media" # Media 파일이 저장되는 경로
```

## JSONField

* JSON 데이터를 저장할 수 있게 해주는 필드&#x20;
  * 복잡한 데이터 구조 또는 가변적인 데이터를 저장할 때 유용&#x20;
* **Index 를 생성할 수 없기 때문에 검색 성능이 떨어진다.**

```python
class Profile(models.Model): 
    preferences = models.JSONField(default=dict) 
    
# 사용자 설정 정보 
profile.preferences = {
    'theme':'dark', 
    'motifacations':{'email':True, 'sms':False}, 
    'language':'ko',
}
```

## Django Managers&#x20;

* `objects` : 기본 Manager(예: `CustomUser.objects.all()`)&#x20;
* Manager 를 활용하면 쿼리셋을 정의하거나 커스텀 메서드 구현 가능&#x20;

```python
class CustomUserManager(models.Manager): 
    def with_image(self):
        return super().get_queryset().filter(image__isnull==False)

class CustomUser(Models.Model): 
    ...
    objects = CustomUserManager() 
    
user_with_image = CustomUser.objects.with_image()
```





