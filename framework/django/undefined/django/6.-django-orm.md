# 섹션6. Django ORM 이해하기

## InconsistenMigrationHistoy 오류

### 문제 상황&#x20;

* Django `user` 모델을 사용하다가 추가적인 컬럼을 넣고 싶어서, `CustomUser(AbstractUser):` 를 추가했다.&#x20;
* 이후, `makemigrations`, `migration` 를 하니 `InconsistenMigrationHistoy` 오류 발생

### 원인&#x20;

* `settings.py` 내 `AUTH_USER_MODEL` 설정은 프로젝트의 첫 번째 `migrate` 명령(Django `user` 모델 사용)을 실행하기 전에 완료해야 한다.&#x20;
* 현재는 첫 번째 `migrate` 명령 후 `AUTH_USER_MODEL` 설정을 변경하였기 때문에, 발생

#### 1단계 : 프로젝트 생성 및 migrate (Django user 모델 적용)&#x20;

* 이때 발생하는 일 :&#x20;
  * Django는 `INSTALLED_APPS`를 순회하며 적용할 마이그레이션 파일들을 찾는다.&#x20;
  * `django.contrib.auth` 앱의 `0001_initial.py` 마이그레이션 파일을 실행한다.
  * 데이터베이스: 실제 `auth_user` 테이블이 생성된다.&#x20;
  * 기록부(DB): `django_migrations`라는 특별한 테이블에 "나 `auth` 앱의 `0001_initial` 파일 적용했음"이라고 영구 기록을 남긴다.&#x20;

#### 2단계 : `CustomUser` 추가 및 설정 변경 (설계도 변경)

* 이때 발생하는 일 :&#x20;
  * AUTH\_USER\_MODEL 설정 추가는 Django에게 "앞으로 'User' 모델의 **주인(Source of Truth)**&#xC740; `django.contrib.auth.models.User`가 아니라, `users.CustomUser`야" 라고 선언한 것이다.&#x20;
  * `AbstractUser`를 상속했기 때문에, Django는 `users.CustomUser`가 _기본 `auth_user` 테이블을 대&#xCCB4;_&#xD574;야 한다고 인지한다.

#### 3단계 : `makemigrations` (새로운 설계도 작성)

* 이때 발생하는 일:
  * Django가 `settings.py`의 `AUTH_USER_MODEL = 'users.CustomUser'` 설정을 읽습니다.
  * 아, User 모델의 주인이 `users` 앱이구나. 그럼 User 테이블을 만드는 새로운 '최초' 설계도가 필요하겠네."
  * `users/migrations/0001_initial.py` 파일을 생성합니다.
  * 중요: 이 `users.0001_initial` 파일은 `auth.0001_initial`과 **'대체 관계'**&#xC785;니다. 둘 다 User 테이블을 만들려는 목적을 가집니다.

#### 4단계 : `migrate` 실행과 `InconsistentMigrationHistory` (충돌 발생)

* Django의 생각 흐름 (오류 발생):
  * "좋아, 마이그레이션을 적용해 볼까."
  * "새로 생긴 `users.0001_initial` 파일을 적용해야겠군. 이 파일은 `CustomUser` 테이블을 만들라는군."
  * "잠깐... 확인 좀 하자. 내 건축 대장(`django_migrations` 테이블)을 보자."
  * "어? 대장에 이미 `auth.0001_initial`이 적용됐다고 기록되어 있네?"
  * "충돌 발생! `auth.0001_initial`(기본 설계도)과 `users.0001_initial`(커스텀 설계도)은 둘 다 '최초'의 `User` 테이블을 만들려는 것들인데, 어떻게 `auth.0001`이 _이미 적&#xC6A9;_&#xB418;어 있을 수가 있지? `users.0001`이 최초여야 하는데!"
  * `InconsistentMigrationHistory` 오류 발생: "마이그레이션 기록이 일치하지 않습니다. `users.0001_initial`을 적용해야 하는데, 이와 충돌하는 `auth.0001_initial`이 이미 적용되어 있습니다."

### 해결 방안

#### 그냥 처음부터 AbstractUser 를 상속받은 User 모델을 만들어라!&#x20;

* **이렇게 되면, `InconsistentMigrationHistory` 문제를 방지하고, 추후 요구사항에 유연하게 반응이 가능하다.**&#x20;
* Django 공식 문서에서도 **"프로젝트를 시작할 때(Start of the project), 커스텀 유저 모델을 설정하는 것을 강력히 권장(Highly recommended)"**&#xD55C;다고 명시하고 있다.&#x20;

## 다대다 관계 이슈

### 문제 상황&#x20;

```python
class Project(models.Model):
    name = models.CharField(max_length=20)
    users = models.ManyToManyField(CustomUser, through='ProjectUser')
```

* 다대다 관계에서 단순히 테이블관 연관 관계만 중요시 한다면 `ManyToManyField` 를 사용해서 단순히 관계만 설정할 수 있다.&#x20;
* 이후, 시간이 지나서 중간 테이블에 `create_at` 과 같은 새로운 컬럼을 추가하고 싶다면, 아래와 같이 중간 테이블 클래스를 생성하고, 기존 `ManyToManyField` 를 사용한 필드에 `through='ProjectUser'` 를 설정하면 된다.&#x20;
* **하지만, 이렇게 하는 경우 기존 중간 테이블에 있던 데이터를 활용하지 못하는 상황이 발생한다.**&#x20;
  * 새로운 테이블이 생성되고, Django 에서 기존 테이블을 사용하지 않도록 동작한다.&#x20;

```python
class ProjectUser(models.Model):
    customuser = models.ForeignKey(CustomUser, on_delete=models.CASCADE)
    project = models.ForeignKey(Project, on_delete=models.CASCADE)
    create_at = models.DateTimeField(auto_now_add=True)
```

### 원인&#x20;

**장고 입장에서는 `through='ProjectUser'` 설정 테이블이 새로운 테이블로 여겨진다.**&#x20;

* 사람 입장에서야 논리적으로 이전 테이블과 설정 테이블이 같은 테이블이라 생각하지만,&#x20;
* 장고는 아니다! (두 개의 테이블을 별개의 테이블로 인식한다)&#x20;

### 해결 방안

* 이런 경우! `SeparateDatabaseAndState` 기능을 사용한다!
  * 데이터베이스와 코드 상태 간의 불일치를 해결하거나 방지하기 위해서 사용한다.&#x20;

```python
dependencies = [
        ('orm', '0004_project'),
    ]

    operations = [
        migrations.SeparateDatabaseAndState(
            # 기존 테이블 이름을 변경
            database_operations=[
                migrations.RunSQL(
                    sql="ALTER TABLE orm_project_users RENAME TO orm_project_user;",
                    reverse_sql="ALTER TABLE orm_project_user RENAME TO orm_project_users;",
                ),
            ],
            state_operations=[
                # ProjectUser 클래스를 생성했고,
                migrations.CreateModel(
                    name='ProjectUser',
                    fields=[
                        ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                        # ('create_at', models.DateTimeField(auto_now_add=True)),
                        ('customuser', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to=settings.AUTH_USER_MODEL)),
                        ('project', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, to='orm.project')),
                    ],
                    # 이 클래스를 통해서 orm_project_user 실제 테이블이 생겼다고 장고에게 속이는 것.
                    # 하지만, 실제로는 orm_project_users 테이블 이름을 바꿔서 사용하는 것이다.
                    options={
                        'db_table': 'orm_project_user',
                    },
                ),
                # 지금 만든 클래스를 중간 테이블로 활용하도록 알려준다.
                migrations.AlterField(
                    model_name='project',
                    name='users',
                    field=models.ManyToManyField(through='orm.ProjectUser', to=settings.AUTH_USER_MODEL),
                ),
            ],
        ),
        migrations.AddField(
            model_name="projectuser",
            name='created_at',
            field=models.DateTimeField(auto_now_add=True),
        )
    ]
```

#### `SeparateDatabaseAndState` 방식의 약점

1. 기본 M2M으로 운영하다 데이터가 10만 건 쌓임.
   1. **아예 새로운 테이블을 만들고 데이터를 이관할 수도 있지만, 해당 과정은 데이터가 많을수록 이관에 엄청난 비용이 소모된다.**&#x20;
   2. **때문에, `SeparateDatabaseAndState` 를 통해서 Django 의 state 와 실제 DB 액션을 분리하는 것이 핵심이다.**
2. 추가 요구사항 발생으로 `through` 모델 도입 결정.
3. 대공사 시작:
   1. 기존 테이블 이름 교체
   2. 장고에게 새로운 테이블을 만든다고 속인다.&#x20;
   3. 추가적인 요구사항 컬럼 추가 (약점)&#x20;
      1. **기존 요구 사항에서 없었던 내용이기 때문에, 의미 없는 값이 들어가거나 `null` 값이 들어가는 것을 감수해야 한다.**&#x20;
      2. 기본 M2M으로 운영했던 데이터 10만 건에 대해서 해당 컬럼은 의미가 없다.&#x20;

**결론 :** **처음부터 `through`를 썼다면? 이런 약점이 발생하지 않는다!**

* `InconsistenMigrationHistoy` 이슈 때처럼 유지보수를 고려한 유연한 설계가 필요하다.&#x20;

### BEST PRACTICE

#### 1. 모델을 깔끔하게 관리하고 싶다면, 중개 모델 직접 구현

* 특징 : 코드와 DB 의 내용이 일관적이다.&#x20;
* 장점 : 중개 테이블을 통해 원하는 필드와 메타 정보를 자유롭게 추가 가능&#x20;
* 단점 : 추가 코드 작성이 필요, ORM 기능 제한&#x20;

```python
class UserProjectRelation(models.Model):
    user = models.ForeignKey(CustomUser, on_delete=models.CASCADE)
    project = models.ForeignKey(Profile, on_delete=models.CASCADE)
    created = models.DateTimeField(auto_now_add=True)
```

#### 2. ManyToManyField 사용한다면, 처음부터 `through` 옵션 적용

* 특징 : 코드와 DB 내용의 불일치 발생
  * 코드 내 `Project` 클래스에는 `users` 가 있지만,&#x20;
  * DB 에는 `users` 와 관련된 컬럼이 존재하지 않는다.&#x20;
* 장점 : ORM 에서 최적화된 인터페이스 제공 (`add()`, `remove()`, `clear()`)
* 단점&#x20;
  * 반드시 관계를 나타내는 필드를 추가해야 함&#x20;
  * 확장성 부족(추가 필드가 필요하면 `through` 옵션 사용)

```python
class Project(models.Model):
    name = models.CharField(max_length=20)
    users = models.ManyToManyField(CustomUser, through='ProjectUser')
```

결론 : 2개의 방법 모두 장단점이 있다! \
때문에, 기술적인 우위보다는 **"팀의 약속(Convention)"**&#xACFC; **"코드의 일관성"**&#xC774; 훨씬 중요한 영역이다.&#x20;
