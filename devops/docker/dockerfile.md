# Dockerfile 을 활용해 이미지 직접 만들기

## Dockerfile 이란?&#x20;

Docker 이미지는 Dockerhub 를 통해 다운받아서 사용할 수 있다. 이 Docker 이미지들도 누군가 만들어서 Dockerhub 에 올려놓은 것이다.&#x20;

Dockerfile 을 이용해서 Docker 이미지를 만들 수 있다.&#x20;

Dockerhub 에 올려놓은 Docker 이미지가 아닌, 나만의 Docker 이미지를 만들고 싶을 수 있다.&#x20;

* 예를 들어, 내가 만든 Spring Boot 프로젝트가 있다. 내가 만든 Spring Boot 프로젝트 자체를 Docker 이미지로 만들고 싶을 수 있다.&#x20;
* 이럴 때에도 Dockerfile 을 활용하면 나만의 Docker 이미지를 만들 수 있다.&#x20;

Dockerfile 은 Docker 이미지를 만들게 해주는 역할이다.&#x20;

## FROM : 베이스 이미지 생성&#x20;

### 의미

`FROM` 은 베이스 이미지를 생성하는 역할을 한다.&#x20;

Docker 컨테이너를 특정 초기 이미지를 기반으로 추가적인 세팅을 할 수 있다. 여기서 이야기한 '특정 초기 이미지' 가 곧 베이스 이미지이다.&#x20;

### 사용법&#x20;

```docker
# FROM [이미지명]
# FROM [이미지명]:[태그명]
FROM eclipse-temurin:17-jdk

# 도커 파일 기반으로 빌드 
$ docker build -t my-jdk17-server
# 빌드한 이미지 실행
$ docker run -d my-jdk17-server
```

> #### 종료된 컨테이너에 들어가서 디버깅하고 싶을 때&#x20;
>
> Docker 를 사용하면 대부분의 코드가 컨테이너 내부에서 동작한다.&#x20;
>
> 때문에, 어떤 과정으로 처리했는지, 잘 처리는 되었는지를 직접적으로 눈에 보이지 않는다. 이 때문에, Docker 학습에 어려움을 겪는다.&#x20;
>
> 이를 해결하기 위해서 우리는 2가지 방법을 이미 익혔다.&#x20;
>
> * `docker logs` 를 활용해 컨테이너 로그 확인하기
> * `docker exec -it` 를 활용해 컨테이너 내부에 직접 들어가보기
>
> 위 방법 중 `docker exec -it` 는 실행 중인 컨테이너에만 쓸 수 있는 명령어이다. 종료된 컨테이너에서는 오류가 발생한다.&#x20;
>
> 때문에 아래 명령어를 마지막에 추가함으로 컨테이너가 바로 종료되는 것을 막을 수 있다.&#x20;
>
> * 그런 뒤에 `docker exec -it` 명령어를 통해 컨테이너 내부에 직접 들어가서 디버깅하면 된다.&#x20;
>
> `ENTRYPOINT ["/bin/bash", "-c", "sleep 500"] # 500초 동안 시스템을 일시정지 시키는 명령어`

## COPY : 파일 복사(이동)&#x20;

### 의미&#x20;

`COPY` 는 호스트 컴퓨터에 있는 파일을 복사해서 컨테이너로 전달한다.&#x20;

## 사용법&#x20;

```docker
# 문법
COPY [호스트 컴퓨터에 있는 복사할 파일의 경로] [컨테이너에서 파일이 위치할 경로]

# 예시
COPY app.txt /app.txt
```

## ENTRYPOINT : 컨테이너가 시작할 때 실행되는 명령어

### 의미&#x20;

`ENTRYPOINT` 는 컨테이너가 생성되고 최초로 실행할 때 수행되는 명령어를 뜻한다. 쉽게 설명하면 `ENTRYPOINT` 에는 미니 컴퓨터 전원을 키고나서 실행시키고 싶은 명령어를 적으면 된다.&#x20;

### 사용법&#x20;

```docker
# 문법
ENTRYPOINT [명령문...]

# 예시
ENTRYPOINT ["node", "dist/main.js"]
```

## RUN : 이미지를 생성하는 과정에서 사용할 명령문 실행&#x20;

### 의미&#x20;

`RUN` 은 이미지 생성 과정에서 명령어를 실행시켜야 할 때 사용한다.&#x20;

### 사용법&#x20;

```docker
# 문법
RUN [명령문]

# 예시
RUN npm install
```

> #### RUN vs ENTRYPOINT
>
> `RUN` 명령어와 `ENTRYPOINT` 명령어가 헷갈릴 때가 있다.&#x20;
>
> 둘 다 같이 명령어를 실행시키기 때문이다. 하지만 엄연히 둘의 사용 용도는 다르다.
>
> `RUN` 은 ‘이미지 생성 과정’에서 필요한 명령어를 실행시킬 때 사용하고, `ENTRYPOINT` 는 생성된 이미지를 기반으로 컨테이너를 생성한 직후에 명령어를 실행시킬 때 사용한다.

## WORKDIR : 작업 디렉토리를 지정&#x20;

### 의미&#x20;

`WORKDIR` 으로 작업 디렉터리를 전환하면 그 이후에 등장하는 모든 `RUN` , `CMD` , `ENTRYPOINT` , `COPY` , `ADD` 명령문은 해당 디렉터리를 기준으로 실행된다.&#x20;

작업 디렉터리를 굳이 지정해주는 이유는 컨테이너 내부의 폴더를 깔끔하게 관리하기 위해서이다.&#x20;

컨테이너도 미니 컴퓨터와 같기 때문에 Dockerfile 을 통해 생성되는 파일들을 특정 폴더에 정리해두는 것이 추후에 관리가 쉽다. 만약 `WORKDIR` 을 쓰지 않으면 컨테이너 내부에 존재하는 기존 파일들과 뒤섞여버린다.

### 사용법&#x20;

```docker
FROM ubuntu

WORKDIR /my-dir

COPY ./ ./

ENTRYPOINT ["/bin/bash", "-c", "sleep 500"]
```

## EXPOSE : 컨테이너 내부에서 사용 중인 포트를 문서화하기&#x20;

### 의미&#x20;

`EXPOSE` 는 컨테이너 내부에서 어떤 포트에 프로그램이 실행되는 지를 문서화하는 역할만 한다. `docker -p 8080:8080 …` 와 같은 명령어의 `-p` 옵션과 같은 역할은 일체 하지 않는다.&#x20;

쉽게 표현하자면 `EXPOSE` 명령어는 쓰나 안 쓰나 작동하는 방식에는 영향을 미치지 않는다.

### 사용법&#x20;

```docker
# 문법
EXPOSE [포트 번호]

# 예시
EXPOSE 3000
```
