# GC 튜닝

> 참고 링크&#x20;
>
> [https://inpa.tistory.com/entry/JAVA-%E2%98%95-%EA%B0%80%EB%B9%84%EC%A7%80-%EC%BB%AC%EB%A0%89%EC%85%98-GC-%ED%8A%9C%EB%8B%9D-%EB%A7%9B%EB%B3%B4%EA%B8%B0](https://inpa.tistory.com/entry/JAVA-%E2%98%95-%EA%B0%80%EB%B9%84%EC%A7%80-%EC%BB%AC%EB%A0%89%EC%85%98-GC-%ED%8A%9C%EB%8B%9D-%EB%A7%9B%EB%B3%B4%EA%B8%B0)

* Java 가 C 언어에 비해 속도 차이가 나는 이유는 JVM 에 있는데, 미리 바이너리 코드로 컴파일 되는 C 언어에 비해서 자바는 바이트 코드라는 중간 단계 컴파일을 해석하는데 있어 시간이 소요되기 때문이다.&#x20;
* 그리고 무엇보다 자바 어플리케이션의 성능의 가장 큰 비중을 차지하는게 바로 GC 의 stop-the-world 이다..&#x20;
* GC 성능을 향상시키기 위해서 성능 좋은 GC 알고리즘을 선택하면 되지만, 이도 문제가 해결이 안된다면 비로서 GC 튜닝 이라는 것을 해야한다!&#x20;

## GC 튜닝의 주의점

### 첫째, GC 튜닝 옵션은 서비스의 특징 마다 적정 값이 다르다는 것이다. &#x20;

* 예를 들어 '누가 이 옵션값을 사용했을 때 성능이 잘 나왔으니, 우리도 이렇게 적용하자' 라고 생각하면 절대 안된다!
* 왜냐하면 서비스 주제와 특징마다 생성되는 객체의 크기도 다르고 살아있는 기간도 다르기 때문이다.&#x20;
* 따라서 별도의 성능 모니터링을 통해서, 어느 지점에서 GC stop-the-world 문제가 나는지 서비스마다 제각각 파악하여 GC 튜닝을 해야한다.&#x20;

### 둘째, GC 튜닝은 가장 마지막에 하는 작업이라는 것이다.&#x20;

* GC 튜닝은 필요한 선행 지식과, 신경써야할 요소, 리스크에 비해서 얻어가는 부분이 적기 때문에, GC 튜닝보다 애플리케이션 코드로써 메모리 최적화를 더 신경 쓸것을 권장하자는 의견도 있다.&#x20;
* GC 튜닝을 근본적으로 왜할까?&#x20;
  * 일반적으로 Java 에서 생성된 객체는 GC 를 통해서 메모리를 해제한다.&#x20;
  * 즉, 생성된 객체가 많으면 많을수록 GC 가 처리해야 하는 대상도 많아지고, 횟수도 많아진다는 소리이다.&#x20;
  * 그리고, GC 의 수행 횟수가 늘어나면 stop-the-world 횟수도 많아지니 성능에 영향이 가게 된다.&#x20;
* 따라서 GC 튜닝을 하기 전에, 쓸모없는 객체 생성을 줄이는 리팩토링 작업이 선행되어야 근본적이 해결이 될 수 있다.&#x20;

## GC 튜닝의 목표&#x20;

### 첫째, Old 영역으로 넘어가는 객체의 수 최소화하기!&#x20;

* 기본적으로 Old 영역의 크기는 Young 영역의 크기보다 훨씬 거대하다.&#x20;
* 따라서, Old 영역의 GC 는 Young 영역의 GC 에 비해서 상대적으로 긴 시간이 소요되기 때문에, 애초에 Old 영역으로 이동하는 객체의 수를 줄이면 Full GC 가 발생하는 빈도를 많이 줄일 수 있게 된다.&#x20;
* 이말은 즉, Young 영역의 크기를 잘 조절하여, Old 영역으로 넘어가는 빈도를 줄이면 큰 효과를 볼 수 있다는 의미이다.&#x20;

### 둘째, Full GC 시간 줄이기&#x20;

* Full GC 의 실행 시간은 상대적으로 Minor GC 에 비해서 길기 때문에, Old 영역의 크기를 적절하게 설정하는 것도 하나의 방법이다.&#x20;
* 그렇다고 Old 영역의 크기를 막 줄여버리면 자칫 OutOfMemoryError 가 발생하거나, Full GC 횟수가 늘어날 수 있다.&#x20;
* 반대로 Old 영역의 크기를 늘리면 Full GC 횟수는 줄어들지만 실행 시간이 늘어나게 된다.&#x20;
* 즉, GC 튜닝의 포인트는 이 둘 사이를 잘 아우리는 적정 범위를 찾는 것이라고 할 수 있다.&#x20;

## GC 튜닝 맛보기&#x20;

### 1. GC 상황 모니터링&#x20;

* jstat 명령어는 JDK 1.6 부터 제공되는 기본 모니터링 및 분석 툴이다.&#x20;

```bash
# jstat -gcutil  명령어로 현재 실행중인 8884번 프로세스에 대해 
# 1초에 한번 씩 총 10번 GC와 관련된 정보를 출력하도록 모니터링
jstat -gcutil -t 8844 1000 10
```

<figure><img src="../../../../../../.gitbook/assets/스크린샷 2024-09-24 19.03.25.png" alt=""><figcaption></figcaption></figure>

<figure><img src="../../../../../../.gitbook/assets/스크린샷 2024-09-24 19.04.09.png" alt=""><figcaption></figcaption></figure>

### 2.모니터링 결과 분석 후 GC 튜닝 여부 결정정&#x20;

* GC 상황을 확인한 후에는, 결과를 분석하고 GC 튜닝 여부를 결정해야 한다.&#x20;
  * Minor GC 수행시간 : YGCT / YGC (0.314 / 19) = 0.016초&#x20;
  * Major GC 수행시간 : FGCT / FGC (0.291 / 3) = 0.097초&#x20;

<figure><img src="../../../../../../.gitbook/assets/스크린샷 2024-09-24 19.10.46.png" alt=""><figcaption></figcaption></figure>

* 만약 모니터링 결과가 다음의 조건에 모두 부합한다면, GC 튜닝이 굳이 필요하지는 않다.&#x20;
  * **Minor GC 처리 시간이 빠르다. (50ms 내외)**&#x20;
  * **Minor GC 주기가 빈번하지 않다. (10초 내외)**&#x20;
  * **Full GC 처리 시간이 빠르다. (1초 내외)**&#x20;
  * **Full GC 주기가 빈번하지 않다. (10분에 1회)**&#x20;

