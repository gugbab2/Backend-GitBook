# HashMap vs TreeMap

## 1. 내부 데이터 구조&#x20;

* HashMap&#x20;
  * 구조 : HashMap 은 해시 테이블 기반으로 데이터를 저정한다.&#x20;
  * 해시 함수 : 해시 함수를 사용하여 키의 해시코드를 계산하고, 이 해시코드를 인덱스로 삼아 데이터를 저장한다.&#x20;
  * 버킷 : 해시 테이블은 여러 개의 버킷을 가지고 있으며, 갓 버킷은 `LinkedList` 나 `Tree` 로 구성될 수 있다.(해시 충돌 해결을 위해서) \
    \-> 자세한 내용은 조금 더 공부해보자&#x20;
* TreeMap&#x20;
  * 구조 : `TreeMap` 은 레드-블랙 트리를 사용해서 데이터를 저장한다.&#x20;
  * 정렬 : 레드-블랙 트리는 이진 검색 트리의 일종으로, 데이터가 항상 정렬된 상태를 유지한다.&#x20;
  * 비교 : `TreeMap` 은 기본적으로 `Comparable` 인터페이스를 구현한 키들로 정렬되거나, 사용자가 제공한 `Comparator` 를 사용하여 정렬된다.&#x20;

## 2. 정렬 및 순서&#x20;

* HashMap&#x20;
  * 정렬 : 요소들이 저장된 순서와 무관하며, 저장된 순서나 정렬 순서가 보장되지 않는다.&#x20;
  * 순서 보장 : 순서가 보장되지 않기 때문에, `HashMap` 은 데이터를 임의의 순서로 반환할 수 있다.&#x20;
* TreeMap&#x20;
  * 정렬 : 요소들이 키의 자연 순서 또는 사용자가 지정한 순서로 정렬되어 저장된다.&#x20;
  * 순서 보장 : `TreeMap` 은 데이터를 정렬된 순서로 반환한다. 이를 통해 범위 검색 등 정렬된 데이터를 처리할 수 있다.&#x20;

## 3. 시간 복잡도&#x20;

* HashMap&#x20;
  * 검색, 삽입, 삭제 : 평균적으로 O(1) 의 시간 복잡도를 가지며, 해시 충돌이 적절히 처리될 경우 매우 빠르다.&#x20;
  * Worst-case : 해시 충돌이 많은 경우, 최악의 경우 시간 복잡도가 O(n) 이 될 수 있다.&#x20;
* TreeMap
  * 검색, 삽입, 삭제 : O(log n) 의 시간 복잡도를 가진다. 레드-블랙 트리의 깊이에 비례한다.&#x20;
  * 범우 검색 : 범위 검색이나 정렬된 데이터를 처리하는데 유용하다.&#x20;

## 4. 성능&#x20;

* HashMap&#x20;
  * 속도 : 해시 테이블 기반으로 되어 있어 평균적으로 빠른 성능을 제공한다.&#x20;
  * 메모리 : 해시 테이블은 메모리 사용이 비효율적일 수 있으며, 해시 충돌 해결을 위해서 추가 메모리를 사용할 수 있다.&#x20;
* TreeMap&#x20;
  * 속도 : 트리 구조로 인해 HashMap 보다 삽입, 삭제, 검색이 다소 느릴 수 있다.(O(log n))
  * 정렬 : 데이터가 정렬된 상태로 유지되기 때문에, 정렬된 데이터에 대한 작업이 효율적이다.&#x20;

## 5. 사용 사례&#x20;

* HashMap&#x20;
  * 데이터의 순서가 중요하지 않고, 빠른 검색, 삽입, 삭제가 필요한 경우에 사용된다.&#x20;
* TreeMap&#x20;
  * 데이터가 정렬되어야 하거나, 범위 검색과 같은 데이터 처리 작업이 필요한 경우에 사용된다.&#x20;
