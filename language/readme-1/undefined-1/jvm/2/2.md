# 2장 - 자바 메모리 영역과 메모리 오버플로

## 2.1 들어가며

메모리 관리 측면에서 C, C++ 개발자는 전권을 가진 황제인 동시에 잡다한 막노동도 직접 하는 일꾼이라 할 수 있다. 객체 각각의 '소유권' 뿐 아니라 객체의 일생을 탄생부터 죽음까지 관리할 책임을 함께 지기 때문이다.&#x20;

한편 자바 개발자는 가상 머신이 제공하는 자동 메모리 관리 메커니즘 덕에 미모리 할당과 해제를 짝지어 코딩하지 않아도 메모리 누수나 오버플로 문제를 거의 겪지 않는다. 하지만 통제권을 위임했기 때문에 발생하는 단점ㅇ도 있다.&#x20;

## 2.2 런타임 데이터 영역&#x20;

자바 가상 머신은 자바 프로그램을 실행하는 동안 필요한 메모리를 몇 개의 데이터 영역으로 나눠 관리한다. 이 영역들은 각각 목적과 생성/삭제 시점이 있다.&#x20;

<figure><img src="../../../../../.gitbook/assets/스크린샷 2025-07-10 15.20.24.png" alt=""><figcaption></figcaption></figure>

### 2.2.1 프로그램 카운터(PC Register)&#x20;

프로그램 카운터 레지스터는 작은 메모리 영역으로, 현재 실행 중인 스레드의 '바이트코드 줄 번호 표시기' 라고 생각하면 쉽다. 자바 가상 머신의 개념 모형(가상 머신의 '일반적인' 형태) 에서, 바이트코드 인터프리터는 이 카운터의 값을 바꿔 다음에 실행할 바이트코드 명령어를 선택하는 식으로 동작한다.&#x20;

프로그램의 제어 흐름, 분기, 순환, 점프 등을 표현하는 것이다. 예외 처리나 스레드 복원 같은 모든 기본 기능이 바로 이 표시기를 활용해 이루어진다.&#x20;

자바 가상 머신에서의 멀티스레딩은 CPU 코어를 여러 스레드가 교대로 사용하는 방식으로 구현되기 때문에 특정 시각에 각 코어는 한 스레드의 명령어만 실행하게 된다. 따라서 스레드 전환 후 이전에 실행하다 멈춘 지점을 정확하게 복원하려면 스레드 각각에는 고유한 프로그램 카운터가 필요하다. 따라서 각 스레드의 카운터는 서로 영향을 주지 않는 독립된 영역에 저장된다. (스레드 프라이빗 : 스레드 별로 저장)

스레드가 자바 메서드를 실행 중일 때는 실행 중인 바이트코드 명령어의 주소가 프로그램 카운터에 기록된다. 한편 스레드 네이티브 메서드를 실행 중일 때 프로그램 카운터의 값은 Undifined 이다. '정의되지 않음' 이란 뜻이다.&#x20;

프로그램 카운터 메모리 영역은 "자바 가상 머신 명세" 에서 OutOfMemoryError 조건이 명시되지 않은 유일한 영역이기도 하다.&#x20;

### 2.2.2 자바 가상 머신 스택 (JVM Stack)&#x20;

프로그램 카운터처럼 자바 가상 머신 스택도 '스레드 프라이빗' 하며, 연결된 스레드와 운명을 같이 한다.

가상 머신 스택은 자바 메서드를 실행하는 스레드의 메모리 모델을 설명해준다. 각 메서드가 호출될 때마다 자바 가상 머신은  스택 프레임(Stack Frame) 을 만들어 **지역 변수 테이블, 피연산자 스택, 동적 링크, 메서드 반환값** 등의 정보를 저장한다. 그리고 스택 프레임을 가상 머신 스택에 푸시(push) 메서드가 끝나면 팝(pop) 하는 일을 반복한다.&#x20;

자바의 메모리 영역을 힙 메모리와 스택 메모리로 구분하는 사람이 많다. 이 구분법은 전통적인 C, C++ 프로그램의 메모리 구조에서 기인한 것으로, 자바 언어를 설명하기에는 무리가 있다. (자바의 메모리 영역 구분은 훨씬 복잡하다)&#x20;

**지역 변수 테이블**에는 자바 가상 머신이 컴파일타임에 알 수 있는 다양한 기본 데이터 타입, 객체 참조, 반환 주소 타입을 저장한다. **지역 변수 테이블을 구성하는 데 필요한 데이터 공간은 컴파일 과정에서 할당된다. 자바 메서드는 스택 프레임에서 지역 변수용으로 할당받아야 할 공간의 크기가 이미 완벽하게 결정되어 있다. 메서드 실행 중에는 절대 변하지 않는다.**&#x20;

"자바 가상 머신 명세" 는 스택 메모리 영역에서 두 가지 오류가 발생할 수 있도록 정의했다.&#x20;

* 첫째, 스레드가 요청한 스택 깊이가 가상 머신이 허용하는 깊이보다 크면 StackOverflowError 를 던진다.&#x20;
* 둘째, 스택 용량을 동적으로 확장할 수 있는 자바 가상 머신(클래식 VM) 에서는 스택을 확장하려는 시점에 여유 메모리가 충분하지 않다면 OutOfMemoryError 를 던진다.&#x20;

### 2.2.3 네이티브 메서드 스택 (Native Method Area)&#x20;

네이티브 메서드 스택은 가상 머신 스택과 매우 비슷한 역할을 한다. 차이점이라면 가상 머신 스택은 자바 메서드(바이트코드) 를 실행할 때 사용하고, 네이비트 메서드 스택은 네이티브 메서드를 실행할 때 사용한다는 것이다.&#x20;

"자바 가상 머신 명세" 는 네이티브 메서드 스택에서 메서드를 어떤 구조로 어떻게 표현해야 하는지와 관련하여 아무것도 명시하지 않았다. 따라서 가상 머신 구현자가 원하는 형태로 자유롭게 표현할 수 있다.&#x20;

그래서 네이티브 메서드 스택과 가상 머신 스택을 하나로 합쳐 놓은 가상 머신도 있다. (핫스팟 VM 포함)

가상 머신 스택처럼 네이티브 메서드 스택도 스택 허용 깊이를 초과하면 StackOverflowError, 스택 확장에 실패하면 OutOfMemoryError 를 던질 수 있다.&#x20;

### 2.2.4 자바 힙 (Heap)

자바 힙은 자바 애플리케이션이 사용할 수 있는 가장 큰 메모리이다. 자바 힙은 모든 스레드가 공유하며 가상 머신이 구동될 때 만들어진다. **이 메모리 영역의 유일한 목적은 객체 인스턴스를 저장하는 것**이고, 자바 세계의 '거의' 모든 객체 인스턴스가 이 영역에 할당된다.&#x20;

"자바 가상 머신 명세" 에는 "모든 객체 인스턴스와 배열은 힙에 할당된다" 라고 적혀 있다. 하지만 그럼에도 '거의'라고 표현한 이유는 구현 관점에서 자바 언어가 계속 발전하면서 앞으로는 값 타입도 지원할 것으로 보인다. (일단은 추측일 뿐)

"자바 가상 머신 명세" 의 자바 힙 절에는 세부 영역 구분에 관한 이야기 자체가 없다.&#x20;

여러 문헌에서 "자바 가상 머신의 힙 메모리는 신시대, 영구 세대, 에덴, 생존자 공간 등으로 나뉜다." 라고 설명한다. G1 컬렉터가 등장한 2010년 전후로 핫스팟 가상 머신은 업계에서 확고한 주류가 되었고, 핫스팟의 GC 들은 모두 전통적인 세대 구분을 따랐다. 당시라면 앞의 설명이 크게 틀린게 없다.&#x20;

하지만 오늘날의 GC 기술은 그 시절에 머물러 있지 않는다. 심지어 핫스팟에도 세대 단위 설계에 따르지 않는 컬렉터가 포함되어 있다. 따라서 앞의 설명은 따져볼게 많은 상황이다.&#x20;

"자바 가상 머신 명세" 에 따르면 자바 힙은 물리적으로 떨어진 메모리에 위치해도 상관 없으나 **논리적으로는 연속되어야 한다.** 파일을 저장할 때 디크스 공간을 활용하는 방식과 같다. 하지만 대다수 가상 머신이 큰 객체는 물리적으로도 연속된 메모리 공간을 사용하도록 구현한다. 저장 효율을 높이고 구현 로직을 단순하게 유지하게 위해서이다.&#x20;

자바 힙은 크기를 고정할 수도, 확장할 수도 있게 구현할 수 있다. 요즘 주류 가장 머신들은 모두 확장 가능한 형태로 구현되어 있다. 새로운 인스턴스에 할당해 줄 힙 공간이 부족하고 힙을 더는 확장할 수 없다면 OutOfMemoryError 를 던진다.&#x20;

### 2.2.5 메서드 영역 (Method Area)&#x20;

메서드 영역도 자바 힙처럼 모든 스레드가 공유한다. 메서드 영역은 가상 머신이 읽어 들인 타입 정보, 상수, 정적 변수 그리고 JIT 컴파일러가 컴파일한 코드 캐시 등을 저장하는데 사용된다.&#x20;

"자바 가상 머신 명세" 에서는 메서드의 영역도 논리적으로는 힙의 한 부분으로 기술하지만, 자바 힙과 구분하기 위해서 'non-heap' 이라고 부르기도 한다.&#x20;

메서드 영역을 설명하려면 Permanent Generation 이야기를 하지 않을 수 없다. 특히 JDK 7까지는 많은 자바 개발자가 핫스팟 가상 머신용으로 프로그램을 개발하고 배포했다. 그리고 당시 많은 사람이 메서드 영역을 Permanent Generation 라고 부르며 두 개념을 혼동했다.&#x20;

사실 이 둘은 같지 않다.. 당시 핫스팟 VM 개발 팀은 GC 수집 범위를 메서드 영역까지 확장하기로 결정했다. 그래서 메서드 영역을 Permanent Generation 구현했을 뿐이다. 그 결과로 핫스팟 VM 의 GC 는 메서드 영역을 마치 자바 힙처럼 관리할 수 있었고, 그 덕분에 메서드 영역을 관리하는 코드가 따로 필요 없으니 작업량을 줄일 수 있었다.&#x20;

* **Permanent Generation 이 과거 핫스팟 VM 에서 메서드 영역의 구현체로 사용되었던 특정 메모리 공간의 이름일 뿐이다.**&#x20;

하지만 다른 VM 의 경우 애초부터 Permanent Generation 라는 개념이 없었다. "자바 가상 머신 명세" 가 특정 방식을 강제하지 않았던 터라, 원칙적으로 메서드 영역을 어떻게 구현할지는 가상 머신을 구현하는 쪽에서 정하면 될 사안이었다.&#x20;

지금에 와서 돌이켜 보면 메서드 영역을 Permanent Generation 에 구현한 결정은 좋은 생각이 아니었다. 이 설계 때문에, 자바 애플리케이션들이 메모리 오버플로를 겪을 가능성이 커졌기 때문이다. Permanent Generation의 최대 크기는 -XX:MaxPermSize 로 제한되며, 이 값을 설정하지 않았더라도 기본값이 정해져있다.&#x20;

* **시스템이 복잡하고 커져가면 메서드 영역의 사용량은 커져갔고, 적절한 크기 예측은 매우 어려운 일이다..**

JDK 6 시절, 핫스팟 개발 팀은 핫스팟의 미래를 위해 Permanent Generation 를 포기하고 점진적으로 메서드 영역을 네이티브 메모리에 구현할 계획을 세운다. 그래서 JDK 7 에 이르러 핫스팟은 그 전에 Permanent Generation 에서 관리하던 문자열 상수와 정적 변수 등의 정보를 자바 힙으로 옮겼다. JDK 8 에 와서는 Permanent Generation 라는 개념을 지우고, 네이티브 메모리에 Metaspace 를 구현했다. JDK 7 까지 Permanent Generation 에 남아 있던 모든 데이터를 Metaspace 로 옮긴 것이다.&#x20;

"자바 가상 머신 명세" 는 메서드 영역에 제약을 거의 두지 않았다. 자바 힙과 마찬가지로 연속될 필요가 없으며, 크기를 고정할 수도 있고, 확장 가능하게 만들 수도 있다. 심지어 가비지 컬렉션을 하지 않아도 괜찮다. 솔직히 이 영역에서 GC 는 거의 이루어지지 않는다. 그렇다고 메서드 영역에 한번 들어온 데이터가 '영구적' 이라는 뜻은 아니다.&#x20;

메서드 영역에서 회수할 대상은 거의 대부분 상수 풀과 타입이라서, 회수 효과가 상대적으로 적다.&#x20;

"자바 가상 머신 명세" 에 따르면 메서드 영역이 꽉 차서 필요한 만큼 메모리를 감당할 수 없다면 OutOfMemoryError 를 던진다.&#x20;

### 2.2.6 런타임 상수 풀&#x20;

런타임 상수 풀은 메서드 영역의 일부다. 상수 풀 테이블에는 클래스 버전, 필드, 메서드, 인터페이스 등 클래스 파일에 포함된 설명 정보에 더해 컴파일 타임에 생성된 다양한 리터럴과 심벌 참조가 저장된다. 가상 머신이 클래스를 로드할 때 이러한 정보를 메서드 영역의 런타임 상수 풀에 저장한다.&#x20;

자바 가상 머신은 (상수 풀을 포함해) 클래스 파일의 각 영역별로 엄격한 규칙을 정해 놓았다. 다만 런타임 상수 풀에 대해서는 "자바 가상 머신 명세" 가 요구 사항을 상세하게 정의하지 않아서 가상 머신 제공자가 입맛에 맞게 구현할 수 있다.&#x20;

클래스 파일의 상수 풀과 비교해 런타임 상수 풀의 중요한 특징이 하나 더 있다. 바로 동적이라는 점이다. 자바 언어에서는 상수가 꼭 컴파일타임에 생성되어야 한다는 규칙이 없다. 즉, 상수 풀의 내용 전부가 클래스 파일에 미리 완벽하게 기술되어 있는 것이 아니라는 점이다. 런타임에도 메서드 영역의 런타임 상수 풀에 새로운 상수가 추가될 수 있다.&#x20;

* 개발자들이 많이 사용하는 String 클래스의 intern() 메서드에 바로 이 특성이 반영되어 있다.&#x20;

런타임 상수 풀은 메서드 영역에 속하므로 자연스럽게 메서드 영역을 넘어서까지 확장될 수는 없다. 그래서 상수 풀의 공간이 부족하면 OutOfMemoryError 를 던진다.&#x20;

### 2.2.7 다이렉트 메모리&#x20;

다이렉트 메모리는 가상 머신 런타임에 속하지 않으며 "자바 가상 머신 명세" 에도 정의된 영역이 아니다. 하지만 자주 쓰이는 메모리이며 OutOfMemoryError 의 원인이 될 수도 있어서 지금 설명하겠다.&#x20;

JDK 1.4 에서 NIO 가 도입되면서 채널과 버퍼 기반 I/O 메서드가 소개되었다. NIO 는 힙이 아닌 메모리를 직접 할당할 수 있는 네이티브 함수 라이브러리를 이용하며, 이 메모리에 저장되어 있는 DirectByteBuffer 객체를 통해 작업을 수행할 수 있다. 따라서 자바 힙과 네이티브 힙 사이에서 데이터를 복사해 주고받지 않아도 돼서 일부 시나리오에서 성능을 크게 개선했다.&#x20;

물리 메모리를 직접 할당하기 때문에, 힙 크기 제약과는 무관하지만 이 역시 메모리라는 사실에는 변함이 없다. 따라서 하부 기기의 총 메모리 용량과 프로세서가 다룰 수 있는 주소 공간을 넘어설 수는 없다..&#x20;

하지만, 서버 관리자들이 가상 머신의 메모리 크기만 고려할 뿐, 다이렉트 메모리는 간과하는 경우가 제법 있다. 사용되는 모든 메모리 영역의 합이 물리 메모리 한계를 넘어서면 동적 확장을 시도할 때 OutOfMemoryError 가 발생한다.&#x20;

## 2.3 핫스팟 가상 머신에서의 객체 들여다보기&#x20;

런타임 데이터 영역에 이어서 알아볼 주제는 메모리 모델이다. 이왕이면 실용적인 학습이 되도록 보편적인 핫스팟 VM, 자바 힙을 예로 들어보자.&#x20;

### 2.3.1 객체 생성



