# 2장 - 자바 메모리 영역과 메모리 오버플로

## 2.1 들어가며

메모리 관리 측면에서 C, C++ 개발자는 전권을 가진 황제인 동시에 잡다한 막노동도 직접 하는 일꾼이라 할 수 있다. 객체 각각의 '소유권' 뿐 아니라 객체의 일생을 탄생부터 죽음까지 관리할 책임을 함께 지기 때문이다.&#x20;

한편 자바 개발자는 가상 머신이 제공하는 자동 메모리 관리 메커니즘 덕에 미모리 할당과 해제를 짝지어 코딩하지 않아도 메모리 누수나 오버플로 문제를 거의 겪지 않는다. 하지만 통제권을 위임했기 때문에 발생하는 단점ㅇ도 있다.&#x20;

## 2.2 런타임 데이터 영역&#x20;

자바 가상 머신은 자바 프로그램을 실행하는 동안 필요한 메모리를 몇 개의 데이터 영역으로 나눠 관리한다. 이 영역들은 각각 목적과 생성/삭제 시점이 있다.&#x20;

<figure><img src="../../../../../.gitbook/assets/스크린샷 2025-07-10 15.20.24.png" alt=""><figcaption></figcaption></figure>

### 2.2.1 프로그램 카운터(PC Register)&#x20;

프로그램 카운터 레지스터는 작은 메모리 영역으로, 현재 실행 중인 스레드의 '바이트코드 줄 번호 표시기' 라고 생각하면 쉽다. 자바 가상 머신의 개념 모형(가상 머신의 '일반적인' 형태) 에서, 바이트코드 인터프리터는 이 카운터의 값을 바꿔 다음에 실행할 바이트코드 명령어를 선택하는 식으로 동작한다.&#x20;

프로그램의 제어 흐름, 분기, 순환, 점프 등을 표현하는 것이다. 예외 처리나 스레드 복원 같은 모든 기본 기능이 바로 이 표시기를 활용해 이루어진다.&#x20;

자바 가상 머신에서의 멀티스레딩은 CPU 코어를 여러 스레드가 교대로 사용하는 방식으로 구현되기 때문에 특정 시각에 각 코어는 한 스레드의 명령어만 실행하게 된다. 따라서 스레드 전환 후 이전에 실행하다 멈춘 지점을 정확하게 복원하려면 스레드 각각에는 고유한 프로그램 카운터가 필요하다. 따라서 각 스레드의 카운터는 서로 영향을 주지 않는 독립된 영역에 저장된다. (스레드 프라이빗 : 스레드 별로 저장)

스레드가 자바 메서드를 실행 중일 때는 실행 중인 바이트코드 명령어의 주소가 프로그램 카운터에 기록된다. 한편 스레드 네이티브 메서드를 실행 중일 때 프로그램 카운터의 값은 Undifined 이다. '정의되지 않음' 이란 뜻이다.&#x20;

프로그램 카운터 메모리 영역은 "자바 가상 머신 명세" 에서 OutOfMemoryError 조건이 명시되지 않은 유일한 영역이기도 하다.&#x20;

### 2.2.2 자바 가상 머신 스택 (JVM Stack)&#x20;

프로그램 카운터처럼 자바 가상 머신 스택도 '스레드 프라이빗' 하며, 연결된 스레드와 운명을 같이 한다.

가상 머신 스택은 자바 메서드를 실행하는 스레드의 메모리 모델을 설명해준다. 각 메서드가 호출될 때마다 자바 가상 머신은  스택 프레임(Stack Frame) 을 만들어 **지역 변수 테이블, 피연산자 스택, 동적 링크, 메서드 반환값** 등의 정보를 저장한다. 그리고 스택 프레임을 가상 머신 스택에 푸시(push) 메서드가 끝나면 팝(pop) 하는 일을 반복한다.&#x20;

자바의 메모리 영역을 힙 메모리와 스택 메모리로 구분하는 사람이 많다. 이 구분법은 전통적인 C, C++ 프로그램의 메모리 구조에서 기인한 것으로, 자바 언어를 설명하기에는 무리가 있다. (자바의 메모리 영역 구분은 훨씬 복잡하다)&#x20;

**지역 변수 테이블**에는 자바 가상 머신이 컴파일타임에 알 수 있는 다양한 기본 데이터 타입, 객체 참조, 반환 주소 타입을 저장한다. **지역 변수 테이블을 구성하는 데 필요한 데이터 공간은 컴파일 과정에서 할당된다. 자바 메서드는 스택 프레임에서 지역 변수용으로 할당받아야 할 공간의 크기가 이미 완벽하게 결정되어 있다. 메서드 실행 중에는 절대 변하지 않는다.**&#x20;

"자바 가상 머신 명세" 는 스택 메모리 영역에서 두 가지 오류가 발생할 수 있도록 정의했다.&#x20;

* 첫째, 스레드가 요청한 스택 깊이가 가상 머신이 허용하는 깊이보다 크면 StackOverflowError 를 던진다.&#x20;
* 둘째, 스택 용량을 동적으로 확장할 수 있는 자바 가상 머신(클래식 VM) 에서는 스택을 확장하려는 시점에 여유 메모리가 충분하지 않다면 OutOfMemoryError 를 던진다.&#x20;

### 2.2.3 네이티브 메서드 스택 (Native Method Area)&#x20;

네이티브 메서드 스택은 가상 머신 스택과 매우 비슷한 역할을 한다. 차이점이라면 가상 머신 스택은 자바 메서드(바이트코드) 를 실행할 때 사용하고, 네이비트 메서드 스택은 네이티브 메서드를 실행할 때 사용한다는 것이다.&#x20;

"자바 가상 머신 명세" 는 네이티브 메서드 스택에서 메서드를 어떤 구조로 어떻게 표현해야 하는지와 관련하여 아무것도 명시하지 않았다. 따라서 가상 머신 구현자가 원하는 형태로 자유롭게 표현할 수 있다.&#x20;

그래서 네이티브 메서드 스택과 가상 머신 스택을 하나로 합쳐 놓은 가상 머신도 있다. (핫스팟 VM 포함)

가상 머신 스택처럼 네이티브 메서드 스택도 스택 허용 깊이를 초과하면 StackOverflowError, 스택 확장에 실패하면 OutOfMemoryError 를 던질 수 있다.&#x20;

### 2.2.4 자바 힙 (Heap)

자바 힙은 자바 애플리케이션이 사용할 수 있는 가장 큰 메모리이다. 자바 힙은 모든 스레드가 공유하며 가상 머신이 구동될 때 만들어진다. **이 메모리 영역의 유일한 목적은 객체 인스턴스를 저장하는 것**이고, 자바 세계의 '거의' 모든 객체 인스턴스가 이 영역에 할당된다.&#x20;

"자바 가상 머신 명세" 에는 "모든 객체 인스턴스와 배열은 힙에 할당된다" 라고 적혀 있다. 하지만 그럼에도 '거의'라고 표현한 이유는 구현 관점에서 자바 언어가 계속 발전하면서 앞으로는 값 타입도 지원할 것으로 보인다. (일단은 추측일 뿐)

"자바 가상 머신 명세" 의 자바 힙 절에는 세부 영역 구분에 관한 이야기 자체가 없다.&#x20;

여러 문헌에서 "자바 가상 머신의 힙 메모리는 신시대, 영구 세대, 에덴, 생존자 공간 등으로 나뉜다." 라고 설명한다. G1 컬렉터가 등장한 2010년 전후로 핫스팟 가상 머신은 업계에서 확고한 주류가 되었고, 핫스팟의 GC 들은 모두 전통적인 세대 구분을 따랐다. 당시라면 앞의 설명이 크게 틀린게 없다.&#x20;

하지만 오늘날의 GC 기술은 그 시절에 머물러 있지 않는다. 심지어 핫스팟에도 세대 단위 설계에 따르지 않는 컬렉터가 포함되어 있다. 따라서 앞의 설명은 따져볼게 많은 상황이다.&#x20;

"자바 가상 머신 명세" 에 따르면 자바 힙은 물리적으로 떨어진 메모리에 위치해도 상관 없으나 **논리적으로는 연속되어야 한다.** 파일을 저장할 때 디크스 공간을 활용하는 방식과 같다. 하지만 대다수 가상 머신이 큰 객체는 물리적으로도 연속된 메모리 공간을 사용하도록 구현한다. 저장 효율을 높이고 구현 로직을 단순하게 유지하게 위해서이다.&#x20;

자바 힙은 크기를 고정할 수도, 확장할 수도 있게 구현할 수 있다. 요즘 주류 가장 머신들은 모두 확장 가능한 형태로 구현되어 있다. 새로운 인스턴스에 할당해 줄 힙 공간이 부족하고 힙을 더는 확장할 수 없다면 OutOfMemoryError 를 던진다.&#x20;

### 2.2.5 메서드 영역 (Method Area)&#x20;

메서드 영역도 자바 힙처럼 모든 스레드가 공유한다. 메서드 영역은 가상 머신이 읽어 들인 타입 정보, 상수, 정적 변수 그리고 JIT 컴파일러가 컴파일한 코드 캐시 등을 저장하는데 사용된다.&#x20;

"자바 가상 머신 명세" 에서는 메서드의 영역도 논리적으로는 힙의 한 부분으로 기술하지만, 자바 힙과 구분하기 위해서 'non-heap' 이라고 부르기도 한다.&#x20;

메서드 영역을 설명하려면 Permanent Generation 이야기를 하지 않을 수 없다. 특히 JDK 7까지는 많은 자바 개발자가 핫스팟 가상 머신용으로 프로그램을 개발하고 배포했다. 그리고 당시 많은 사람이 메서드 영역을 Permanent Generation 라고 부르며 두 개념을 혼동했다.&#x20;

사실 이 둘은 같지 않다.. 당시 핫스팟 VM 개발 팀은 GC 수집 범위를 메서드 영역까지 확장하기로 결정했다. 그래서 메서드 영역을 Permanent Generation 구현했을 뿐이다. 그 결과로 핫스팟 VM 의 GC 는 메서드 영역을 마치 자바 힙처럼 관리할 수 있었고, 그 덕분에 메서드 영역을 관리하는 코드가 따로 필요 없으니 작업량을 줄일 수 있었다.&#x20;

* **Permanent Generation 이 과거 핫스팟 VM 에서 메서드 영역의 구현체로 사용되었던 특정 메모리 공간의 이름일 뿐이다.**&#x20;

하지만 다른 VM 의 경우 애초부터 Permanent Generation 라는 개념이 없었다. "자바 가상 머신 명세" 가 특정 방식을 강제하지 않았던 터라, 원칙적으로 메서드 영역을 어떻게 구현할지는 가상 머신을 구현하는 쪽에서 정하면 될 사안이었다.&#x20;

지금에 와서 돌이켜 보면 메서드 영역을 Permanent Generation 에 구현한 결정은 좋은 생각이 아니었다. 이 설계 때문에, 자바 애플리케이션들이 메모리 오버플로를 겪을 가능성이 커졌기 때문이다. Permanent Generation의 최대 크기는 -XX:MaxPermSize 로 제한되며, 이 값을 설정하지 않았더라도 기본값이 정해져있다.&#x20;

* **시스템이 복잡하고 커져가면 메서드 영역의 사용량은 커져갔고, 적절한 크기 예측은 매우 어려운 일이다..**

JDK 6 시절, 핫스팟 개발 팀은 핫스팟의 미래를 위해 Permanent Generation 를 포기하고 점진적으로 메서드 영역을 네이티브 메모리에 구현할 계획을 세운다. 그래서 JDK 7 에 이르러 핫스팟은 그 전에 Permanent Generation 에서 관리하던 문자열 상수와 정적 변수 등의 정보를 자바 힙으로 옮겼다. JDK 8 에 와서는 Permanent Generation 라는 개념을 지우고, 네이티브 메모리에 Metaspace 를 구현했다. JDK 7 까지 Permanent Generation 에 남아 있던 모든 데이터를 Metaspace 로 옮긴 것이다.&#x20;

"자바 가상 머신 명세" 는 메서드 영역에 제약을 거의 두지 않았다. 자바 힙과 마찬가지로 연속될 필요가 없으며, 크기를 고정할 수도 있고, 확장 가능하게 만들 수도 있다. 심지어 가비지 컬렉션을 하지 않아도 괜찮다. 솔직히 이 영역에서 GC 는 거의 이루어지지 않는다. 그렇다고 메서드 영역에 한번 들어온 데이터가 '영구적' 이라는 뜻은 아니다.&#x20;

메서드 영역에서 회수할 대상은 거의 대부분 상수 풀과 타입이라서, 회수 효과가 상대적으로 적다.&#x20;

"자바 가상 머신 명세" 에 따르면 메서드 영역이 꽉 차서 필요한 만큼 메모리를 감당할 수 없다면 OutOfMemoryError 를 던진다.&#x20;

### 2.2.6 런타임 상수 풀 (Runtime Constant Pool)

런타임 상수 풀은 메서드 영역의 일부다. 상수 풀 테이블에는 클래스 버전, 필드, 메서드, 인터페이스 등 클래스 파일에 포함된 설명 정보에 더해 컴파일 타임에 생성된 다양한 리터럴과 심벌 참조가 저장된다. 가상 머신이 클래스를 로드할 때 이러한 정보를 메서드 영역의 런타임 상수 풀에 저장한다.&#x20;

자바 가상 머신은 (상수 풀을 포함해) 클래스 파일의 각 영역별로 엄격한 규칙을 정해 놓았다. 다만 런타임 상수 풀에 대해서는 "자바 가상 머신 명세" 가 요구 사항을 상세하게 정의하지 않아서 가상 머신 제공자가 입맛에 맞게 구현할 수 있다.&#x20;

클래스 파일의 상수 풀과 비교해 런타임 상수 풀의 중요한 특징이 하나 더 있다. 바로 동적이라는 점이다. 자바 언어에서는 상수가 꼭 컴파일타임에 생성되어야 한다는 규칙이 없다. 즉, 상수 풀의 내용 전부가 클래스 파일에 미리 완벽하게 기술되어 있는 것이 아니라는 점이다. 런타임에도 메서드 영역의 런타임 상수 풀에 새로운 상수가 추가될 수 있다.&#x20;

* 개발자들이 많이 사용하는 String 클래스의 intern() 메서드에 바로 이 특성이 반영되어 있다.&#x20;

런타임 상수 풀은 메서드 영역에 속하므로 자연스럽게 메서드 영역을 넘어서까지 확장될 수는 없다. 그래서 상수 풀의 공간이 부족하면 OutOfMemoryError 를 던진다.&#x20;

### 2.2.7 다이렉트 메모리&#x20;

다이렉트 메모리는 가상 머신 런타임에 속하지 않으며 "자바 가상 머신 명세" 에도 정의된 영역이 아니다. 하지만 자주 쓰이는 메모리이며 OutOfMemoryError 의 원인이 될 수도 있어서 지금 설명하겠다.&#x20;

JDK 1.4 에서 NIO 가 도입되면서 채널과 버퍼 기반 I/O 메서드가 소개되었다. NIO 는 힙이 아닌 메모리를 직접 할당할 수 있는 네이티브 함수 라이브러리를 이용하며, 이 메모리에 저장되어 있는 DirectByteBuffer 객체를 통해 작업을 수행할 수 있다. 따라서 자바 힙과 네이티브 힙 사이에서 데이터를 복사해 주고받지 않아도 돼서 일부 시나리오에서 성능을 크게 개선했다.&#x20;

물리 메모리를 직접 할당하기 때문에, 힙 크기 제약과는 무관하지만 이 역시 메모리라는 사실에는 변함이 없다. 따라서 하부 기기의 총 메모리 용량과 프로세서가 다룰 수 있는 주소 공간을 넘어설 수는 없다..&#x20;

하지만, 서버 관리자들이 가상 머신의 메모리 크기만 고려할 뿐, 다이렉트 메모리는 간과하는 경우가 제법 있다. 사용되는 모든 메모리 영역의 합이 물리 메모리 한계를 넘어서면 동적 확장을 시도할 때 OutOfMemoryError 가 발생한다.&#x20;

## 2.3 핫스팟 가상 머신에서의 객체 들여다보기&#x20;

런타임 데이터 영역에 이어서 알아볼 주제는 메모리 모델이다. 이왕이면 실용적인 학습이 되도록 보편적인 핫스팟 VM, 자바 힙을 예로 들어보자.&#x20;

### 2.3.1 객체 생성

자바는 객체 지향 프로그래밍 언어다. 자바 프로그램이 동작하는 동안 언제든 수시로 객체가 만들어진다. 언어 수준에서 객체 생성은 보통 단순히 new 키워드를 쓰면 끝난다. 그렇다면 가상 머신 수준에서는 과연 어떤 과정을 거쳐 객체(배열과 Class 객체가 아닌 일반적인 자바 객체) 가 생성될까?&#x20;

자바 가상 머신이 new 명령에 해당하는 바이트코드를 만나면, 이 명령의 매개 변수가 상수 풀 안의 클래스를 가리키는 심벌 참조인지 확인한다. 그런 다음 심벌 참조가 뜻하는 클래스 로딩, 해석(resolve), 초기화(initialize) 가 되었는지 확인한다. 준비되지 않은 클래스라면 로딩부터 해야 한다. (클래스 로딩에 관한 내용은 이후에 살펴보자)

> ### 런타임 상수 풀(Runtime Constant Pool)
>
> 자바 클래스 파일(`.class` 파일)에는 **상수 풀(Constant Pool)**&#xC774;라는 특별한 영역이 있다. 이 상수 풀은 클래스 파일이 필요로 하는 모든 종류의 상수 데이터를 저장하는 곳으로, 여기에는 다음과 같은 정보들이 포함될 수 있다.
>
> * 리터럴(Literal) 값: 문자열, 숫자(정수, 실수) 등 직접적인 상수 값
> * 클래스 및 인터페이스 이름: `java/lang/Object`, `MyClass`와 같은 클래스 이름의 심벌 참조
> * 필드(Field) 참조: 어떤 클래스의 어떤 필드를 참조하는지에 대한 심벌 참조
> * 메서드(Method) 참조: 어떤 클래스의 어떤 메서드를 참조하는지에 대한 심벌 참조
>
> 이러한 정보들은 실제 메모리 주소가 아니라, 심벌릭(Symbolic)한 형태로 저장된다.
>
> 예를 들어, `MyClass`라는 문자열은 실제 `MyClass` 클래스의 메모리 주소가 아니라, "MyClass"라는 이름 자체를 나타내는 심벌이다.&#x20;
>
>
>
> ### `new` 명령과 심벌 참조
>
> `new` 명령은 새로운 객체를 생성할 때 사용되는 바이트코드 명령어로, 이 명령어는 어떤 클래스의 인스턴스를 생성할지 알아야 한다. 이때 그 클래스 정보를 바로 메모리 주소로 가지고 있는 것이 아니라, 상수 풀에 있는 심벌 참조를 통해 간접적으로 가리킨다.

로딩이 완료된 클래스라면 새 객체를 담을 메모리를 할당한다. 객체에 필요한 메모리 크기는 클래스를 로딩하고 나면 완벽하게 알 수 있다. 객체용 메모리 공간 할당은 자바 힙에서 특정 크기의 메모리 블럭을 잘라주는 일이라고 할 수 있다.&#x20;

자바 힙이 완벽히 규칙적이라고 가정하면 사용 중인 메모리는 모두 한쪽에, 여유 메모리는 반대편에 자리하여, 포인터가 두 영역의 경계인 가운데 지점을 가리키게 될 것이다. 이 상태에서 메모리를 할당하면 포인터를 여유 공간 쪽으로, 정확히 객체 크기만큼 이동시키게 된다. 이러한 할당 방식을 포인터 밀치기(bump the pointer)라고 한다.&#x20;

<figure><img src="../../../../../.gitbook/assets/image.png" alt=""><figcaption></figcaption></figure>

**하지만 자바 힙은 규칙적이지 않다.** 사용 중인 메모리와 여유 메모리가 뒤섞여 있어서, 포인터를 밀쳐 내기가 그리 간단하지 않다. 그 대신 가상 머신은 가용 메모리 블록들을 목록으로 따로 관리하여, 객체 인스턴스를 담기에 충분한 공간을 찾아 할당한 후 목록을 갱신한다. 이 할당 방식을 여유 목록(free list) 이라 한다.&#x20;

어떤 방식을 사용할지는 자바 힙이 규칙적이냐 아니냐에 따라 달라지며, 자바 힙이 규칙적이냐는 사용하는 GC 가 Compact(요약) 를 할 수 있느냐에 따라 달렸다.&#x20;

가용 공간을 어떻게 나눌지 외에도 고민할게 남았다. 가상 머신에서 객체 생성은 매우 빈번하게 일어난다. 더욱이 멀티스레딩 환경에서는 여유 메모리의 시작 포인터 위치를 수정하는 단순한 일도 스레드 안전하지 않기 때문에, 여러 스레드가 동시에 객체를 생성하려고 할 때 문제가 발생할 수 있다.&#x20;

해법은 두가지이다.&#x20;

* 첫번째는 메모리 할당을 동기화하는 방법이다. 실제로 비교 및 교환(CAS)과 실패 시 재시도 방식의 가상 머신은 갱신을 원자적으로 수행한다.&#x20;
* 두번째는 스레드마다 다른 메모리 공간을 할당하는 방법이다. 스레드 각각이 자바 힙 내에 작은 크기의 전용 메모리를 미리 할당 받아놓는 것이다. 이런 메모리를 **스레드 로컬 할당 버퍼(TLAB)** 라고 한다. 각 스레드는 로컬 버퍼에서 메모리를 할당 받아 사용하다가 버퍼가 부족해지면 그때 동기화를 해 새로운 버퍼를 할당받는 식이다. 가상 머신이 스레드 로컬 할당 버퍼를 사용할지는 -XX:+/-UseTLAB 매개 변수로 설정한다.&#x20;

<figure><img src="../../../../../.gitbook/assets/image (1).png" alt=""><figcaption></figcaption></figure>

메모리 할당이 끝났으면 가상 머신은 할당받은 공간을 0으로 초기화한다.

* 자바 코드에서 객체의 인스턴스 필드를 초기화하지 않고도 사용할 수 있는 이유가 바로 이 단계 덕이다.&#x20;
* 모든 필드가 자연스럽게 각 데이터 타입에 해당하는 0 값을 담고 있게 되는 것이다.&#x20;

다음 단계로 자바 가상 머신은 '각 객체에 필요한 설정' 을 해준다.&#x20;

* 예를 들어, 어느 클래스의 인스턴스인지, 클래스의 메타 정보는 어떻게 찾는지, 이 객체의 해시 코드는 무엇인지, GC 세대 나이는 얼마인지 등의 정보가 여기 속한다.&#x20;
* 이런 정보는 인스턴스의 헤더에 저장된다.&#x20;
* 인스턴스의 부가 정보를 초기화하는 과정이라 생각하면 될 것 같다.&#x20;

이상의 과정이 끝났다면 가상 머신 관점에서는 새로운 객체가 다 만들어진 셈이다. 하지만 자바 프로그램 관점에서는 이제부터가 시작이다. 생성자가 아직 실행되지 않았고, 모든 필드는 기본값인 0 인 상태다. 그리고 객체로서 구실을 하기 위한 여러 자원과 상태 정보 역시 아직 개발자의 의도대로 구성되지 못했다. **일반적으로 new 명령어에 이어서 \<init>() 메서드까지 실행되어 객체를 개발자의 의도대로 초기화해야 비로서 사용 가능한 진짜 객체가 완성된다.**&#x20;

* \<init>() 메서드 : 생성자

### 2.3.2 객체 메모리 레이아웃&#x20;

핫스팟 VM 은 객체를 세 부분으로 나눠 힙에 저장한다.&#x20;

* 객체 헤더
* 인스턴스 데이터&#x20;
* 길이 맟추기용 정렬 패딩&#x20;

<figure><img src="../../../../../.gitbook/assets/image (2).png" alt=""><figcaption></figcaption></figure>

#### 객체 헤더&#x20;

핫스팟 VM 은 객체 헤더에 두 유형의 정보를 담는다.&#x20;

* 첫번째 유형은 객체 자체의 런타임 데이터이다. 해시 코드, GC 세대 나이, 랏 상태 플래그, 스레드가 점유하고 있는 락들, 등등.. 이 부분을 마크 워크(mark work) 라고 하며 차지하는 크기는 32비트 가상 머신에서는 32비트이고, 62비트 가상 머신에서는 64비트이다. \
  객체는 아주 많은 런타임 데이터를 필요로해서, 사실 32비트, 64비트 구조에는 모두 담을 수 없다. 그래서 마크 워드의 데이터 구조는 동적으로 의미가 달라진다. 작은 공간에 가능한 많은 정보를 담고, 객체 상태에 따라 공간을 재활용할 수도 있게 하기 위해서다.&#x20;
* 두번째 유형은 클래스 워드(klass word) 가 온다. 클래스 워드에는 객체의 클래스 관련 메타데이터를 가리키는 클래스 포인터가 저장된다. 자바 가상 머신은 이 포인터를 통해 특정 객체가 어느 클래스의 인스턴스인지 런타임에 알 수 있다.
* 세번째 유형은 자바 배열의 경우 배열의 길이도 객체 해더에 저장한다. 위치는 클래스 워드 다음이다. &#x20;

#### 인스턴스 데이터&#x20;

객체 레이아웃의 두 번쨰 부분인 인스턴스 데이터는 객체가 실제로 담고 있는 정보다. (프로그램 코드에서 정의한 인스턴스 관련 내용)&#x20;

#### 정렬 패딩&#x20;

이 부분은 존재하지 않을 수도 있으며, 특별한 의미 없이 자리를 확보하는 역할만 한다.&#x20;

핫스팟 VM 의 자동 메모리 관리 시스템에서 객체의 시작 주소는 반드시 8바이트의 정수배여야 하는데, 인스턴스 데이터가 조건을 충족하지 못하는 경우에만 패딩을 채운다.&#x20;

### 2.3.3 객체에 접근하기&#x20;

대다수 객체는 다른 객체 여러 개를 조합해 만들어진다. 그리고 자바 프로그램은 스택에 있는 참조 데이터를 통해 힙에 들어 있는 객체들에 접근해 이를 조작한다.&#x20;

"자바 가상 머신 명세" 는 참조 타입을 단지 '객체를 가리키는 참조' 라고만 정했을 뿐, 힙에서 객체의 정확한 위치를 알아내어 접근하는 구체적인 방법은 규정하지 않았다. 따라서 객체에 접근하는 방식 역시 가상 머신에서 구현하기 나름이며 주로 핸들이나 다이렉트 포인터를 사용해 구현한다.&#x20;

핸들 방식의 가장 큰 장점은 참조에 '안정적인' 핸들의 주소가 저장된다는 것이다. GC 과정에서 객체가 이동하는 과정은 매우 흔하다. 핸들을 이용하면 이렇게 객체의 위치가 바뀌는 상황에서도 참조 자체는 손댈 필요가 없다. 그 대신 핸들내의 인스턴스 데이터 포인터만 변경하면 된다.&#x20;

<figure><img src="../../../../../.gitbook/assets/image (3).png" alt=""><figcaption></figcaption></figure>

다이렉트 포인터 방식에서는 자바 힙에 위치한 객체에서 인스턴스 데이터뿐 아니라 타입 데이터에 접근하는 길도 제공해야 한다. 스택의 참조에는 객체의 실제 주소가 바로 저장되어 있다.&#x20;

다이렉트 포인터 방식의 가장 큰 장점은 속도다. 핸들을 경유하는 오버헤드가 없기 때문이다. 자바에서는 다른 객체에 접근할 일이 아주 많기 때문에 이 오버헤드도 실행 시간에 영향을 크게 줄 수 있다.&#x20;

이 책의 주된 논의 대상인 핫스팟 VM 은 주로 다이렉트 포인터 방식을 사용한다.&#x20;

<figure><img src="../../../../../.gitbook/assets/image (4).png" alt=""><figcaption></figcaption></figure>

## 2.4 실전 : OutOfMemoryError 예외&#x20;

"자바 가상 머신 명세" 에 따르면 가상 머신 메모리의 여러 런타임 영역에서 OutOfMemoryError 가 날 수 있다. 이번 절에서는 OutOfMemoryError 가 실제로 발생하는 시나리오를 확인할 것이다.&#x20;

메모리 오버플로는 가상 머신을 어떻게 구현하느냐에 크게 의존하며, 언제 어떻게 발생하는지가 모두 자바 언어 차원에서 합의된 동작이 아니라는 점을 기억해야 한다.&#x20;

### 2.4.1 자바 힙 오버플로&#x20;

자바 힙은 객체 인스턴스를 저장하는 공간이다. 객체를 계속 생성하고 그 객체에 접근할 경로가 살아 있다면 언젠가는 힙의 최대 용량을 넘어설 것이다. 그러면 메모리가 오버플로 된다.&#x20;

실제로 자바 애플리케이션에서 OutOfMemoryError 가 가장 많이 발생하는 영역이 자바 힙이다. 자바 힙에서 오버플로가 발생하면 'java.lang.OutOfMemoryError' 메시지 옆에 'Java heap space' 라고 출력될 것이다.&#x20;

이 메모리 문제를 해결하는 일반적인 방법은 메모리 이미지 분석 도구로 힙 덤프 스냅숏을 분석해 보는 것이다.&#x20;

* 첫번째로 '오버플로를 일으킨 객체가 꼭 필요한 객체인가' 확인해야 한다. 다시 말해 메모리 누수인지, 오버플로인지 확인한다. 필요 없는 개체가 원인이라면 메모리 누수이다. \
  메모리 누수라면 도구를 이용해 누수된 객체로부터 GC 루트까지의 참조 사슬(reference chain)을 살펴본다.
* 두번째로 메모리 누수가 아니라면 컴퓨터가 가용메모리를 확인해 가상 머신에 메모리를 더 많이 할당할 수 있는지 알아본다. 그 다음에는 코드에서 수명 주기가 너무 길거나 상태를 너무 오래 유지하는 객체가 없는지, 공간 낭비가 심한 데이터 구조를 쓰고 있지 않은지 살펴 프로그램이 런타임에 소비하는 메모리를 최소로 낮춘다.&#x20;

### 2.4.2 가상 머신 스택과 네이티브 메서드 스택 오버플로

핫스팟 VM 은 가상 머신 스택과 네이티브 메서드 스택을 구분하지 않는다. 때문에 스택 크기는 오직 -Xss 매개 변수로만 변경할 수 있다.&#x20;

"자바 가상 머신 명세" 에 따르면 가상 머신 스택과 네이티브 메서드 스택에서는 다음 두가지 경우에만 예외가 발생한다.&#x20;

1. 스레드가 요구하는 스택 깊이가 가상 머신이 허용하는 최대 깊이보다 크면 StackOverflowError 를 던진다.&#x20;
2. 가상 머신이 스택 메모리를 동적으로 확장하는 기술을 지원하나, 가용 메모리가 부족해 스택을 더 이상 확장할 수 없다면 OutOfMemoryError 를 던진다.&#x20;

"자바 가상 머신 명세" 에서는 분명 스택을 동적으로 확장할 수 있는 여지를 두었지만 핫스팟 가상 머신은 확장을 지원하지 않는다. 따라서 다음의 상황이 발생한다.&#x20;

1. 스레드를 만들 공간이 부족하면 OutOfMemoryError 발생&#x20;
2. 이미 만들어진 스레드가 자신의 고정된 스택 공간이 다 쓰면 StackOverflowError 발생

### 2.4.3 메서드 영역과 런타임 상수 풀 오버플로&#x20;

JDK 6 까지 메서드 영역은 Permanent Generation 으로 구현되어 고정된 크기로 사용하기 때문에, 오버플로가 발생할 가능성이 컷지만 JDK 7 부터 Permanent Generation 를 점진적으로 없애기 시작했고 JDK 8 부터는 Metaspace 로 완전히 대체되어 네이티브 메모리를 사용하게 되었다. Metaspace 부터 동적으로 메모리 할당이 가능했기 때문에, 오버플러 문제는 거의 해결되었다.&#x20;

### 2.4.4 네이티브 다이렉트 메모리 오버플로&#x20;

해당 영역은 네이티브 메모리 영역에 해당하기 때문에, 힙 덤프 파일에서는 이상한 점을 찾을 수 없다. 때문에 해당 케이스에는 네이티브 메모리에서 원인을 찾는데 집중해야 한다.
