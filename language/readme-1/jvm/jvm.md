# JVM 구조 이해하기

> #### 참고 링크&#x20;
>
> [https://docs.oracle.com/javase/specs/jvms/se20/html/jvms-2.html#jvms-2.1](https://docs.oracle.com/javase/specs/jvms/se20/html/jvms-2.html#jvms-2.1)

<figure><img src="../../../.gitbook/assets/image (41).png" alt=""><figcaption></figcaption></figure>

* 자바의 코드가 운영체제에서 실행되기 위해서는 아래의 과정을 거친다.
* 자바 소스코드 -> 자바 컴파일러 -> 바이트코드 -> **JVM** -> 기계어 -> 하드웨어 및 OS

## 1. 클래스 로더 시스템

* **클래스 파일을 읽어들여서 메모리에 적절하게 배치하는 일을 한다.**
* 로딩 : 클래스 파일에서 바이트 코드를 읽고, 적절한 데이터를 메모리에 올린다.\
  \-> ex) 메서드 영역 : 클래스 수준 정보, 힙 영역 : 인스턴스
* 링크 : 래퍼런스(참조)를 연결하는 과정.
* 초기화 : static 값을 초기화 및 변수에 할당

## 2. 메모리

### 2-1. 공유하는 자원(라이프 사이클이 프로세스와 동일하다)&#x20;

#### 메소드&#x20;

* 클래스 수준의 정보(클래스 이름(풀패키지 경로), 부모 클래스 이름, 메소드, 변수 등)를 저장한다.
* 메소드 영역은 논리적으로는 힙 영역의 일부분이지만, GC 대상을 선택하지 않을 수 있다.&#x20;
* 해당 영역은 런타임 상수 풀을 포함한다.(Constant Pool)
* **대부분의 메소드 영역의 데이터는 JVM 종료까지 유지된다.**&#x20;

#### 힙

* 힙은 모든 클래스 인스턴스와 배열의 메모리가 할당되는 런타임 데이터 영역이다.&#x20;
* 힙 영역의 인스턴스는 명시적으로 회수되지 않고, GC 에 의해 회수된다.&#x20;

### 2-2. 쓰레드 단위로 존재하는 자원

#### **스택**

* **쓰레드마다 런타임 스택을 만들고**, 그 안에 메소드 호출을 스택 프레임(콜스택) 이라 부르는 블럭으로 쌓는다.   &#x20;

#### **PC(Program Counter) 레지스터**&#x20;

* 쓰레드 마다 쓰레드 내 현재 실행할 스택 프레임을 가리키는 포인터가 생성된다.

#### **네이티브 메서드 스택**

* 네이티브 메서드를 저장한다. (네이티브 메서드 : C, C++ 로 작성된 라이브러리)
* 네이티브 메서드 인터페이스와 네이티브 메서드 라이브러리와 항상 함께 동작한다.
* **네이테브 메서드는 JVM 이 코드를 해석하거나 컴파일 하지 않고, 운영 체제에 맡겨서 실행한다.**&#x20;

## 3. 실행엔진

* **인터프리터** : 바이트코드를 이해하고 한줄 씩 실행한다.
* **JIT(Just In Time) 컴파일러** : 인터프리터에서 사용되는 반복되는 바이트코드가 발견되며, JIT 컴파일러로 반복되는 코드를 네이티브코드로 바꾸어준다. 그 다음부터 인터프리터는 JIT 컴파일러에 의해서 컴파일 된 네이티브코드를 사용한다.\
  \-> **프로그램 속도를 높여준다.**\
  \-> **캐시와 비슷..**
* **GC(Garbage Collector)** : 더 이상 참조되지 않는 객체들을 모아서 정리한다.

## 4. 그 외..

* **JNI(Java Native Interface)** : 네이티브 메서드를 호출할 수 있도록 해주는 인터페이스
* **JNL(Java Native Library)** : 네이티브 메서드를 사용할 수 있는 실제 객체(라이브러리)\
  \-> native 키워드를 사용한다.

<figure><img src="../../../.gitbook/assets/image (44).png" alt=""><figcaption></figcaption></figure>
