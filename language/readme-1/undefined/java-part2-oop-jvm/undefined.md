# 클래스 - 첫 번째

## 객체(Object) 란 무엇인가?

#### 절차지향에서 객체지향으로 넘어오면서 기본적인 질문이 다음처럼 바뀐다.&#x20;

* 절차지향 : 무엇을 변수로 만들 것인가?&#x20;
* 객체지향 : 무엇을 객체로 만들 것인가?&#x20;

#### 객체란 무엇인가?&#x20;

* OOP 환경에서 소프트웨어(소스코드) 를 구성하는 **단위요소**
  * OOP 프로그램은 객체의 집합체이며 각 객체는 메서드를 통해서 관계를 맺는다.&#x20;
* **변수 및 그와 관련한 메서드가 모여진 하나의 집합체**&#x20;
  * **클래스는 반드시 존재 이유와 목적이 명확해야 함**&#x20;
  * 이 객체는 설계의 영역이기 때문에, 사람마다 객체를 나누는 의견이 분분할 수 있다. (정답이 없다)
  * 이런 객체 생성 패턴의 일반화한 것들이 디자인 패턴이라고 볼 수 있다.&#x20;
* Java 에서는 클래스로 객체를 기술한다.&#x20;

#### OOP 로 오면서 절차지향과 다르게 코드의 범위가 패키지까지 범위가 커진다.&#x20;

<figure><img src="../../../../.gitbook/assets/스크린샷 2025-03-03 12.55.28.png" alt=""><figcaption></figcaption></figure>

#### 클래스, 객체, 인스턴스&#x20;

* 클래스는 변수와 같은 자료형으로 이해&#x20;
  * 클래스는 객체를 기술하는 문법&#x20;
  * 클래스 형식에 대해 선언 할 수 있는 것은 참조(null 가능)&#x20;
* 인스턴스가 의미하는 것은 추상적인 것에 대한 실체이다.&#x20;
  * 객체(클래스) 에 대한 실체는 인스턴스이다.&#x20;
  * 인스턴스는 개발에서 다양한 의미로 사용된다.&#x20;
* 변수는 메모리(RAM) 를 사용하고자 하는 문법이다.&#x20;
  * **다시 말하면 클래스를 인스턴스화 하면 JVM 내에서 할당한 메모리를 사용하게 된다.**&#x20;

## 클래스 기본 문법과 두 가지 관점&#x20;

```java
class class-name {} 
```

* 관계에 대해 생각하지 않는다면 메서드를 구성요소로 포함하는 단순 집합체로 이해&#x20;
* 구성요소(필드나 메서드) 를 멤버라 지칭&#x20;
  * 필드는 메모리를 사용하는 보편적인 수단&#x20;
* **선언과 정의가 공존하는 구조 (일반적으로 다른 언어에서는 선언과 정의를 구분해서 사용한다)**&#x20;
  * 선언 : `public void main();`&#x20;
  * 정의 : `{// 메서드에 대한 정의}`

#### 객체(관념적) 작성자와 사용자를 구분해 생각하는 능력 필수(매우 중요!)&#x20;

* 코드를 작성하는 개발자가 모든것을 기억할 수 있다는 착각에 빠지지 말자
* 때문에 다음과 같은 기준으로 나누어 코드를 작성하도록 노력해야 한다.&#x20;
  * **작성자 기준**
  * **사용자 기준 (모든 코드는 사용자 기준으로 배려해서 코드를 작성해야 한다)**&#x20;

#### 클래스 기본 구성

<figure><img src="../../../../.gitbook/assets/스크린샷 2025-03-03 13.21.32.png" alt=""><figcaption></figcaption></figure>

## 생성자와 필드 초기화&#x20;

#### 멤버 선언 및 초기화

* 필드 선언 시 초기값 정의 가능&#x20;
  * 초기값을 기술하지 않을 시 기본 값은 0&#x20;
  * 참조 자료형은 `null`&#x20;
* 생성자를 통해 초기화 가능&#x20;
  * 클래스 내부는 생성자라는 매우 특별한 메서드가 존재한다.&#x20;
  * 클래스 내 생성자는 다음과 같은 순서로 호출되게 된다.&#x20;
    * **`new` 연산자를 통해 특정 클래스 인스턴스를 동적으로 생성**&#x20;
    * **힙영역 메모리 공간 확보 (필드 변수, 메서드 실행 코드)**&#x20;
    * **JVM 에서 생성자를 불러 클래스를 인스턴스화 한다.**&#x20;

#### 생성자&#x20;

* **생성자는 객체가 생성되는 시점에 자동으로 호출되는 메서드**&#x20;
  * 이름이 클래스 이름과 동일&#x20;
  * **생략 시 컴파일러가 빈 생성자를 자동으로 추가**&#x20;
  * **반환자료와 호출자가 없는 점에 유의**
    * 호출하는 시점이 개발자가 정의하는 것이 아니다. (추측은 할 수 있다)&#x20;
    * 때문에 값 반환이라는 개념이 없다.&#x20;
    * 인스턴스를 생성하기 위한 준비가 된 후 JVM 이 호출해준다.&#x20;
* 객체의 생성은 `new` 연산에 따른 동적 생성&#x20;
* 다중 정의 가능&#x20;
* 클래스 자체와 관련된 코드만 기술할 것!

#### 인스턴스 동적 생성&#x20;

* `new` 연산자를 이용해 인스턴스 동적 생성&#x20;
* 클래스 형식에 대한 변수 선언은 모두 참조 (포인터와 유사)
  * 인스턴스가 존재하지 않는 경우에는 `null`&#x20;
* 한 인스턴스에 대해 여러 참조자가 존재할 수 있음&#x20;
  * 사이드 이펙트 문제 고려

#### 코드 예제

<figure><img src="../../../../.gitbook/assets/스크린샷 2025-03-03 13.41.16.png" alt=""><figcaption></figcaption></figure>

<figure><img src="../../../../.gitbook/assets/스크린샷 2025-03-03 13.41.53.png" alt=""><figcaption></figcaption></figure>

* 위 예제에서 `MyFirstClass` 타입의 변수인 `myClass` 는 포인터로 생각하면 된다. 때문에, 알수없는 레퍼런스 값을 할당 받는다.&#x20;
  * 클래스 변수 : 레퍼런스 할당&#x20;
  * 일반 변수 : 값 할당&#x20;

## 접근 제어 지시자

<figure><img src="../../../../.gitbook/assets/스크린샷 2025-03-03 14.03.29.png" alt=""><figcaption></figcaption></figure>

## this&#x20;

* 클래스로 구현한 객체 자신의 인스턴스에 대한 참조자&#x20;
* **클래스에 대한 인스턴스 선언(미래) 시 값(주소)이 결정될 수 있음**
  * **인스턴스가 힙메모리에 JVM 생성하는 시점(런타임)에 값이 결정된다.**&#x20;
* 같은 클래스에 대한 인스턴스라고 하더라도 this 값은 각자 다른 값이 된다.&#x20;
* **메서드 호출시 스택(0번 슬롯) 에 값이 저장**&#x20;
* **정적 메서드에서는 사용할 수 없다.**&#x20;
  * **인스턴스가 생성되지 않았는데, 주소값을 사용한다?**&#x20;
  * **말이 안된다.**&#x20;

## 문자열 처리를 위한 MyString 클래스 (실습)

```java
class MyString {
    private byte[] string;

    public String getString(){
        if (this.string == null || this.string.length == 0) {
            return "초기화 필요";
        }
        return new String(string);
    }

    public void setString(String param) {
        this.string = param.getBytes();
    }

    public int length() {
        if (this.string == null) {
            return 0;
        }
        return this.string.length;
    }

    public int compareTo(String param){
        if(this.string == null){
            return -1;
        }

        return param.compareTo(this.getString());
    }
}

public class Main {
    public static void main(String[] args) {
        MyString str = new MyString();
        System.out.println(str.length());
        System.out.println(str.getString());

        str.setString("Hello World");
        System.out.println(str.length());
        System.out.println(str.getString());
        System.out.println(str.compareTo("Hello World"));
    }
}
```
