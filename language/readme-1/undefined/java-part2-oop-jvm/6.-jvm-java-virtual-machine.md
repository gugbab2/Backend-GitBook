# 6. JVM(Java Virtual machine) 기본 이론

## 1. Java 와 C++ 메모리 관리 차이&#x20;

### Native 언어 (C,C++ ... )&#x20;

CPU 가 이해할 수 있는 기계어로 직접 번역하고 실행한다. 때문에, 운영체제 환경에 대해서 직접적인 의존성을 가진다.&#x20;

때문에, 윈도우에서 개발된 C, C++ 코드를 리눅스, 유닉스 환경에서 실행시킬 수 없다. 각 운영체제 별로 기계어가 다르기 때문이다.&#x20;

Native 언어는 하드웨어와 직접적으로 연관되어 있다.&#x20;

### JVM 언어&#x20;

JVM 은 CPU 를 하드웨어가 아닌 소프트웨어로 구현했고, 이를 Virtual Machine 이라고 부르며, 이 Virtual Machine 에서 인식할 수 있는 코드가 Java Byte Code 일 때, JVM(Java Virtual Machine) 이라고 부른다.&#x20;

결과적으로 JVM 은 소프트웨어로 CPU + 가상메모리(RAM + SSD) 모두가 구현된 것을 의미한다. 여기에 운영체제가 제공하는 기능 일부도 제공한다.&#x20;

때문에, JVM 을 이해한다는 것은 OS, 컴퓨터구조를 모두 이해한다는 의미와 같다.. (열라 어렵겠지?)&#x20;

JVM 언어는 소프트웨어와 직접적으로 연관되어 있다.&#x20;

### Java 와 C++ 메모리 관리 차이&#x20;

JVM 은 User Mode Application 으로 Application Process 범위를 넘어서지 않는다. 쉽게 말해서 JVM 프로세스가 다운된다고 해서 OS 가 다운될 일은 없다! \
(물론 JNI 를 통해서 운영체제에 영향을 줄 수 있다. 해당 케이스는 패스\~)&#x20;

때문에, 보안적 장점이 명확하다!&#x20;

하지만 Native 언어는 운영체제와 직접적인 의존성을 가지기 때문에, 사소한 문제라도 OS 가 다운될 수 있다.&#x20;

#### C++

* 객체에 대한 모든 관리 책임은 개발자에게 있음 (메모리 할당 및 해제)&#x20;
* 객체의 생명주기에 개발자가 개입하는 구조&#x20;

#### Java

* 개체 메모리 해제는 전적으로 JVM 의 몫
* **하지만, 문제 발생시 구조를 알아야 대응 가능**

## 2. JVM 구성요소 정리

<figure><img src="../../../../.gitbook/assets/스크린샷 2025-03-22 14.59.53.png" alt=""><figcaption></figcaption></figure>

### Class loader

소프트웨어의 시점은 크게 3가지로 나뉘어 진다.&#x20;

* 컴파일
* 링크
* 실행

하지만 JVM 는 컴파일, 실행 과정으로만 나뉘어진다.

**클래스 로더는 여기서 컴파일 된 바이트코드를 로딩하고, 링킹하고 초기화하는 역할을 담당한다. (매우 중요한 역할이다)**

* 로딩 : 바이트코드를 JVM 내 Runtime data area 에 배치하는 작업.
* 링킹 : 로드된 클래스파일들을 사용 가능한 상태로 변경한다.
* 초기화 :  정적 초기화 블록이나 정적 변수들을 초기화하는 과정을 의미하고, 클래스가 사용될 때 최초로 한번만 동작한다.

클래스 로딩은 JVM 이 올라올 때 한번에 로딩되는 것이 아니라, 해당 코드가 호출 될 때마다 동적으로 로딩된다. 때문에 앞선 클래스 로딩의 절차적으로 문제가 생긴다면 다음 클래스 로딩에 문제가 생길 수 밖에 없다.&#x20;

### Runtime data area&#x20;

* Method area : 클래스 관련 정보(클래스 메서드, 클래스 정보 등), 문자열 상수를 관리하는 영역
* Heap area : GC 가 관리하는 영역&#x20;
* Stack area : 스레드마다 가지고 있는 영역&#x20;
* PC register : 스레드마다 가지고 있는 영역&#x20;
* Native method stack&#x20;

### Execution engine&#x20;

* Interpreter : 기본적으로 바이트코드를 기계어로 번역해서 실행한다.&#x20;
* JIT compiler : 반복되는 바이트코드들은 미리 기계어로 번역해놓고 실행시킨다.&#x20;
* Garbage collector : 힙 메모리를 관리해준다.&#x20;







## 3. .class 파일과 바이트 코드 소개&#x20;







## 4. 클래스 로더 및 로딩 과정&#x20;

.class 파일이(Java byte code) JVM 내에서 실제로 실행 가능한 코드이다.&#x20;

<figure><img src="../../../../.gitbook/assets/스크린샷 2025-03-22 17.26.05.png" alt=""><figcaption></figcaption></figure>

### 클래스 로더&#x20;

* 이름을 알고 있는 특정 클래스에 대한 정의(Byte stream) 를 가져오는 역할을 수행&#x20;
  * 가져온다는 것을 보았을 때, 네트워크를 통해서 .class 파일을 가져올 수도 있다. \
    (그만큼 확장성이 있다는 뜻?!)&#x20;
* 아래 3가지 클래스 로더에서 클래스를 로드하지 못했을때 `ClassNotFoundException` 이 발생한다.&#x20;

#### 부트스트랩 클래스 로더&#x20;

* JVM 이 실행될 때 가장 먼저 실행되는 클래스로더로 JVM 핵심 클래스(java.lang.\*, ... ) 들을 로드한다. 이 로더는 Java 로 작성된 것이 아니라, 네이티브 코드로 작성되어 있다.&#x20;
* 부트스트랩? &#x20;
  * 부트스트랩이라는 용어는 아무것도 없는 상태에서 스스로 부팅하는 과정을 의미한다.&#x20;
  * 즉 시스템의 기초적인 기능을 초기화하고 운영체제를 실행할 수 있도록하는 과정을 의미한다.&#x20;

#### 플랫폼 클래스 로더

* Java9 부터 도입되었으며 부트스트랩 클래스로더와 애플리케이션 클래스로더의 경계선을 명확하게 하기 위해서 존재하는 클래스로더이다.&#x20;
* JVM 핵심 클래스 외의 확장된 Java SE API 를 로드하여 부트스트랩 클래스로더와 경계선을 명확히 한다.&#x20;

#### 애플리케이션 클래스 로더&#x20;

* JVM에서 **사용자가 작성한 클래스와 애플리케이션 관련 라이브러리를 로드하는 클래스 로더** 입니다.
* 가장 최 상위에 위치한다.&#x20;

### 로딩(Loading) &#x20;

<figure><img src="../../../../.gitbook/assets/스크린샷 2025-03-22 17.28.19.png" alt=""><figcaption></figcaption></figure>

* **JVM 의 클래스 로딩 + 링킹 과정이 모두 런타임에 이루어짐**
  * 이 말은 클래스를 한꺼번에 로딩하지 않고, 필요할 때마다 동적으로 메모리에 올린다.
  * 때문에, `classNotFoundException` 이 런타임에 발생할 수 있다.&#x20;
* 실행 성능이 일부 저하될 수 있으나 **높은 확장성과 유연성을 제공하는 근간이다.**&#x20;
  * 인터페이스만 맞으면 런타임에 구현 클래스를 변경 가능하다.&#x20;
  * **클래스 로더는 실행할 프로그램 코드를 네트워크로 수신하는 것도 가능하다.**&#x20;
* 해석(Resolution) 단계는 동적 바인딩(혹은 늦은 바인딩)을 지원할 목적으로 초기화 후로 지연될 수 있다.&#x20;

> #### 준비&#x20;
>
> * 로딩 + 링킹 과정을 포함해서 준비 과정으로 볼 수 있다.&#x20;
>
> #### 실행&#x20;
>
> * 실행 단계에서 인스턴스화를 진행하며, 그 말은 초기화를 의미한다.&#x20;
> * **생성자를 통해 인스턴스화가 되므로, 생성 시점을 정할 수 있다.**&#x20;
>
> #### 마무리&#x20;
>
> * GC 를 통해 메모리를 회수한다.&#x20;
> * **Java 에는 소멸자가 존재하지 않기 때문에, GC 시점을 정할 수 없다..**&#x20;

### 링킹(Linking)&#x20;

#### **단계1. 클래스 검증(Verification)**&#x20;

* **JVM 명세가 정하는 규칙과 제약을 만족하는지 확인**&#x20;
  * 파일 형식(.class) 검증 : `.class` 파일의 형식과 구조 확인.&#x20;
  * 클래스 메타데이터 구조 검증 : 클래스 간의 상속 관계, 인터페이스 구현, 메서드 시그니처, 접근 제한자 확인.
  * 바이트코드 검증 : 바이트코드 명령어의 타입 안전성, 스택과 로컬 변수의 일관성, 제어 흐름의 유효성 확인.
  * 심볼릭 참조 검증 : A 클래스를 사용하기 위해서 먼저 로딩해야하는 클래스가 있는지 확인
* **바이트코드 검증 내에 보안위협에 대한 검증 포함**&#x20;
  * JVM 자체가 User Mode Application 영역에 한정되기 때문에, 직접적으로 OS or 하드웨어에 영향을 줄 수 없다. (성능적 향상을 위해서 JNI 를 사용하기는 한다) \
    -> 때문에, Native 언어에 비해서 보안위협을 일으킬 가능성이 매우매우 적다.&#x20;
  * **JVM 의 Verification 은 보안 위협을 방지하기 위한 중요한 단계이며, 특히 악의적인 바이트코드 실행하지 못하도록 막는 보안 장치 역할을 한다.**&#x20;
  * 검증 단계는 JVM 이 제공하는 첫 번째 방어선이다.&#x20;
  * 하지만 성능적인 연산량이 많다..&#x20;

#### 단계2. 준비(Preparation)&#x20;

* `java.lang.Class` 인스턴스가 힙 영역에 생성되고, 클래스 변수(정적 멤버) 메모리를 0으로 초기화
  * `java.lang.Class` : 사용할 클래스의 메타데이터들을 관리하는 클래스 ~~(너무 어렵잖아;;)~~&#x20;
  * 아직 사용할 클래스들은 인스턴스화 되지 않았고, `java.lang.Class` 만 인스턴스화 된 것이다.&#x20;
  * 사용할 클래스의 인스턴스는 Using 단계에서 힙 사용
  * `static final` 선언된 변수는 코드에서 정의한 초기값으로 정의 (0이 아닐 수 있음)&#x20;
* 생성자 호출 전 상태(new 연산 전)&#x20;
  * 필드(인스턴스 변수) 초기값은 생성자 호출 시 정의&#x20;
  * 정적 필드에 초기값 할당&#x20;

#### 단계3. 해석(Resolution)&#x20;

* 클래스 파일 내부에서 참조하고 있는 모든 요소들을 실제 메모리 상의 위치로 바꾸는 작업을 말한다.&#x20;
  * .class 파일은 많은 정보를 심볼릭 참조 형태로 저장하고 실제 메모리 주소가 아닌 문자열이나 인덱스 형태로 저장된 참조 정보이다. (클래스 이름, 메서드 이름, 필드 이름, 인터페이스 이름)&#x20;
  * JVM 은 프로그램 실행 중 이러한 심볼릭 참조를 런타임 시점에 실제 메모리 주소로 변환한다.&#x20;

### 유징(Using)&#x20;

#### Heap 영역에 객체 생성&#x20;

* JVM 은 객체 저장을 위한 메모리 공간을 확보 후 0으로 초기화(단, 객체 헤더 제외)&#x20;
* 객체 초기화를 위한 구성설정 실시
  * 클래스 이름 및 메타 정보 확인 방법&#x20;
  * 객체에 대한 해시 코드&#x20;
  * GC 세대 나이&#x20;
* **생성자 호출 (new 연산 실행)**&#x20;
