# HashSet vs TreeSet

## 1. 기본 개념 및 구조&#x20;

* HashSet&#x20;
  * `HashSet` 은 내부적으로 해시 테이블을 사용하여 데이터를 저장한다.&#x20;
  * 해시 테이블은 해시 함수를 사용해 요소를 해시코드로 변환하고, 이 해시코드를 기반으로 요소를 저장하거나 검색한다.&#x20;
  * 요소는 정렬되지 않은 상태로 저장되며, 요소 간의 순서는 보장되지 않는다.&#x20;
* TreeSet&#x20;
  * `TreeSet` 은 내부적으로 이진 검색 트리, 특히 레드-블랙 트리를 사용하여 데이터를 저장한다.&#x20;
  * 트리는 항상 정렬된 상태를 유지하며, 요소가 정렬된 순서로 저장되고 검색된다.&#x20;
  * 기본적으로 `Comparable` 인터페이스를 구현한 요소들이나, `Comparator` 를 사용해 정렬 기준을 정의할 수 있다.&#x20;

## 2. 순서 및 정렬&#x20;

* HashSet&#x20;
  * 요소들이 추가된 순서나 그들의 자연적인 순서는 유지되지 않는다.&#x20;
  * 요소들의 순서는 해시 함수에 따라 결정되므로, 삽입된 순서와는 무관하다.&#x20;
* TreeSet&#x20;
  * 요소들이 정렬된 순서로 저장된다.&#x20;
  * 정렬은 기본적으로 요소의 자연스러운 순서(`Comparable`) 에 따라 이루어지며, 또는 트리의 생성 시 제공된 `Comparator` 에 따라 정렬될 수 있다.&#x20;

## 3. 성능&#x20;

* HashSet&#x20;
  * 시간복잡도 : HashSet 은 일반적으로 O(1) 의 상수 시간 내에 요소를 추가, 삭제, 검색할 수 있다. 이는 해시 테이블의 특성 덕분에 가능하다.&#x20;
  * 성능 : 해시 함수가 잘 설계되었다면, HashSet 은 매우 빠르게 동작한다. 하지만 해시 충돌이 많을 경우 성능이 저하 될 수 있다.&#x20;
* TreeSet&#x20;
  * 시간복잡도 : TreeSet 은 요소 추가, 삭제, 검색에 O(log n) 의 시간 복잡도를 가진다. 이는 이진 검색 트리의 깊이에 따라 결정된다.&#x20;
  * 성능 : TreeSet 은 요소가 정렬되어 있어야 하는 경우에 유용하지만, HashSet 보다 성능이 떨어질 수 있다.&#x20;

## 4. 사용 사례&#x20;

* HashSet&#x20;
  * 데이터의 순서가 중요하지 않고, 빠른 삽입, 삭제가 필요할 때 사용한다.&#x20;
  * 예를 들어, 중복을 허용하지 않는 유일한 값의 집합을 관리할 때 유용하다.&#x20;
* TreeSet&#x20;
  * 정렬된 순서로 데이터를 유지해야 할 때 사용한다.
  * 예를 들어, 자연스러운 순서나 사용자 정의 순서로 정렬된 데이터가 필요할 때 사용된다.&#x20;
