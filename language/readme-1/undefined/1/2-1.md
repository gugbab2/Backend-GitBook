# 생산자 소비자 문제2

## Lock Condition - 예제4&#x20;

* 생산자가 생산자를 깨우고, 소비자가 소비자를 깨우는 비효율을 어떻게 해결할 수 있을까?

#### 해결방안&#x20;

* 핵심은 생산자 스레드는 데이터를 생성하고, 대기중인 소비자 스레드에게 알려주어야 한다. 반대로 소비자 스레드는 데이터를 소비하고, 대기중인 생산자 스레드에게 알려주면 된다. 결국 생산자 스레드가 대기하는 대기 집합과, 소비자 스레드가 대기하는 대기 집합을 둘로 나누면 된다.&#x20;
* **이러한 기능을 앞서 학습한 `Lock`, `ReentrantLock` 을 사용하며 된다.**&#x20;
* **아래 V4 예제는 V3 예제와 동일하게 동작한다. (락의 구현체만 바꾼 것이다)**&#x20;

> 자바는 1.0 부터 존재한 `synchronized`, `BLOCKED` 상태를 통한 임계영역 관리의 단점을 해결하기 위해서 자바 1.5 부터 `Lock` 인터페이스와 `ReentrantLock` 구현체를 제공한다.&#x20;

#### condition&#x20;

* `Condition condition = lock.newCondition();`&#x20;
* `Condition` 은 `ReentrantLock` 을 사용하는 스레드가 대기하는 스레드 대기 공간이다.&#x20;
* `lock.newCondition()` 메서드를 호출하면 스레드 대기 공간이 만들어진다. `Lock(ReentrantLock)` 의 스레드 대기 공간은 이렇게 만들어 질 수 있다.&#x20;
* 참고로 `Object.wait()` 에서 사용한 스레드 대기 공간은 모든 객체 인스턴스가 내부에 기본적으로 가지고 있다.&#x20;
* 반면에, `Lock(ReentrantLock)` 을 사용하는 경우 이렇게 스레드 대기 공간을 직접 만들어서 사용해야 한다.&#x20;

#### condition.await()&#x20;

* `Object.wait()` 와 유사한 기능이다. 지정한 `condition` 에 현재 스레드를 대기 (`WAITING`) 상태로 보관한다.&#x20;
* 이때 `ReentrantLock` 에서 획득한 락을 반납하고 대기 상태로 `condition` 에 보관한다.&#x20;

#### condition.signal()

* `Object.notify()` 와 유사한 기능이다. 지정한 `condition` 에서 대기중인 스레드를 하나 깨운다. 깨어난 스레드는 `condition` 에서 빠져나온다.&#x20;

```java
package thread.bounded;

import java.util.ArrayDeque;
import java.util.Queue;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

import static util.MyLogger.log;

public class BoundedQueueV4 implements BoundedQueue {

    private final Lock lock = new ReentrantLock();
    private final Condition condition = lock.newCondition();

    private final Queue<String> queue = new ArrayDeque<>();
    private final int max;

    public BoundedQueueV4(int max) {
        this.max = max;
    }

    @Override
    public void put(String data) {
        lock.lock();
        try{
            while(queue.size() == max) {
                log("[put] 큐가 가득 참, 생산자 대기");
                try {
                    condition.await();
                    log("[put] 생산자 깨어남");
                } catch (InterruptedException e) {
                    throw new RuntimeException(e);
                }
            }
            queue.offer(data);
            log("[put] 생산자 데이터 저장, signal() 호출");
            condition.signal();
        } finally {
            lock.unlock();
        }
    }

    @Override
    public String take() {
        lock.lock();
        try{
            while(queue.isEmpty()) {
                try {
                    condition.await();
                    log("[take] 소비자 깨어남");
                } catch (InterruptedException e) {
                    throw new RuntimeException(e);
                }
            }
            String data = queue.poll();
            log("[take] 소비자 데이터 획득, signal() 호출");
            condition.signal();
            return data;
        }finally {
            lock.unlock();
        }
    }

    @Override
    public String toString() {
        return queue.toString();
    }
}
```

## 생산자 소비자 대기 공간 분리 - 예제5 코드&#x20;

<figure><img src="../../../../.gitbook/assets/스크린샷 2024-11-10 17.14.58.png" alt=""><figcaption></figcaption></figure>

#### Condition 분리&#x20;

* consumerCond : 생산자를 위한 스레드 대기 곤간&#x20;
* producerCond : 소비자를 위한 스레드 대기 공간&#x20;

#### put(data) - 생산자 스레드가 호출&#x20;

* 큐에 가득 찬 경우 : producerCond.await() 를 호출해서 생산자스레드를 생산자 전용 스레드 대기 공간에 보관한다.&#x20;
* 데이터를 저장한 경우 : 생산자가 데이터를 생산하면 큐에 데이터가 추가된다. 따라서 소비자를 깨우는 것이 좋다. consumerCond.signal() 을 호출해서 소비자전용 스레드 전용 대기 공간에 신호를 보낸다. 이렇게 하면 대기중인 소비자 스레드 하나를 깨워 데이터를 소비할 수 있다.&#x20;

#### take() - 소비자 스레드가 호출&#x20;

* 큐가 빈 경우 : `consumerCond.await()` 를 호출해서 소비자 스레드를 소비자 전용 스레드가 대기 공간에 보관한다.&#x20;
* 데이터를 소비한 경우 : 소비자가 데이터를 소비한 경우 큐에 여유 공간이 생긴다. 따라서 생산자를 깨우는 것이 좋다. `producerCond.signal()` 를 호출해서 생산자 전용 스레드 대기 공간에 신호를 보낸다. 이렇게 하면 대기 중인 생산자 스레드가 하나 깨어나서 데이터를 추가할 수 있다.&#x20;

#### 핵심은 생산자는 소비자를 깨우고, 소비자는 생산자를 깨운다는 것이다.&#x20;

```java
package thread.bounded;

import java.util.ArrayDeque;
import java.util.Queue;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

import static util.MyLogger.log;

public class BoundedQueueV5 implements BoundedQueue {

    private final Lock lock = new ReentrantLock();
    private final Condition producerCond = lock.newCondition();
    private final Condition consumerCond = lock.newCondition();

    private final Queue<String> queue = new ArrayDeque<>();
    private final int max;

    public BoundedQueueV5(int max) {
        this.max = max;
    }

    @Override
    public void put(String data) {
        lock.lock();
        try{
            while(queue.size() == max) {
                log("[put] 큐가 가득 참, 생산자 대기");
                try {
                    producerCond.await();
                    log("[put] 생산자 깨어남");
                } catch (InterruptedException e) {
                    throw new RuntimeException(e);
                }
            }
            queue.offer(data);
            log("[put] 생산자 데이터 저장, signal() 호출");
            consumerCond.signal();
        } finally {
            lock.unlock();
        }
    }

    @Override
    public String take() {
        lock.lock();
        try{
            while(queue.isEmpty()) {
                try {
                    consumerCond.await();
                    log("[take] 소비자 깨어남");
                } catch (InterruptedException e) {
                    throw new RuntimeException(e);
                }
            }
            String data = queue.poll();
            log("[take] 소비자 데이터 획득, signal() 호출");
            producerCond.signal();
            return data;
        }finally {
            lock.unlock();
        }
    }

    @Override
    public String toString() {
        return queue.toString();
    }
}
```

### 생산자 소비자 대기 공간 분리 - 예제5 분석&#x20;

#### 생산자 실행&#x20;

<figure><img src="../../../../.gitbook/assets/스크린샷 2024-11-10 17.23.17.png" alt="" width="563"><figcaption></figcaption></figure>

<figure><img src="../../../../.gitbook/assets/스크린샷 2024-11-10 17.23.32.png" alt="" width="563"><figcaption></figcaption></figure>

<figure><img src="../../../../.gitbook/assets/스크린샷 2024-11-10 17.23.40.png" alt="" width="563"><figcaption></figcaption></figure>

#### 소비자 실행&#x20;

<figure><img src="../../../../.gitbook/assets/스크린샷 2024-11-10 17.24.50.png" alt="" width="563"><figcaption></figcaption></figure>

<figure><img src="../../../../.gitbook/assets/스크린샷 2024-11-10 17.24.57.png" alt="" width="563"><figcaption></figcaption></figure>

<figure><img src="../../../../.gitbook/assets/스크린샷 2024-11-10 17.25.06.png" alt="" width="563"><figcaption></figcaption></figure>

#### Object.notify() vs Condition.signal()&#x20;

* Obejct.notify()
  * 대기 중인 스레드 중 임의의 하나를 선택해서 깨운다. 스레드가 깨어나는 순서는 정리되어 있지 않으며, JVM 수현에 따라 다르다. 보통은 먼저 들어온 스레드가 먼저 수행되지만, 구현에 따라 다를 수 있다.
  * `synchronized` 블록 내에서 모니터 락을 가지고 있는 스레드가 호출해야 한다.&#x20;
* Condition.signal()&#x20;
  * 대기 중인 스레드 중 하나를 깨우며, 일반적으로는 FIFO 순서로 깨운다. 이 부분은 자바 버전과 구현에 따라 달라질 수 있지만, 보통 `Condition` 의 구현은 `Queue` 구조를 사용하기 때문에, FIFO 순서로 깨운다.&#x20;
  * `ReentrantLock` 을 가지고 있는 스레드가 호출해야 한다.&#x20;

## 스레드 대기&#x20;

* 다음 내용으로 진행하기 전에, `synchronized`, `ReentrantLock` 의 대기 상태에 대해서 정리해 보자&#x20;
* 먼저 `synchronized` 대기 상태에 대해서 정리해보자. 잘 생각해보면 `synchronized` 의 대기 상태는 2가지로 분리되어 있다.&#x20;

#### synchronized 대기

* 대기1 : 락 획득 대기
  * `BLOCKED` 상태로 락 획득 대기&#x20;
  * `synchronized` 를 시작할 때 락이 없으면 대기&#x20;
  * 다른 스레드가 `synchronized` 를 빠져나갈 때 대기가 풀리며 락 획득 시도&#x20;
* 대기2 : `wait()` 대기&#x20;
  * `WAITING` 상태로 대기&#x20;
  * `wait()` 를 호출 했을 때 스레드 대기 집합에서 대기&#x20;
  * 다른 스레드가 `notify()` 를 호출 했을 때 빠져나감&#x20;









