# 스레드 제어와 생명 주기1

## 1. 스레드 기본 정보

```java
import thread.start.HelloRunnable;
import static util.MyLogger.log;

public class ThreadInfoMain {
         public static void main(String[] args) { // main 스레드
                  Thread mainThread = Thread.currentThread();
                  log("mainThread = " + mainThread);
                  log("mainThread.threadId() = " + mainThread.threadId());
                  log("mainThread.getName() = " + mainThread.getName());
                  log("mainThread.getPriority() = " + mainThread.getPriority()); // 1~10(기본값 5)
                  log("mainThread.getThreadGroup() = " + mainThread.getThreadGroup()); 
                  log("mainThread.getState() = " + mainThread.getState());
                  
                  // myThread 스레드
                  Thread myThread = new Thread(new HelloRunnable(), "myThread"); 
                  log("myThread = " + myThread);
                  log("myThread.threadId() = " + myThread.threadId()); 
                  log("myThread.getName() = " + myThread.getName()); 
                  log("myThread.getPriority() = " + myThread.getPriority()); 
                  log("myThread.getThreadGroup() = " + myThread.getThreadGroup()); 
                  log("myThread.getState() = " + myThread.getState());
         } 
}
```

#### 1. 스레드 생성&#x20;

* 스레드 생성 시 실행할 Runnable 인터페이스와 스레드의 이름을 전달할 수 있다.&#x20;
  * Runnable 인터페이스 : 실행할 작업을 포함하는 인터페이스이다. &#x20;
  * 스레드 이름 : 이 이름은 디버깅이나 로깅 목적으로 유용하다. 지정하지 않을 경우 Thread-0, Thread-1 과 같은임의의 이름이 생성된다.&#x20;

```java
Thread myThread = new Thread(new HelloRunnable(), "myThread");
```

#### 2. 스레드 객체 정보&#x20;

* 만든 스레드 객체를 문자열로 변환하여 출력한다. (자동적으로 Thread.toString() 사용)\
  ex, `Thread[#21,myThread,5,main]`

```java
log("myThread = " + myThread);
```

#### 3. 스레드 ID&#x20;

* threadId() : 스레드 고유의 식별자를 반환하는 메서드이다. 이 ID 는 JVM 내에서 각 스레드에 대해 유일하다. ID 는 스레드가 생성될 때 할당되며, 직접 지정할 수 없다.&#x20;

```java
log("myThread.threadId() = " + myThread.threadId());
```

#### 4. 스레드 이름&#x20;

* getName() : 스레드의 이름을 반환하는 메서드이다. 생성자에서 "myThread" 라는 이름을 지정했기 때문에, 이 값이 반환된다. 참고로 스레드 ID 는 중복되지 않지만 스레드 이름은 중복될 수 있다.&#x20;

```java
log("myThread.getName() = " + myThread.getName());
```

#### 5. 스레드 우선순위&#x20;

* getPriority() : 스레드의 우선순위를 반환하는 메서드이다. **우선순위는 1(가장 낮음) 부터 10(가장 높음) 까지의 값으로 설정할 수 있으며, 기본값은 5이다.** setPriority() 를 통해서 우선순위를 변경할 수 있다.&#x20;
* 우선순위는 스레드 스케줄러가 어떤 스레드를 우선 실행할지 결정하는 데 사용된다. 하지만 실제 실행 순서는 JVM 구현과 운영체제에 따라서 달라질 수 있다.&#x20;

```java
log("myThread.getPriority() = " + myThread.getPriority()); 
```

#### 6. 스레드 그룹&#x20;

* getThreadGroup() : 스레드가 속한 스레드 그룹을 반환하는 메서드이다. 스레드 그룹은 스레드를 그룹화하여 관리할 수 있는 기능을 제공한다. 기본적으로 모든 스레드는 부모 스레드와 동일한 스레드 그룹에 속하게 된다.&#x20;
* 스레드 그룹은 여러 스레드를 하나의 그룹으로 묶어서 특정 작업(일괄 종료, 우선순위 설정 등.. ) 을 수행할 수 있다.&#x20;
* 부모 스레드(Parent Thread) : 새로운 스레드를 생성하는 스레드를 의미한다. 스레드는 기본적으로 다른 스레드에 의해서 생성된다. **이러한 생성 관계에서 새로 생성된 스레드는 생성한 스레드를 부모로 간주한다.**&#x20;
* 스레드 그룹 기능은 직접적으로 잘 사용하지는 않기에, 있구나 정도로 알아두자 ..&#x20;

```java
log("myThread.getThreadGroup() = " + myThread.getThreadGroup());
```

#### 7. 스레드 상태&#x20;

* getState() : 스레드의 현재 상태를 반환하는 메서드이다. 반환되는 값은 Thread.State 열거형에 정의된 상수 중 하나이다. 주요 상태는 다음과 같다.&#x20;
  * NEW : 스레드가 아직 시작되지 않은 상태이다 .
  * RUNNABLE : 스레드가 실행 중이거나, 실행될 준비가 된 상태이다.&#x20;
  * BLOCKED : 스레드가 동기화 락을 기다리는 상태이다.&#x20;
  * WAITING : 스레드가 다른 스레드의 특정 작업이 완료되기를 기다리는 상태이다.&#x20;
  * TIMED\_WAITING : 일정 시간 동안 기다리는 상태이다.&#x20;
  * TERMINATED : 스레드가 실행을 마친 상태이다.&#x20;

```java
log("myThread.getState() = " + myThread.getState());
```

## 2. 스레드의 생명 주기&#x20;

<figure><img src="../../../../.gitbook/assets/스크린샷 2024-10-09 14.26.49.png" alt="" width="563"><figcaption></figcaption></figure>

### 스레드의 상태&#x20;

* New : 스레드가 아직 시작되지 않은 상태이다 .
* Runnable : 스레드가 실행 중이거나, 실행될 준비가 된 상태이다.&#x20;
* 일시 중지 상태들 (자바 스레드에서 해당 단어는 없다.. 알아듣기 쉽게 사용한 단어이다)
  * Blocked : 스레드가 동기화 락을 기다리는 상태이다.&#x20;
  * Waiting : 스레드가 다른 스레드의 특정 작업이 완료되기를 기다리는 상태이다.&#x20;
  * Timed Waiting : 일정 시간 동안 기다리는 상태이다.&#x20;
* Terminated : 스레드가 실행을 마친 상태이다.&#x20;

#### New (새로운 상태)

* 스레드가 생성되고 아직 시작되지 않은 상태이다.&#x20;
* 이 상태에서는 Thread 객체가 생성되지만, start() 메서드가 호출되지 않은 상태이다.&#x20;
* ex, `Thread thread = new Thread(runnable());`

#### Runnable (실행 가능 상태)&#x20;

* 스레드가 실행될 준비가 된 상태이다. 이 상태에서 스레드는 실제로 CPU 에서 실행될 수 있다.&#x20;
* start() 메서드가 호출되면 스레드는 이 상태로 들어간다.&#x20;
* ex, `thread.start();`
* **이 상태는 스레드가 실행될 준비가 되어 있음을 나타내며, 실제로 CPU 에서 실행될 수 있는 상태이다. 그러나 Runnable 상태에 있는 모든 스레드가 동시에 실행되는 것은 아니다. 운영체제의 스케줄러가 각 스레드에 CPU 시간을 할당하여 실행하기 때문에, Runnable 상태에 있는 스레드는 스케줄러의 실행 대기열에 포함되어 있다가 차례로 CPU 에서 실행된다.**&#x20;
* **참고로 운영체제 스케줄러의 실행 대기열에 있든, CPU 에서 실제 실행되고 있든 모두 RUNNABLE 상태이기 때문에, 자바에서 둘을 구분해서 사용할 수는 없다.**\
  **-> 실제로 운영체제에서 위 두가지 상태가 너무 빠르게 변경되기에 자바에서 확인하는 것이 의미도 없을 것이다.**&#x20;
* 보통 실행 상태라고 부른다. &#x20;

#### Blocked (차단 상태)&#x20;

* 스레드가 다른 스레드에 의해 동기화 락을 얻기 위해 기다리는 상태이다.&#x20;
* 예를 들어, `synchronized` 블록에 진입하기 위해서 락을 얻어야 하는 경우 이 상태에 들어간다.&#x20;

#### Waiting (대기 상태)&#x20;

* 스레드가 다른 스레드의 특정 작업이 완료되기를 무기한 기다리는 상태이다.&#x20;
* `wait()`, `join()` 메서드가 호출될 때 이 상태가 된다.&#x20;
* 스레드는 다른 스레드가 `notify()`, `notifyAll()` 메서드를 호출하거나, `join()` 이 완료될 때까지 기다린다.&#x20;

#### Timed Waiting (시간 제한 대기 상태)&#x20;

* 스레드가 특정 시간 동안 다른 스레드의 작업이 완료되기를 기다리는 상태이다.&#x20;
* `sleep(long millis)` , `wait(long timeout)`,  `join(long millis)` 메서드가 호출될 때 이 상태가 된다.
* 주어진 시간이 경과하거나 다른 스레드가 해당 스레드를 깨우면 이 상태를 벗어난다.&#x20;

#### Terminated (종료 상태)&#x20;

* 스레드의 실행이 완료된 상태이다.&#x20;
* 스레드가 정상적으로 종료되거나, 예외가 발생하여 종료된 경우 이 상태로 들어간다.&#x20;
* 스레드는 한 번 종료되면 다시 시작할 수 없다.&#x20;

```java
import static util.MyLogger.log;

public class ThreadStateMain {
    public static void main(String[] args) throws InterruptedException {
        Thread thread = new Thread(new MyRunnable(), "myThread");
        log("myThread.state1 = " + thread.getState());
        log("myThread.start()");
        thread.start();
        Thread.sleep(1000);
        log("myThread.state3 = " + thread.getState());
        Thread.sleep(4000);
        log("myThread.state5 = " + thread.getState());
    }

    static class MyRunnable implements Runnable {

        @Override
        public void run() {

            try {
                log("start");
                log("myThread.state2 = " + Thread.currentThread().getState());
                log("sleep start");
                Thread.sleep(3000);
                log("sleep end");
                log("myThread.state4 = " + Thread.currentThread().getState());
                log("end");
            } catch (InterruptedException e) {
                throw new RuntimeException(e);
            }
        }
    }
}
```

<figure><img src="../../../../.gitbook/assets/스크린샷 2024-10-09 15.12.07.png" alt="" width="563"><figcaption></figcaption></figure>

## 3. 체크 예외 재정의&#x20;

* `Runnable`  인터페이스의 `run()` 메서드를 구현할 때 `InterruptedException`  체크 예외를 밖으로 던질 수 없는 이유를 알아보자.
* `Runnable`  인터페이스는 다음과 같이 정의되어 있다.&#x20;

```java
public interface Runnable {
    void run(); 
}
```

* 자바에서 메서드를 재정의 할 때, 재정의 메서드가 지켜야 할 예외와 관련된 규칙이 있다.&#x20;
  * **체크 예외**&#x20;
    * **부모 메서드가 체크 예외를 던지지 않는 경우, 재정의 된 자식 메서드도 체크 예외를 던질 수 없다.**
    * **자식 메서드는 부모 메서드가 던질 수 있는 체크 외의 하위 타입만 던질 수 있다.**
  * **언체크(런타임) 예외**&#x20;
    * **예외 처리를 강제하지 않으므로 상관 없이 던질 수 있다.**
* `Runnable`  인터페이스의 `run()` 메서드는 아무런 체크 예외를 던지지 않는다. 따라서 `Runnable`  인터페이스의 `run()` 메서드를 재정의 하는 곳에서는 체크 예외를 밖으로 던질 수 없다. 다음 코드를 실행하면 컴파일 오류가 발생한다.

```java
public class CheckedExceptionMain {
    public static void main(String[] args) throws Exception {
        throw new Exception();
    }
    static class CheckedRunnable implements Runnable {
        @Override
        public void run() /*throws Exception*/ { // 주석 풀면 예외 발생
        //throw new Exception(); // 주석 풀면 예외 발생 
        }
    } 
}
```

### 자바는 왜 이런 제약을 두는 것일까?&#x20;

* 부모 클래스의 메서드를 호출하는 클라이언트 코드는 부모 메서드가 던지는 특정 예외만을 처리하도록 작성된다.&#x20;
* 자식 클래스가 더 넓은 범위의 예외를 던지면 해당 코드는 모든 예외를 처리하지 못할 수 있다.&#x20;
* 이는 예외 처리의 일관성을 해치고, 예상치 못한 런타임 오류를 발생시킬 수 있다.&#x20;

<pre class="language-java"><code class="lang-java"><strong>// 아래는 동작하지 않는 코드이다. 
</strong><strong>class Parent {
</strong>     void method() throws InterruptedException {
          // ...
     } 
}
class Child extends Parent {
     @Override
     void method() throws Exception {
          // ...
     } 
}

public class Test {
     public static void main(String[] args) {
          Parent p = new Child();
          try {
             p.method();
          } catch (InterruptedException e) {
               // InterruptedException 처리 
          }
     } 
}
</code></pre>

#### 체크 예외 재정의 규칙&#x20;

* 자식 클래스에 재정의 된 메서드는 부모 메서드가 던질 수 있는 체크 예외의 하위 타입만 던질 수 있다.&#x20;
* 원래 메서드가 체크 예외를 던지지 않는 경우, 재정의 된 메서드도 체크 예외를 던질 수 없다.&#x20;

#### 안전한 예외 처리&#x20;

* **체크 예외를 run() 메서드에서 던질 수 없도록 강제하므로써, 개발자는 반드시 예외를 try-catch 블록 내에서 처리하게 된다.**
* **이는 예외 발생 시 예외가 적절히 처리되지 않아서, 프로그램이 비정상 종료되는 상황을 방지 할 수 있다.**&#x20;
* 특히 멀티스레팅 환경에서는 예외 처리를 강제 함으로써 스레드의 안정성과 일관성을 유지할 수 있다.&#x20;
* **하지만 체크 예외를 강제하는 이런 부분들은 자바 초창기 기조이고, 최근에는 체크 예외보다는 언체크(런타임) 예외를 선호한다.**&#x20;

### 재정의 된 Sleep 유틸리티&#x20;

```java
import static util.MyLogger.log;

public abstract class ThreadUtils {

    public static void sleep(long millis) {
        try {
            Thread.sleep(millis);
        } catch (InterruptedException e) {
            log("인터럽트 발생, " + e.getMessage());
            throw new RuntimeException(e);
        }
    }
}
```

## 4. Join 시작&#x20;

* 앞서 Thread.sleep() 메서드를 통해 THREAD\_WAITING 상태를 알아보았다.&#x20;
* 이번에는 join() 메서드를 통해 WAITIN(대기 상태) 가 무엇이고, 왜 필요한지 알아보자.&#x20;

#### Waiting (대기 상태)&#x20;

* 스레드가 다른 스레드의 특정 작업이 완료되기를 무기한 기다리는 상태이다.&#x20;

### join() 이 필요한 상황&#x20;

* 1 \~ 100 까지 더하는 간단한 코드를 생각해보자.
* CPU 코어를 하나만 사용하는 것보다 여러 스레드를 사용해 멀티태스킹 하는 방법이 더 효율적일 것이다.&#x20;
* 때문에, 1 \~ 100 더하는 연산은 다음과 같이 나눌 수 있다.&#x20;
  * 1 \~ 50 까지 더하기 = 1275
  * 51 \~ 100 까지 더하기 = 3775&#x20;
* CPU 코어가 2개라면 이론적으로 연산 속도가 2배 빨라진다.&#x20;
* 아래 코드를 실행해 결과를 살펴보자
  * task1, task2 연산이 마무리 되기 전에 메인 스레드에서 값을 계산하기 때문에, 결과 값으로 0을 출력 하는 것을 확인할 수 있다.&#x20;

> #### `this` 의 비밀&#x20;
>
> * **어떤 메서드를 호출하는 것은, 정확히는 특정 스레드가 어떤 메서드를 호출하는 것이다.**&#x20;
> * 스레드는 메서드의 호출을 관리하게 위해서 메서드 단위로 스택 프레임을 만들고, 해당 스택 프레임을 스택 위에 쌓아 올린다.
> * **이때 인스턴스의 메서드를 호출하면, 어떤 인스턴스의 메서드를 호출했는지 기억하기 위해, 해당 인스터스의 참조 값을 스택 프레임 내부에 저장해둔다.**&#x20;
> * **이것이 바로 우리가 자주 사용하던 `this` 이다.**&#x20;
> * 특정 메서드 안에서 `this` 를 호출하면 바로 스택프레임 안에 있는 this 값을 불러 사용하게 된다.&#x20;
> * 이렇게 `this` 가 있기 때문에, `thread-1`, `thread-2` 는 자신의 인스턴스를 구분해서 사용할 수 있다.&#x20;
> * **정리하자면, `this` 는 호출된 인스턴스 메서드가 소속된 객체를 가리키는 참조이며, 이것이 스택 프레임 내부에 저장되어 있다.**&#x20;



```java
import static util.MyLogger.log;
import static util.ThreadUtils.sleep;

public class JoinMainV1 {
    public static void main(String[] args) {
        log("start");

        SumTask task1 = new SumTask(1, 50);
        SumTask task2 = new SumTask(51, 100);
        Thread thread1 = new Thread(task1, "thread-1");
        Thread thread2 = new Thread(task2, "thread-2");

        thread1.start();
        thread2.start();

        log("task1.result = " + task1.result);
        log("task2.result = " + task2.result);

        int sumAll = task1.result + task2.result;
        log("task1 + task2 = " + sumAll);

        log("end");
    }

    static class SumTask implements Runnable {

        int startValue;
        int endValue;
        int result = 0;

        public SumTask(int startValue, int endValue) {
            this.startValue = startValue;
            this.endValue = endValue;
        }

        @Override
        public void run() {
            log("작업 시작");
            sleep(2000);
            int sum = 0;
            for(int i=startValue;i<endValue;i++) {
                sum += i;
            }

            result = sum;
            log("작업 완료 result = " + result);
        }
    }
}
```

<figure><img src="../../../../.gitbook/assets/스크린샷 2024-10-09 19.47.07.png" alt=""><figcaption></figcaption></figure>

<figure><img src="../../../../.gitbook/assets/스크린샷 2024-10-09 19.48.35.png" alt=""><figcaption></figcaption></figure>

### join() - sleep() 사용&#x20;

* 특정 스레드를 기다리게 하는 가장 간단한 방법은 sleep() 을 사용하는 것이다.&#x20;
  * **하지만 이렇게 sleep() 을 사용해서 무작정? 기다리는 방법은 대기 시간에 손해도 보고, 또 thread-1. thread-2 수행시간이 달라지는 경우에는 정확한 타이밍을 맞추기 어렵다.**&#x20;

```java
import static util.MyLogger.log;
import static util.ThreadUtils.sleep;

public class JoinMainV2 {
    public static void main(String[] args) {
        log("start");

        SumTask task1 = new SumTask(1, 50);
        SumTask task2 = new SumTask(51, 100);
        Thread thread1 = new Thread(task1, "thread-1");
        Thread thread2 = new Thread(task2, "thread-2");

        thread1.start();
        thread2.start();

        // 정확한 타이밍을 맞추기가 어렵다.
        log("main 스레드 sleep()");
        sleep(3000);
        log("main 스레드 깨어남");

        log("task1.result = " + task1.result);
        log("task2.result = " + task2.result);

        int sumAll = task1.result + task2.result;
        log("task1 + task2 = " + sumAll);

        log("end");
    }

    static class SumTask implements Runnable {

        int startValue;
        int endValue;
        int result = 0;

        public SumTask(int startValue, int endValue) {
            this.startValue = startValue;
            this.endValue = endValue;
        }

        @Override
        public void run() {
            log("작업 시작");
            sleep(2000);
            int sum = 0;
            for(int i=startValue; i<=endValue; i++) {
                sum += i;
            }

            result = sum;
            log("작업 완료 result = " + result);
        }
    }
}

```

<figure><img src="../../../../.gitbook/assets/스크린샷 2024-10-09 19.56.30.png" alt=""><figcaption></figcaption></figure>

<figure><img src="../../../../.gitbook/assets/스크린샷 2024-10-09 19.56.45.png" alt=""><figcaption></figcaption></figure>

* 더 나은 방법은 thread-1, thread-2 가 계산을 끝내고 종료될 때 까지 main 스레드가 기다리는 방법이다.&#x20;
* 예를 들어서 main 스레드가 반복문을 사용해서 thread-1, thread-2 의 상태가 TERMINATED 가 될 때까지 계속 확인하는 방법이 있다.&#x20;
  * 하지만 이런 방법은 번거롭고 또 계속되는 반복문은 CPU 연산을 사용한다. 이 때 join() 메서드를 사용하면 문제가 깔끔하게 해결된다.&#x20;

```java
while(thread1.getState() != TERMINATED
     && thread2.getState() != TERMINATED) {
    // ... 
}
```

### join() - join() 사용

* main 스레드는 다음 코드를 실행하게 되면, thread-1, thread-2 가 종료될 때 까지 기다린다.&#x20;
* 이때 main 스레드는 WAITING 상태가 된다.&#x20;
* 만약 일정 시간만큼만 대기하고 싶다면 join(ms) 메서드를 호출하자&#x20;

> #### Waiting (대기 상태)&#x20;
>
> * 스레드가 다른 스레드의 특정 작업이 완료되기를 무한히 기다리는 상태이다.&#x20;
> * join() 을 호출하는 스레드는 대상 스레드가 TERMINATED 상태가 될 때 까지 대기한다.&#x20;
> * 대상 스레드가 TERMINATED 가 되면 호출 스레드는 다시 RUNNABLE 상태가 되고 다음 코드를 진행한다.&#x20;



```java
import static util.MyLogger.log;
import static util.ThreadUtils.sleep;

public class JoinMainV3 {
    public static void main(String[] args) throws InterruptedException {
        log("start");

        SumTask task1 = new SumTask(1, 50);
        SumTask task2 = new SumTask(51, 100);
        Thread thread1 = new Thread(task1, "thread-1");
        Thread thread2 = new Thread(task2, "thread-2");

        thread1.start();
        thread2.start();

        // 스레드가 종료될 때까지 대기
        log("join() - main 스레드가 thread1, thread2 종료까지 대기");
        thread1.join();
        thread2.join();
        log("main 스레드 대기 완료");

        log("task1.result = " + task1.result);
        log("task2.result = " + task2.result);

        int sumAll = task1.result + task2.result;
        log("task1 + task2 = " + sumAll);

        log("end");
    }

    static class SumTask implements Runnable {

        int startValue;
        int endValue;
        int result = 0;

        public SumTask(int startValue, int endValue) {
            this.startValue = startValue;
            this.endValue = endValue;
        }

        @Override
        public void run() {
            log("작업 시작");
            sleep(2000);
            int sum = 0;
            for(int i=startValue; i<=endValue; i++) {
                sum += i;
            }

            result = sum;
            log("작업 완료 result = " + result);
        }
    }
}

```

<figure><img src="../../../../.gitbook/assets/스크린샷 2024-10-09 20.03.39.png" alt=""><figcaption></figcaption></figure>

<figure><img src="../../../../.gitbook/assets/스크린샷 2024-10-09 20.03.54.png" alt=""><figcaption></figcaption></figure>
