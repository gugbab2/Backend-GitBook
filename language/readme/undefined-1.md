# 인라인 함수

## 함수를 호출할 때 일어나는 일

#### 함수를 호출하기 위해 필요한 단계들&#x20;

\-> 함수는 스택 메모리 안에 할당 되어 있다.

1. 변수들을 스택에 PUSH
2. 함수 주소로 점프(스택 포인터를 옮긴다)
3. 함수를 실행한다.
4. 함수를 실행 후 함수를 호출했던 함수로 다시 점프한다.
5. 1단계에서 넣어두었던 변수들을 POP 해서 사용한다.

#### 함수 호출에 여러 단계가 있으므로 생기는 단점&#x20;

* 단계가 많아서 조금 더 느림 ..&#x20;
* CPU 캐시에 최적이 아닐 수도 있다. \
  \-> **한번 호출한 내용에 대해서 보통은 캐시 메모리에 저장되게 되는데, 힙 메모리와 같이 전혀 다른 곳을 호출하게 되면 캐시 최적화에 문제가 될 수 있다.**
* 모던 CPU 아키텍처에서는 더 느림 ..&#x20;

## 인라인 함수 (함수 호출의 오버헤드를 개선하는 방법)

* 코드를 살펴보자
  * 다음과 같이 inline 키워드를 헤더부분에 선언해주고 함수를 사용하게 되면,
  * 개발자가 보기에는 함수를 호출하는 것으로 보여지지만, 컴파일러가 리턴값으로 바꾸어준다.
  * \#define 과 같이 매크로의 개념과 매우 비슷하다.\
    `#define SQUARE(x) (x)*(x)`

<pre class="language-cpp"><code class="lang-cpp"><strong>// 클래스 멤버함수가 아닌 경우
</strong><strong>inline int Square(int number)
</strong><strong>{
</strong><strong>    return number * number;
</strong><strong>}
</strong>
<strong>// 클래스 멤버함수의 경우
</strong><strong>// Animal.h
</strong><strong>// .h 파일 안에 inline 함수의 구현체가 있어야만 한다.
</strong>class Animal
{
public:
    Animal(int age);
    inline int GetAge() const;
};

int Animal::GetAge() const
{
    return mAge;
}

// Main.cpp
// 컴파일 전!
Cat* myCat = new Cat(2, "COCO");
int age = myCat->GetAge();

// 컴파일 후!
Cat* myCat = new Cat(2, "COCO");
int age = myCat.mAge;    // mAge 는 private 변수이기 때문에, 이러한 체크는 컴파일러가 해준다.
</code></pre>

#### 매크로와 비슷한데 그렇다면 대신 매크로를 사용해도 되나? -> _쓰지마_ ;;

* 하지만, 매크로는 디버깅이 너무 힘들다 ..
* 매크로는 범위를 준수하지 않는다.
  * 엑세스 체크, 범위를 준수하지 않는다.
* **정말 매크로를 쓸 이유가 있지 않는 한 인라인 함수를 쓰자!**

## **인라인 함수를 쓸 때 주의점**

#### inline 키워드는 힌트일 뿐이다.

* 실제로 인라인이 안될수도 있다!?
* 컴파일러가 자기 맘대로 인라인을 할수도 안할수도 있다.

#### 인라인 함수 구현이 헤더 파일에 위치해야 한다!

* 컴파일러가 .cpp 파일을 따로 컴파일 한다.&#x20;
* 따라서 b.h 를 include 하는 a.cpp 파일을 컴파일 할 때, 컴파일러는 b.cpp 에 뭐가 들어있는 줄 모른다!
* 때문에, 복붙을 하려면 컴파일러가 그 구현체를 볼 수 있어야 하기 때문에, 인라인 함수 구현이 헤더 파일에 위치해야 한다.

#### 간단한 함수에 적합하다.

* 특히 getter, setter

#### 실행 파일의 크기가 증가하기가 쉽다.

* 동일한 코드를 여러번 복붙하기 때문에, 실행파일의 크기가 증가하고
* 남용하지 말자!
* 실행파일이 작을수록 CPU 캐시하고 잘 작동한다.\
  \-> 속도가 더 빨라질 수 있다.
