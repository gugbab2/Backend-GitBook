---
description: 수
---

# 인라인 함수

#### 함수를 호출할 때 일어나는 일!

**-> **_**모든 코드를 함수로 만드는 것이 좋은것은 아니다!!**_

* 함수는 스택 메모리 안에 할당 되어 있다.
* 함수를 호출하기 위해 필요한 단계들
  * 변수들을 스택에 PUSH
  * 함수 주소로 점프(스택 포인터를 옮긴다)
  * 함수를 실행한다.
  * 함수를 실행 후 함수를 호출했던 함수로 다시 점프한다.
  * 1단계에서 넣어두었던 변수들을 POP 해서 사용한다.
* 함수의 호출에는 여러 단계가 있다.
  * 그래서 좀더 느리다...
  * CPU 캐시에 최적이 아닐 수도 있다!\
    \-> 최근에 읽은 메모리들은 캐시 메모리에 저장되어 있다.\
    \-> A, B 함수의 위치가 멀어질 시, 코드를 실행시킬 때 캐시에 읽어와서 다시 실행을 해야하기 때문에, 이 과정이 반복될 시 성능이 느려질 수 있다.
  * 때문에, 모든 것을 함수로 만들라는 것은 잘못된 조언이다...\
    \-> 하지만, 아직도 이런 조언을 하는 경우가 많다.\
    \-> 재활용성이 있거나, 너무 긴 코드의 가독성이 필요할 때만 함수로 만들라는 조언이 적합하다.
* 하지만 너무 간단한 연산에 함수를 만드는 것은, 함수호출에 필요한 오버헤드를 떠맡기에는 좀 부담이 된다. \
  \-> 해법이 없을까?

#### 인라인 함수 (함수 호출의 오버해드를 개선하는 방법)&#x20;

* 코드를 살펴보자
  * 다음과 같이 inline 키워드를 헤더부분에 선언해주고 함수를 사용하게 되면,
  * 개발자가 보기에는 함수를 호출하는 것으로 보여지지만, 컴파일러가 리턴값으로 바꾸어준다.
  * \#define 과 같이 매크로의 개념과 매우 비슷하다.\
    `#define SQUARE(x) (x)*(x)`

<pre class="language-cpp"><code class="lang-cpp"><strong>// 클래스 멤버함수가 아닌 경우
</strong><strong>inline int Square(int number)
</strong><strong>{
</strong><strong>    return number * number;
</strong><strong>}
</strong><strong>
</strong><strong>// 클래스 멤버함수의 경우
</strong><strong>// Animal.h
</strong><strong>// .h 파일 안에 inline 함수의 구현체가 있어야만 한다.
</strong>class Animal
{
public:
    Animal(int age);
    inline int GetAge() const;
};

int Animal::GetAge() const
{
    return mAge;
}

// Main.cpp
// 컴파일 전!
Cat* myCat = new Cat(2, "COCO");
int age = myCat->GetAge();

// 컴파일 후!
Cat* myCat = new Cat(2, "COCO");
int age = myCat.mAge;    // mAge 는 private 변수이기 때문에, 이러한 체크는 컴파일러가 해준다.
</code></pre>

#### 그렇다면 대신 매크로를 사용해도 되나?

* 하지만, 매크로는 디버깅이 너무 힘들다 ..
* 매크로는 범위를 준수하지 않는다.
  * 엑세스 체크, 범위를 준수하지 않는다.
* **정말 매크로를 쓸 이유가 있지 않는 한 인라인 함수를 쓰자!**

#### **인라인 함수를 쓸 때 주의점!**

* inline 키워드는 힌트일 뿐이다.
  * 실제로 인라인이 안될수도 있다!?
  * 컴파일러가 자기 맘대로 인라인을 할수도 안할수도 있다.
* 인라인 함수 구현이 헤더 파일에 위치해야 한다!
  * 컴파일러가 .cpp 파일을 따로 컴파일 하는데,&#x20;
  * 따라서 b.h 를 인클루드 하는 a.cpp 파일을 컴파일 할 때, 컴파일러는 b.cpp 에 뭐가 들어있는 줄 모른다!
  * 때문에, 복붙을 하려면 컴파일러가 그 구현체를 볼 수 있어야 하기 때문에, 인라인 함수 구현이 헤더 파일에 위치해야 한다.
* 간단한 함수에 적합하다.
  * 특히 getter, setter
* 실행파일의 크기가 증가하기가 쉽다.
  * 동일한 코드를 여러번 복붙하기 때문에, 실행파일의 크기가 증가하고
  * 남용하지 말자!
  * 실행파일이 작을수록 CPU 캐시하고 잘 작동한다. \
    \-> 속도가 더 빨라질 수 있다.
