# 6-3. 가상 함수에 대한 지식들

## 가상 소멸자&#x20;

* virtual 키워드를 소멸자에도 붙여서 실제 개체의 소멸자가 호출되게 할 수도 있다.&#x20;
* 대부분은 소멸자는 실제 개체의 소멸자를 호출하기를 원하기 때문에, 부모 클래스의 소멸자에는 virtual 키워드를 붙이자!

## 가상 함수 구현의 원리&#x20;

* 지금까지의 구현을 바탕을 다음과 같은 의문이 들수도 있다.\
  \-> 모든 함수를 가상 함수로 구현하면 안될까?
* 실제로 Java 의 경우에는 모든 함수가 default 로 가상 함수로 선언된다.&#x20;
* **그렇다면 왜 C++ 은 virtual 선언을 통해서 가상 함수가 동작하도록 했을까?**\
  **-> 이것은 약간의 오버헤드가 존재하기 때문이다..**&#x20;
* **C++ 컴파일러는 가상 함수가 하나라도 존재하는 클래스에 대해서 가상 테이블을 만들게 된다.** \
  **-> 가상 테이블 : 함수가 실제 어떤 개체와 연관이 있는지 나타내는 테이블**&#x20;
* 그 결과 아래의 코드는 아래 이미지와 같은 관계를 만들어내게 된다. \
  \-> 가상 테이블의 메모리 공간은 개체 내부에 일정량을 할당하고 있다.&#x20;

```cpp
class Parent {
 public:
  virtual void func1();
  virtual void func2();
};
class Child : public Parent {
 public:
  virtual void func1();
  void func3();
};
```

<figure><img src="../../../.gitbook/assets/스크린샷 2024-05-24 15.11.44.png" alt=""><figcaption></figcaption></figure>

* 비 가상 함수들은 직접적으로 함수를 호출하게 되지만, 가상 함수들은 가상 테이블을 거쳐 함수를 호출하기 때문에, 비 가상 함수에 비해 약간의 오버헤드를 가지게 된다.&#x20;

#### 비 가상 함수와 가상 함수의 성능적 차이는 미미하지만, 최적화가 필요한 분야는 이와 같은 성능의 차이도 개선을 해야 하기에, virtual 선언을 통해서 가상 함수(동적 바인딩) 를 사용할 수 있다.&#x20;
