# const

## const 의 의미

* 다음 const 키워드의 의미를 확인해보자

```cpp
const int num = 10;                // 변수 num 을 상수화
const int * ptr1 = &val1;          // 포인터 ptr1 을 이용해서 val1 의 값을 변경할 수 없음
int * const ptr2 = &val2;          // 포인터 ptr2 가 상수화 됨    
const int * const ptr3 = &val3;    // 포인터 ptr3 가 상수화 되었으며, ptr3 를 이용해서 val3 의 값을 변경할 수 없음
```

## const 사용의 꿀팁

### 1. 참조자를 이용한 Call-by-reference 단점을 해결한 const 참조자

* 예를 들어서 코드를 분석하는 과정에 있다면, 함수의 호출문장만 보고도 함수의 특성을 어느 정도 판단할 수 있어야 한다. 그러나 참조자를 사용하는 경우, 함수의 원형을 확인해야 하고, 확인결과 참조자가 매개변수의 선언에 와있다면, 함수의 몸체까지 문장 단위로 확인을 해서 참조자를 통한 값의 변경이 일어나는 지를 확인해야 한다.&#x20;
* **const 를 통해 해당 단점을 해소할 수 있다.** \
  **-> 함수 내에서, 참조자를 통한 값의 변경을 진행하지 않을 경우, 참조자를 const 로 선언해서, 함수의 원형만 보더라도 값의 변경이 이뤄지지 않음을 알 수  있게 한다.**
* 아래 코드를 보자&#x20;

```cpp
void HappyFunc(const int &ref) {...}    // 참조자 ref 를 이용한 값의 변경은 하지 않겠다. 
```

* 다음의 논리적인 허점을 주의하자..!

```cpp
// before =============================
const int num = 20;    // 상수 선언을 하고, 
int &ref = num;
ref += 10;
cout << num << endl;   // 참조자를 통해 값을 바꾼다고?? 물론 C++ 컴파일러 에러가 발생한다.

// After ==============================
const int num = 20;
const int &ref = num;
ref += 10;             // 컴파일 에러
cout << num << endl;
```

### 2. 참조자의 상수 참조를 통한 리터럴 연산 함수

* 20, 30 과 같은 리터럴 값들은 다음의 특징을 갖는다. \
  \-> **임시적으로 존재하는 값이다. 다음 행으로 넘어가면 존재하지 않는 상수이다.**&#x20;
* 만약 리터럴 값을 매개변수로 받아 연산을 해야하는 함수라면 어떻게 하는가?&#x20;
* 아래 코드를 보자

```cpp
// before =============================
int Adder(int &num1, int &num2)
{
    return num1 + num2;
}

int result = Adder(10, 20);    // 컴파일 에러(리터럴은 다음 행으로 넘어가면 존재하지 않는 상수이다)

// after ==============================
int Adder(const int &num1, const int &num2)    // 참조자의 상수 참조를 사용할 때, 임시 변수를 생성하게 된다. 
{
    return num1 + num2;    // 만들어진 임시 변수를 통해 연산을 하게 된다.
}

int result = Adder(10, 20);    // SUCCESS
```
