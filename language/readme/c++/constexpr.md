# constexpr

## 템플릿 메타프로그래밍&#x20;

* 컴파일 타임에 실행되는 프로그래밍 기법입니다. 이는 템플릿을 사용하여 코드를 생성하거나 변환함으로써 실행 시간이 아닌 컴파일 시간에 프로그램을 수정하고 확장하는 방법입니다.\
  \-> 아래와 같이 피보나치 수열의 값을 템플릿을 이용해 컴파일 타임에 값을 구할 수 있다.&#x20;
* 왜 사용할까?
  * **컴파일 도중에 값을 평가하기 위해서.**
  * **최적화** \
    **-> 그러나 가독성이 좋지 않다..**&#x20;
  * _**아래 예제는 컴파일 시 45 라는 값이 정해져 있어야 한다.**_\
    _**-> 런타임에 피보나치 수열의 값을 받기 위해서는 런타임 용 함수를 만들어내야 한다.**_ \
    _**-> 코드 중복이 생겨난다..**_&#x20;

#### 결론적으로 템플릿 메타프로그래밍은 좋은 방법이 아니다!

<figure><img src="../../../.gitbook/assets/image (99).png" alt=""><figcaption></figcaption></figure>

## constexpr

* **우리의 의도는 컴파일 도중에 값을 평가하는 것임을 컴파일러에게 알려줌**&#x20;
* _**변수는**_** 컴파일러가 컴파일 도중에 반드시 결정지어 줌**&#x20;
* _**함수는**_** 컴파일 도중에 결정지어주려 노력함** \
  **-> 평가할 수 없을 경우, 실행시에 그 함수가 호출된다.**&#x20;

## constexpr 함수, 변수

### constexpr 함수

* **constexpr 를 사용해 함수를 만들게 되면, 컴파일 타임에 값을 구할 수 있다면, 컴파일 타임에 동작하게 되고,**&#x20;
* **런타임에 값을 구할 수 있다면, 런타임에 동작하도록 한다.** \
  **-> 템플릿 메타프로그래밍처럼 템플릿과 함수 두개를 만들 필요가 없다.**

<figure><img src="../../../.gitbook/assets/image (100).png" alt=""><figcaption></figcaption></figure>

### constexpr 변수

* **아래 예제 중 constexpr 의 매개변수가 상수가 아닌 경우, 컴파일 에러가 발생한다.** \
  **-> constexpr 변수는 컴파일 중에 값이 평가되어야 하기 때문이다!**

#### _**컴파일 도중에 '반드시' 값이 결정되게 하고 싶다면, constexpr 변수를 사용해라!**_

<figure><img src="../../../.gitbook/assets/image (101).png" alt=""><figcaption></figcaption></figure>

* 물론 과도한 연산의 경우, 컴파일 에러가 발생하기도 한다.&#x20;

<figure><img src="../../../.gitbook/assets/image (102).png" alt=""><figcaption></figcaption></figure>

## const vs constexpr (결국은 둘다 const)

### const&#x20;

* **변수와 함수 모두 변경이 불가하다..**&#x20;
* **멤버 함수에만 사용 가능하다.** \
  **-> 멤버 변수를 바꿀 수 없다는 것을 의미한다.**&#x20;

### constexpr

* **변수의 경우 컴파일 시 평가되어 변경이 불가하지만,**&#x20;
* **함수의 경우 컴파일 시 평가해주었으면 좋겠다는 것이지, 변경도 가능하다.**&#x20;
* **멤버 함수와 비멤버 함수에 둘 다 사용 가능하다.** \
  **-> 멤버 변수를 바꿀 수 있다. ( C++14 부터)**

<figure><img src="../../../.gitbook/assets/image (104).png" alt=""><figcaption></figcaption></figure>

<figure><img src="../../../.gitbook/assets/image (105).png" alt=""><figcaption></figcaption></figure>
