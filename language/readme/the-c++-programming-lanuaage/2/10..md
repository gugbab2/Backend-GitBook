# 10. 표현식

### 10.3.4 임시 개체&#x20;

* 종종 컴파일러는 표현식의 중간 결과를 보관하기 위해 개체를 저장해야 한다. \
  \-> 예를 들어, v=x+y\*z 의 경우 y\*z 의 결과를 x 에 더하기 전에 어딘가에 저장해야 한다.&#x20;
* 기본 타입의 연산 시 임시 개체로 처리되어 사용자에게 보여지지 않는다.&#x20;
* 임시 개체는 특수한 경우를 제외하고는 임시 개체 생성과 관련된 표현식이 끝날 때 소멸된다. \
  \-> 임시 개체는 자신의 참조자나 이름 있는 개체가 유효 범위를 벗어날 때 소멸된다.&#x20;
* 임시 개체는 rvalue 이다. \
  \-> 때문에, & 변수에는 초기화가 불가하다. \
  \-> const & 변수는 초기화가 가능하다.&#x20;

```cpp
void h (string& s1, string& s2)
{
    const string& s = s1 + s2;    // const & 변수는 초기화가 가능
    string& ss = s1 + s2;         // 컴파일 에러 ;;
    string sss = s1 + s2;         // 기본 변수에는 초기화 가능
}
```

## 10.4 상수 표현식&#x20;

* C++ 는 '상수' 에 관련 된 두 가지 의미를 제공한다.&#x20;
  * constexpr : 컴파일 타임에 평가된다. ( C++11 에 등장, 이번 절에서 주요하게 다뤄볼 예정)
  * const : 해당 유효 범위에서 변경되지 않는다.&#x20;
* constexpr 은 컴파일러가 평가할 수 있는 표현식이다. \
  \-> constexpr 은 컴파일 타임에 알려지지 않은 변수를 사용할 수 없으므로 side effect 가 없다.&#x20;
* 변수에 비해 상수를 좋아하는 이유
  * **이름 있는 상수는 가독성이 높다.**&#x20;
  * **변수는 변경될 가능성이 있다.**&#x20;
  * **임베디드 프로그래머들은 불변 데이터를 좋아한다.** \
    **-> 상수 메모리는 동적 메모리보다 저렴하고, 대부분 시스템 에러에 영향을 받지 않는다.**&#x20;
  * **초기화가 컴파일 타임에 수행될 경우 멀티스레드 시스템에서는 해당 개체에 대한 경합이 일어나지 않는다.**&#x20;
  * **컴파일 타임의 평가는 성능 향상을 의미한다.** \
    **-> 런타임에 수만번 평가가 일어날 수도 있다.**&#x20;
* constexpr 변수는 컴파일 타임에 평가되어 변경이 불가하다. \
  \-> constexpr 함수의 경우, 컴파일 타임에 평가가 가능하다면 컴파일 타임에 동작하고, 아니라면 런타임에 동작한다. (유연성을 제공한다)&#x20;

### 10.4.1. 기호 상수&#x20;

* 상수 변수를 이용하는 이유는 매직 넘버(하드코딩 된 값) 을 없애고, 가독성 좋은 코드를 만들기 위해 사용된다. \
  \-> 무질서하게 사용되는 리터럴 값은 가장 성가신 유지 보수의 난관 중 하나이다. \
  (배열의 크기를 매직넘버를 사용하게 되면 그 값을 바꾸기 위해 배열마다 일일이 매직넘버를 수정해야 한다)&#x20;

### 10.4.2 상수 표현식에서의 const&#x20;

* 기본적으로 컴파일 타임의 상수를 정의하는 의미에서 constexpr 이 const 보다 나은 선택이지만, 오래된 코드는 const 를 사용하는 경향이 있다.&#x20;

## 10.5 암시적 타입 변환&#x20;

* 정수 및 부동소수점 타입은 대입문과 표현식에서 자유롭게 뒤섞여 쓰일 수 있다. \
  \-> 가능한 경우에 언제나 변수는 암시적으로 형 변환이 이루어진다.&#x20;
* **그러나 문제는, 값이 손실(축소) 되는 변환까지 암시적으로 이루어진다는 점에 있다.**&#x20;
* 어떤 변환이 값을 보존하려면, 값을 변환한 다음, 원래 타입으로 결과를 다시 변환해서 원래의 값을 구할 수 있어야 한다. \
  \-> **변환이 그렇게 할 수 없다면 축소 변환(narrowing conversion) 이 된다.**&#x20;

### 10.5.1 타입 승격&#x20;

* **값을 보존하는 암시적 변환은 보통 타입 승격(type promotion) 이라고 한다.**&#x20;
* 산술 연산을 수행하기 위해 _**int 보다 작은 정수형 타입에서 int 로 암시적 형변환**_이 일어나는 케이스를 볼 수 있다. \
  \-> **타입 승격은 long 으로는 일어나지 않는다는 점을 유의하자.** \
  **(C 에서 타입 승격을 도입한 본래의 목적은 '자연스러운' 크기로 맞춘다는 것이다!)**

### 10.5.2 타입 변환&#x20;

* 기본 타입끼리는 당혹스러울 정도로 많은 방법으로 서로 간에 암시적으로 변환될 수 있다. \
  \-> 때문에, 코드를 작성할 때 의도하지 않은 방식으로 정보를 날려버릴 수 있기 때문에, 주의해야 한다.&#x20;
* {} 초기화 식 문법은 축소 변환을 방지한다.&#x20;

```cpp
void f(double d)
{
    char c {d};    // error : 축소 변환을 방지.. 
}
```
