# 13. 예외 처리

## 13.1 오류 처리

### 13.1.1 예외

* 예외(exception) 이란 개념은 오류가 탐지된 시점에서 오류가 처리될 수 있는 시점으로 정보를 전달하는 데 도움을 주기 위해 제공된다.&#x20;
* 전형적인 예제는 아래와 같다.&#x20;

```cpp
void taskmaster()
{
    try{
        auto result = do_task();
        // 결과를 사용한다. 
    }
    catch(Some_error){
        // do_task 실행 실패 - 문제를 처리한다. 
    }
}

int do_task()
{
    // ...
    if(/*테스크를 수행할 수 없다면*/)
        return result;
    else
        throw Some_error{};
}
```

* 기본적으로 예외는 특정 목적을 위해 특별히 정의된 사용자 정의 타입만을 사용하기를 권장한다. \
  \-> 명확한 의도전달!

```cilkcpp
struct Range_error {}; 
void f(int n)
{
    if (n<0 || max<n) throw Range_error{}; 
    ...
}
```

### 13.1.2 전통적인 예외 처리&#x20;

* 프로그램 종료!(꽤나 과격한 방법..)\
  \-> 계속적으로 돌아가는 프로그램에서는 사용 불가한 방법&#x20;

```cpp
if(something_wrong) exit(1);
```

* 오류  처리 함수를 호출한다.&#x20;
  * 오류 처리 함수를 통해서 프로그램이 종료되지 않고 로직이 계속될 수 있다.&#x20;

```cpp
if(something_wrong) something_handler();    // 오류 처리 함수를 통해서 로직이 계속 될 수 있다. 
```

### 13.1.3. 버티기&#x20;

* 프로그램이 종료를 받아들일 수 없는 상황이라면 모든 예외를 붙잡아 둘 수 있다. \
  \-> 결국 예외는 프로그래머가 허용한 경우에만 프로그램을 종료한다.&#x20;
* 때때로 사람들은 오류 메시지를 출력하고, 사용자에게 도움을 요청하는 대화상자를 만드는 등의 방식으로 '버티기' 의 부정적인 측면들을 완화시키려고 노력한다.&#x20;

### 13.1.4 예외의 다른 관점&#x20;

#### 13.1.4.1 비동기적 이벤트&#x20;

* 예외 처리 매커니즘은 동기적은 예외만을 처리하게 설계되어 있다.&#x20;
* 비동기적 이벤트는 예외 처리를 사용할 수 없기 때문에, 근본적으로 다른 매커니즘을 필요로 한다.&#x20;
* 많은 시스템은 비동기적 예외를 처리하기 위한 매커니즘 신호와 같은 것들을 지원해서 비동기적 예외를 처리한다.&#x20;

#### 13.1.4.2 오류가 아닌 예외&#x20;

* 예외를 '시스템의 어떤 부분에서 요청된 작업을 처리할 수 없는 것' 이라고 생각해보자.
* 예외(throw) 는 함수 호출에 비해서 드물에 이루어져야 한다.\
  \-> 그렇지 않은 경우 시스템 구조가 모호해진다.&#x20;
* 프로그램 동작에 나쁜 영향을 끼치지 않는 예외의 경우, 단지 프로그래머는 그것을 오류라고 간주하고 예외처리 매커니즘을 오류를 처리하는 도구 정도로 생각한다. \
  \-> 누군가는 예외 처리 매커니즘을 그저 또 하나의 제어 구조이자 호출자에게 값을 반환하는 다른 방법 정도로 생각할 수 있다.&#x20;
* **'예외처리는 오류처리' 라는 관점에 집중해야 한다.** \
  **-> 그 외 관점의 예외처리는 용도에 맞지 않게 사용하고 있는 것이다.**&#x20;

### **13.1.6. 계층적인 예외 처리**&#x20;

* 예외 처리의 목적은 프로그램의 한 부분이 다른 부분에게 요청된 작업이 수행될 수 없다는 사실을 알려주기 위한 수단을 제공하는 것이다.&#x20;
* 프로그램의 다양한 부분이 예외 처리되는 방식과 예외가 처리될 장소에 대한 정의가 되어 있어야 한다. \
  \-> 예외 처리 매커니즘은 기본적으로 비지역적으로 종합적인 전략을 정의하는 것이 필수적이다. \
  \-> 간단하고 명료해야 한다.&#x20;
* 규모가 큰 프로젝트에서 예외 처리 전략을 상세하게 정의하고 지키기는 어려운 일이다.. \
  \-> 때문에, 범용적으로 사용할 수 있는 예외처리 전략을 세우는 일은 중요한 일이다!\
  \-> 범용적이고, 계층적인 예외 처리 전략을 필수적이다.&#x20;

### 13.1.7 예외와 효율성&#x20;

* 예외 던지기는 함수 호출처럼 비용이 많이 들지 않게끔 구현될 수 있다. \
  \-> 쉬운일은 아니다.. \
  \-> 하지만, 예외 처리가 아닌 다른 대안 역시 공짜는 아니다!
* 예외 처리와 관련 없어 보이는 아래 함수를 확인해보자.
  * g() 나 h() 는 예외를 던질 수 있으므로, f() 는 예외가 일어날 경우 buf 를 제대로 소멸시킬 수 있는 코드를 탑재해야 한다.

```cpp
void f()
{
    string buf;
    cin>>buf;
    ...
    g(1);
    h(buf);
}    
```

* 신중하고 체계적인 오류 처리가 필요할 때는 예외 처리 매커니즘을 사용하는 것이 최선이다.&#x20;
* noexcept 키워드를 사용하게 되면 컴파일러에게 해당 함수는 예외를 던지지 않는 것을 알려주기 때문에, 요긴하게 사용될 수 있다.&#x20;
  * 전통적인 C 함수는 예외를 던지지 않으므로 대부분의 C 함수는 noexcept 를 사용할 수 있다.&#x20;
  * 하지만, C 함수 내부에서 C++ 의 new 연산자를 사용해 bad\_alloc 을 던질수도 있다..\
    **-> 늘 그렇듯 측정이 수반되지 않은 효율성 논의는 무의미하다.**&#x20;

## 13.2 예외 보장&#x20;

#### C++ 표준 라이브러리는 모든 라이브러리 연산에 대해서 다음중 하나를 보장한다.&#x20;

* 모든 연산에 대한 기본적 보장(basic guarantee)
  * 모든 개체의 불 변속성이 유지되며, 메모리 등의 자원이 누출되지 않는다.&#x20;
  * 특히 모든 기본 제공 및 표준 라이브러리 타입의 기본 불변속성은 모든 표준 라이브러리 연산 이후, 개체를 소멸시키거나 개체의 대입을 할 수 있도록 보장해준다.&#x20;
* 핵심 연산에 대한 강력한 보장(string guarantee)&#x20;
  * 기본 보장 제공에 추가해서 연산은 성공하지 않을 경우 아무런 영향을 미치지 않는다.&#x20;
  * 이 보장은 push\_back(), 리스트에서 얻은 단일 원소, uninitialized\_copy() 같은 핵심 연산을 위해 제공된다.
* 일부 연산에 대한 예외 금지 보장(nothrow guarantee)
  * 기본 보장 제공에 추가해서 일부 연산은 예외를 던지지 않게 보장된다.
  * 이 보장은 두 컨테이너의 swap() 이나 pop\_back() 같은 몇가지 간단한 연산을 위해 사용된다.&#x20;

#### basic guarantee 와 strong guarantee 는 다음 조건을 만족하는 경우에만 제공된다.&#x20;

* 사용자 제공 연산(대입이나 swap() 함수 등) 은 컨테이너 원소를 유효하지 않은 상태로 남겨두지 않아야 한다.&#x20;
* 사용자 제공 연산은 누출하지 않아야 한다.&#x20;
