# 13. 예외 처리

## 13.1 오류 처리

### 13.1.1 예외

* 예외(exception) 이란 개념은 오류가 탐지된 시점에서 오류가 처리될 수 있는 시점으로 정보를 전달하는 데 도움을 주기 위해 제공된다.&#x20;
* 전형적인 예제는 아래와 같다.&#x20;

```cpp
void taskmaster()
{
    try{
        auto result = do_task();
        // 결과를 사용한다. 
    }
    catch(Some_error){
        // do_task 실행 실패 - 문제를 처리한다. 
    }
}

int do_task()
{
    // ...
    if(/*테스크를 수행할 수 없다면*/)
        return result;
    else
        throw Some_error{};
}
```

* 기본적으로 예외는 특정 목적을 위해 특별히 정의된 사용자 정의 타입만을 사용하기를 권장한다. \
  \-> 명확한 의도전달!

```cilkcpp
struct Range_error {}; 
void f(int n)
{
    if (n<0 || max<n) throw Range_error{}; 
    ...
}
```

### 13.1.2 전통적인 예외 처리&#x20;

* 프로그램 종료!(꽤나 과격한 방법..)\
  \-> 계속적으로 돌아가는 프로그램에서는 사용 불가한 방법&#x20;

```cpp
if(something_wrong) exit(1);
```

* 오류  처리 함수를 호출한다.&#x20;
  * 오류 처리 함수를 통해서 프로그램이 종료되지 않고 로직이 계속될 수 있다.&#x20;

```cpp
if(something_wrong) something_handler();    // 오류 처리 함수를 통해서 로직이 계속 될 수 있다. 
```

### 13.1.3. 버티기&#x20;

* 프로그램이 종료를 받아들일 수 없는 상황이라면 모든 예외를 붙잡아 둘 수 있다. \
  \-> 결국 예외는 프로그래머가 허용한 경우에만 프로그램을 종료한다.&#x20;
* 때때로 사람들은 오류 메시지를 출력하고, 사용자에게 도움을 요청하는 대화상자를 만드는 등의 방식으로 '버티기' 의 부정적인 측면들을 완화시키려고 노력한다.&#x20;

### 13.1.4 예외의 다른 관점&#x20;

#### 13.1.4.1 비동기적 이벤트&#x20;

* 예외 처리 매커니즘은 동기적은 예외만을 처리하게 설계되어 있다.&#x20;
* 비동기적 이벤트는 예외 처리를 사용할 수 없기 때문에, 근본적으로 다른 매커니즘을 필요로 한다.&#x20;
* 많은 시스템은 비동기적 예외를 처리하기 위한 매커니즘 신호와 같은 것들을 지원해서 비동기적 예외를 처리한다.&#x20;

#### 13.1.4.2 오류가 아닌 예외&#x20;

* 예외를 '시스템의 어떤 부분에서 요청된 작업을 처리할 수 없는 것' 이라고 생각해보자.
* 예외(throw) 는 함수 호출에 비해서 드물에 이루어져야 한다.\
  \-> 그렇지 않은 경우 시스템 구조가 모호해진다.&#x20;
* 프로그램 동작에 나쁜 영향을 끼치지 않는 예외의 경우, 단지 프로그래머는 그것을 오류라고 간주하고 예외처리 매커니즘을 오류를 처리하는 도구 정도로 생각한다. \
  \-> 누군가는 예외 처리 매커니즘을 그저 또 하나의 제어 구조이자 호출자에게 값을 반환하는 다른 방법 정도로 생각할 수 있다.&#x20;
* **'예외처리는 오류처리' 라는 관점에 집중해야 한다.** \
  **-> 그 외 관점의 예외처리는 용도에 맞지 않게 사용하고 있는 것이다.**&#x20;

### **13.1.6. 계층적인 예외 처리**&#x20;

* 예외 처리의 목적은 프로그램의 한 부분이 다른 부분에게 요청된 작업이 수행될 수 없다는 사실을 알려주기 위한 수단을 제공하는 것이다.&#x20;
* 프로그램의 다양한 부분이 예외 처리되는 방식과 예외가 처리될 장소에 대한 정의가 되어 있어야 한다. \
  \-> 예외 처리 매커니즘은 기본적으로 비지역적으로 종합적인 전략을 정의하는 것이 필수적이다. \
  \-> 간단하고 명료해야 한다.&#x20;
* 규모가 큰 프로젝트에서 예외 처리 전략을 상세하게 정의하고 지키기는 어려운 일이다.. \
  \-> 때문에, 범용적으로 사용할 수 있는 예외처리 전략을 세우는 일은 중요한 일이다!\
  \-> 범용적이고, 계층적인 예외 처리 전략을 필수적이다.&#x20;

### 13.1.7 예외와 효율성&#x20;

* 예외 던지기는 함수 호출처럼 비용이 많이 들지 않게끔 구현될 수 있다. \
  \-> 쉬운일은 아니다.. \
  \-> 하지만, 예외 처리가 아닌 다른 대안 역시 공짜는 아니다!
* 예외 처리와 관련 없어 보이는 아래 함수를 확인해보자.
  * g() 나 h() 는 예외를 던질 수 있으므로, f() 는 예외가 일어날 경우 buf 를 제대로 소멸시킬 수 있는 코드를 탑재해야 한다.

```cpp
void f()
{
    string buf;
    cin>>buf;
    ...
    g(1);
    h(buf);
}    
```

* 신중하고 체계적인 오류 처리가 필요할 때는 예외 처리 매커니즘을 사용하는 것이 최선이다.&#x20;
* noexcept 키워드를 사용하게 되면 컴파일러에게 해당 함수는 예외를 던지지 않는 것을 알려주기 때문에, 요긴하게 사용될 수 있다.&#x20;
  * 전통적인 C 함수는 예외를 던지지 않으므로 대부분의 C 함수는 noexcept 를 사용할 수 있다.&#x20;
  * 하지만, C 함수 내부에서 C++ 의 new 연산자를 사용해 bad\_alloc 을 던질수도 있다..\
    **-> 늘 그렇듯 측정이 수반되지 않은 효율성 논의는 무의미하다.**&#x20;

## 13.2 예외 보장&#x20;

#### C++ 표준 라이브러리는 모든 라이브러리 연산에 대해서 다음 중 하나를 보장한다. &#x20;

> #### C++ 표준 라이브러리가 여러 수준의 예외 안정성을 제공하는 이유
>
> * 예외 발생시에도 프로그램이 일관된 상태를 유지
> * 리소스 누수 등 심각한 문제가 발생하지 않도록

* **기본 보장(basic guarantee)**
  * **일관된 상태 유지 :** 표준 라이브러리의 대부분의 구성 요소는 예외가 발생하더라도 개체가 일관된 상태를 유지하도록 설계되었다.&#x20;
  * **리소스 누수 방지** : 표준 라입브러리는 예외 발생 시 리소슥가 누수되지 않도록 보장한다.&#x20;
  * **아래 코드에서 vec 의 상태는 구체적으로 알 수 없다..** \
    \-> 예외가 발생하기 전의 상태, 즉 '{1,2,3}' 일수도 있고, \
    \-> 예외가 발생하기 직전의 상태인, 즉 '{1,2,3,4}' 일수도 있다. \
    \-> 구체적으로 어떤 상태인지 예측할 수 없지만, vec 는 항상 유효한 상태를 유지한다.&#x20;

<pre class="language-cpp"><code class="lang-cpp"><strong>void exampleFunction()
</strong>{
    std::vector&#x3C;int> vec = {1,2,3};
    try{
        vec.push_back(4);        // 예외가 발생할 수 있다. 
    } catch(...) {
         // 예외가 발생해도 vec 는 일관된 상태를 유지한다. 
    }
    // vec 는 여전히 일관된 상태지만, 내용은 알 수 없다.
}
</code></pre>

* **강한 보장(strong guarantee)**
  * **롤백** : 일부 표준 라이브러리의 구성 요소는 예외가 발생하면 함수 호출 이전 상태로 되돌릴 수 있는 강한 보장을 제공한다.&#x20;

```cpp
std::vector<int> vec = {1,2,3};
std::vector<int> temp = vec;    // 임시 복사본 생성
try {
    temp.push_back(4);    // 예외 발생 가능성 있음 
    vec = temp;           // 성공하면 vec 에 적용
} catch (...) {
    // vec 는 
}
```

* **예외 없음 보장(nothrow guarantee)**
  * **예외를 던지지 않음** : 표준 라이브러리의 일부 함수는 예외를 던지지 않음을 보장한다. 주로 소멸자, 메모리 할당 / 해제 함수 등에서 사용된다.&#x20;

```cpp
void noThrowFunction() noexcept {
    // 예외를 던지지 않는 함수
    try {
        // 안전한 코드 작성 
    } catch (...) {
        // 모든 예외를 잡아 처리
    }
}
```
