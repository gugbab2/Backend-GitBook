# 11. 선택 연산

## 11.2 힙 영역 메모리

### 11.2.1 메모리 관리

* 힙 저장 공간의 주요 문제점은 다음과 같다.&#x20;
  * **메모리 누수(leaked object) : new 를 통해 힙 영역에 데이터를 생성하고 나서 delete 를 사용하지 않을 때 메모리 누수가 발생한다.** \
    **-> 메모리 누수는 프로그램의 저장 공간을 줄이기 때문에, 심각한 문제가 될 가능성이 있다.**&#x20;
  * **빠른 소멸(premature deletion) : 개체를 delete 하고 나중에 그 포인터를 사용하고자 할 때**&#x20;
  * **중복 소멸(double deletion) : 개체를 두번 소멸할 때**\
    **-> 한번 개체를 소멸하면, 해당 메모리 공간은 운영체제에 의해 다른 변수에게 할당될 수 있다.** \
    **-> 두번 개체를 소멸하는 것은 다른 변수의 메모리 공간을 소멸한다는 것!** \
    **(정말 잘못된 상황을 초래할 수 있다.. )**
* 위와 같은 문제점이 있기에, 'new', 'delete' 를 사용하는 방식에 두 가지 권장 사항이 있다.&#x20;
  * **꼭 필요하지 않다면, 동적 할당을 하지 않는다.** \
    **-> 스택에 변수를 우선적으로 저장한다.**&#x20;
  * **힙 영역에 개체를 생성할 때, 그것들을 관리해주는 표준 라이브러리 or 컨테이너를 사용해라.** \
    **-> 예를 들어, STL 컨테이너는 기본적으로 동적으로 메모리 공간을 관리해주고, 내부적으로 개체의 생성과 소멸을 담당한다.** \
    **-> string, vector, unique\_ptr, shared\_ptr 등 ..**&#x20;

### 11.2.2 배열&#x20;

* 개체의 배열 역시 new 로 생성할 수 있다.&#x20;
* 개체의 배열을 삭제할 때 delete\[] 가 사용된다. \
  \-> \[] 를 사용하지 않는다면 배열의 첫번째 메모리만 해제되고, 나머지 해제되지 않는다.&#x20;
* 배열과 컨테이너는 new 를 통해 힙영역에 생성할 수 있지만, 지역 개체에는 new 를 사용하지 말아야 한다. \
  \-> 아래 코드는 비효율적이다.. \
  \-> return 이나 delete 이전에 발생한 예외는 메모리 누수를 일으킬 것이다. \
  (지역 변수를 사용하자.. )

<pre class="language-cpp"><code class="lang-cpp"><strong>// 사용하면 안되는 방식!
</strong><strong>void f1()
</strong>{
    X* p = new X;
    // ... *p 를 사용한다. 
    
    delete p;
}

// 사용해도 되는 방식.
void f2() 
{
    X x; 
    // ... x 를 사용한다. 
}
</code></pre>

### 11.2.3 메모리 공간 확보&#x20;

* new 키워드를 통해 힙 영역의 메모리 공간을 확보할 수 있다.&#x20;
* new 가 할당할 수 있는 공간을 찾지 못하면 **기본 설정 상 bad\_alloc 이라는 예외를 던진다.** \
  \-> 아래 코드는 엄청난 메모리 공간을 소모하고, 결국 bad\_alloc 예외를 호출할 수 밖에 없다.&#x20;

```cpp
void f()
{
    vector<char*> v;
    try{
        for(;;){
            char* p = new char[10000];    // 메모리를 확보한다.
            v.push_back(p);               // 새로운 메모리가 사용될 공간을 체크한다. 
            p[0] = 'x';                   // 새로운 메모리를 사용한다. 
        }
    }
    catch(bad_alloc){
        cerr << "Memory schausted!\n";
    }
}
```

## 11.3 리스트&#x20;

*
