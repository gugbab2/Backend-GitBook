# 12. 함수

## 12.1 함수 선언

### 12.1.1 왜 함수인가?

* 함수의 목적은 복잡한 계산을 의미있는 덩어리로 쪼개고, 그것들에 이름을 붙이자는 것이다.&#x20;
* 이는 함수의 가독성을 높이자는 것이고, 이는 유지보수를 편하게 하기 위한 첫걸음이다.&#x20;
* 코드에서 오류의 개수는 코드의 양과 코드의 복잡성과 강력한 상관관계를 갖는데, \
  \-> 두 문제 모두 더 짧은 함수를 많이 사용함으로 해결할 수 있다.&#x20;
* 가장 기본적인 조언은 한 화면에서 전체를 볼 수 있는 정도로 함수의 크기를 유지하라는 것이다. \
  \-> 많은 프로그래머들에게 함수당 대략 40줄 정도의 함수를 만들라고 이야기한다. \
  \-> 필자가 이상적으로 생각하는 수준은 7줄이다.&#x20;
* 실질적으로 거의 모든 경우 함수 호출 비용은 문제의 원인아 아니다. \
  \-> 호출이 많아져 호출 비용의 문제가 생길 경우 인라인 함수를 사용해 비용을 줄일 수 있다.&#x20;

### 12.1.2 함수 선언문의 구성&#x20;

* 호출되는 모든 함수는 어딘가에서 선언 및 정의되야 하며, 함수 정의는 함수의 본체가 표시되는 함수의 선언이다.&#x20;
* 다음을 보자&#x20;

```cpp
void swap(int*, int*);    // 선언
void swap(int*p, int*q);    // 정의
{
    ...
}
```

* 또는, 아래와 같이 선언과 정의의 매개변수의 이름이 다를수도 있다. \
  \-> 필수는 아니지만, 가독성을 위해서 일치시킨다.&#x20;

```cpp
int& max(int& a, int& b, int& c);
int& max(int& x1, int& x2, int& x3)
{
    ...
}
```

* 아래와 같이, 이름 없는 인자를 사용할 수도 있다. \
  \-> 이름을 붙이지 않을때는, 해당 인자가 함수 정의에서 사용되지 않는다는 점을 나타낸다. \
  \-> 이는 코드를 간단히 하기 위한 목적이나, 확장을 염두해 둔 사전 설계 때문에 등장한다.&#x20;

```cpp
void seach(table* t, const char* key, const char*)
{
    // 세번째 인자는 사용되지 않는다. 
    ...
}
```

### 12.1.4 값 반환&#x20;

* 전통적으로 함수 선언에서 반환 타입이 맨 앞에 위치한다.&#x20;
* 하지만, 함수 선언은 반환 타입을 매개변수 뒤에 위치시키는 문법을 이용해서 사용될 수도 있다.&#x20;
* 아래 두 선언은 동일하다.

```cpp
string to_string(int a);            // 전위형 반환 타입(전통적 방식)
auto to_string(int a) -> string;    // 후위형 반환 타입
```

* 후위형 반환 타입이 사용될 때는, 함수 템플릿에서 중요해진다.
* 아래 코드를 보자 \
  \-> 람다와 비슷하게 생겼다.&#x20;

```cpp
template<typename T, typename U>
auto product(const vector<T>& x, const vector<U>& y) -> decltype(x*y);
```

* 매번 함수가 호출될 때마다, 스택에 변수가 할당된다. 함수가 반환된 후 해당 공간은 재사용되므로, static 이 아닌 지역변수를 가리키는 포인터는 절대로 반환되지 않아야한다. \
  \-> 참조나 포인터가 아닌 유의미한 값이 반환되어야 한다.&#x20;
* 다행스럽게도 컴파일러는 지역변수에 대한 참조자 반환에 대해서 경고를 보낸다.&#x20;
* 아래 코드는 좋지 않은 예

```cpp
int* fp()
{
    int local = 1;
    ...
    return &local;    // Bad
}

int & fr()
{
    int local = 1;
    ...
    return local    // Bad
}
```

> #### 함수를 빠져나가는 5가지 방법
>
> 1. return 문의 실행
> 2. 단순하게 함수의 끝에 도달
> 3. 지역적으로 잡히지 않는 예외를 던진다.
> 4. 예외가 던져지고 noexcept 에서 지역적으로 잡히지 못하는 것으로 인한 종료&#x20;
> 5. 반환하지 않는 시스템 함수(ex, exit()) 를 직간접적으로 호출

### 12.1.5 inline 함수&#x20;

* 함수는 아래와 같이 inline 으로 정의될 수 있다.&#x20;
  * inline 지정자는 해당 함수가 인라인 호출 코드를 생성하려 시도한다는 것을 컴파일러에게 알려주는 중요한 단서이다.&#x20;
  * inline 지정자를 선언해도 무조건적으로 인라인화가 되는 것은 아니다. 컴파일러가 판단한다.&#x20;
  * 어떤 값이 반드시 컴파일 타임에 계산되게 하고 싶다면, 해당 값을 constexpr 로 선언하고 해당 값의 평가에 사용될 모든 함수를 constexpr 로 만들어야 한다.&#x20;

```cpp
inline int fec(int n)
{
    return (n<2) ? 1 : n*fac(n-1);
}
```

### 12.1.6 constexpr 함수&#x20;

* 일반적으로 함수는 컴파일 타임에 평가될 수 없으므로 상수 표현식에 호출될 수 없다.&#x20;
* 하지만, constexpr 함수로 지정하면 해당 함수가 상수 표현식 안에서 사용되게 만들 수 있다. \
  \-> 컴파일 타임에 초기화식을 평가하겠다는 뜻이다.&#x20;

```cpp
constexpr int fac(int n)
{
    return (n>1) ? n*fac(n-1) : 1;
}
constexpr int f9 = fac(9);    // 컴파일 타임에 평가되어야 한다. 
```

```cpp
void f(int n) 
{
     int f5 = fac(5);               // 컴파일 타임에 평가될 수 있다.
     int fn = fac(n);               // n은 변수이기 때문에, 런타임에 평가된다.
 
     constexpr int f6 = fac(6);     // 컴파일 타임에 평가될 수 있다. 
     constexpr int fnn = fac(n);    // error : n은 변수이기 때문에, 컴파일 타임 평가를 보장할 수 없다. 
     
     char a[fac(4)];                // 배열의 경계는 상수여야하고, fac() 는 constexpr 이다. 
     char a2[fac(n)];               // error : 배열의 경계는 상수여야하는데, n은 변수이기 때문에 에러.
}
```

* 컴파일 타임에 평가되려면 함수는 충분히 간단해야 한다. (constexpr 은 순수 함수)&#x20;
* 때문에 다음과 같은 제약조건을 가지게 된다.&#x20;
  1. **단순한 표현식**:
     * `constexpr` 함수는 기본적으로 단순한 표현식을 포함해야 합니다. 복잡한 런타임 로직을 포함할 수 없습니다.
  2. **한정된 함수 본문**:
     * 함수 본문은 한정된 수의 명령문과 연산만을 포함할 수 있습니다. 특히 컴파일 타임에 평가될 수 있어야 합니다.
     * 조건문 (`if`), 반복문 (`for`, `while`) 등을 사용할 수 있지만, 이들 역시 컴파일 타임에 평가될 수 있어야 합니다.
  3. **상수 표현식만 사용**:
     * 함수 내에서 사용되는 모든 변수와 객체는 상수 표현식이어야 합니다.
     * `constexpr` 함수 내부에서 비상수 데이터나 포인터 조작은 허용되지 않습니다.
  4. **반환 타입**:
     * 함수의 반환 타입은 `literal type`이어야 합니다. 기본적으로 기본 자료형과 `constexpr`로 정의된 사용자 정의 타입이 이에 해당합니다.
  5. **함수 호출**:
     * `constexpr` 함수는 다른 `constexpr` 함수나 상수 표현식에서 호출될 수 있습니다.

```cpp
int glob;
constexpr void bad1(int a)        // error : constexpr 함수는 void 일 수 없다.
{
    glob = a;                     // error : constexpr 함수 내 side effect 
}

constexpr int bad2(int a)
{
    if(a>=0) return a; 
    else return -a;               // error : constexpr 함수 내 if문
}

constexpr int bad3(int a)
{
    int sum = 0;                  // error : constexpr 함수 내 지역변수 
    for(int i=0; i<a; ++i)        // error : constexpr 함수 내 반복문
        sum += fac(i);
    return sum;
}
```

#### 12.1.6.2. 조건부 평가&#x20;

* constexpr 함수 내에서 결과를 알 수 없는 조건 표현식은 컴파일 타임에 결과 값이 계산되지 않는다. \
  \-> 이는 해당 조건 표현식의 결과 값이 런타임에 계산된다는 뜻이다.&#x20;
* 다음 코드를 살펴보자.&#x20;
  * low 와 high 는 컴파일 타임에 알 수 이는 환경 매개변수이며,
  * f(x,y,z) 는 구현에 따라서 결과 값이 달라진다는 것을 알 수 있다.&#x20;

```cpp
constexpr int low = 0;
constexpr int hign = 99;

constexpr int check(int i)
{
    return (low<=i && i<high) ? i : throw out_of_range("check() failed");
}

constexpr int val0 = check(50);         // OK
constexpr int val1 = check(f(x,y,z));   // 아마도 OK
constexpr int val2 = check(200);        // 예외를 던진다.
```

### 12.1.7 \[\[noreturn]] 함수&#x20;

* \[\[...]] 구조는 속성(attribute) 라고 불리며, c++ 문법 거의 어디에나 넣을 수 있다.&#x20;
* 표준 속성은 다음 두가지가 있다.&#x20;
  * \[\[noreturn]] : 함수 선언 맨 앞에 두면 해당 함수의 반환을 기대하지 않는다는 의미이다.&#x20;
  * \[\[carries\_dependency]] :&#x20;
* 다음 코드를 살펴보자 \
  \-> \[\[noreturn]] 속성에도 불구하고, 함수가 반환한다면 무슨 일이 일어날지는 정의되어 있지 않다.&#x20;

```cpp
[[noreturn]] void exit(int);    // exit 는 절대로 반환하지 않는다. 
```

### 12.1.8 지역 변수&#x20;

* 어떤 함수 내에 정의된 변수를 지역 변수(local name) 이라고 부른다.&#x20;
* 지역 변수나 상수는 실행 스레드가 자신의 정의에 다다를 때 초기화된다.&#x20;
* 변수는 static 으로 선언돼 있지 않는 한 함수가 호출될 때마다 해당 변수의 복사본이 만들어진다. \
  \-> 만약 static 지역 변수가 있다면 실행 스레드가 자신의 정의의 다다를 때 딱 한번 초기화 될 것이다.&#x20;
