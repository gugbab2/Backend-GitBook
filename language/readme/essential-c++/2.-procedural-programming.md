# 2. 절차지향 프로그래밍(Procedural Programming)

## 2-2. 함수의 호출&#x20;

* 다음은 버블 정렬에 대한 코드이다. 아래 코드가 실제로 정렬이 이루어질까? \
  \-> 정렬이 안된다..
* 값에 의한 호출(pass by value) 이기 때문이다.&#x20;
* 함수를 호출하게 되면 스택에 다음 데이터들이 저장된다. \
  \-> **기본적으로 매개변수로 넘기는 값은 원본이 아닌 복사본을 만들게 된다.**&#x20;
  * 매개변수
  * 지역변수
* **매개변수로 넘기는 값이 복사본이기 때문에, 아무리 swap 연산을 하더라도 원본에 전혀 영향이 없다.**&#x20;

<pre class="language-cpp"><code class="lang-cpp"><strong>void dizplay(vector&#x3C;int> vec)
</strong>{
    for(int ix=0; ix&#x3C;vec.size(); ++ix)
        cout &#x3C;&#x3C; vec[ix] &#x3C;&#x3C; ' ';
    cout &#x3C;&#x3C; endl;
}

void swap(int val1 , int val2)
{
    int temp = val1;
    val1 = val2;
    val2 = temp;
}

void bubble_sort(vector&#x3C;int> vec)
{
    for(int ix=0; ix&#x3C;vec.size(); ++ix)
        for(int jx=0; ix+1; jx&#x3C;vec.size(); ++jx)
            if(vec[ix] > vec[jx])
                swap(vec[ix], vec[jx]);
}

int main()
{
    int ia[8] = {8, 34, 3, 13, 1, 21, 5, 2};
    vector&#x3C;int> vec(ia, ia+8);
    
    cout &#x3C;&#x3C; "vector before sort: ";
    display(vec);
    
    bubble_sort(vec);
    
    cout &#x3C;&#x3C; "vector after sort: ";
    dirplay(vec);
}
</code></pre>

* swap 메서드의 매개변수가 레퍼런스(&) 형으로 변경되었다. \
  **-> 스택에 복사본을 만드는 것은 동일하지만, 값 타입이 아닌 레퍼런스 타입을 받기 때문에, 원본에 영향을 미칠 수 있다.**&#x20;
* 다음과 같은 방법을 레퍼런스에 의한 전달(pass by reference) 라고 부른다.

```cpp
void dizplay(vector<int> vec)
{
    for(int ix=0; ix<vec.size(); ++ix)
        cout << vec[ix] << ' ';
    cout << endl;
}

void swap(int &val1 , int &val2)
{
    int temp = val1;
    val1 = val2;
    val2 = temp;
}

void bubble_sort(vector<int> vec)
{
    for(int ix=0; ix<vec.size(); ++ix)
        for(int jx=0; ix+1; jx<vec.size(); ++jx)
            if(vec[ix] > vec[jx])
                swap(vec[ix], vec[jx]);
}

int main()
{
    int ia[8] = {8, 34, 3, 13, 1, 21, 5, 2};
    vector<int> vec(ia, ia+8);
    
    cout << "vector before sort: ";
    display(vec);
    
    bubble_sort(vec);
    
    cout << "vector after sort: ";
    dirplay(vec);
}
```

### 래퍼런스에 의한 전달(Pass by Reference)&#x20;

* 래퍼런스는 변수를 간접적으로 다룰 수 있는 도구이다. \
  \-> 레퍼런스는 별칭을 갖는 변수라고 생각하면 이해가 쉽다.&#x20;
* 다음의 코드에서 매개변수를 받을 때 어떠한 일이 일어날까?
* **매개변수를 값으로 전달하고 있는데, 이때 vector 개체의 값 전체를 복사 후 초기화를 해준다.** \
  **-> 틀린 동작은 아니지만, vector 개체의 데이터가 10만개 들어가있다면?** \
  **-> 상당히 큰 오버헤드를 유발한다.**&#x20;

```cpp
void dizplay(vector<int> vec)
{
    for(int ix=0; ix<vec.size(); ++ix)
        cout << vec[ix] << ' ';
    cout << endl;
}
```

* 때문에 아래와 같이 **참조형 변수를 받는 것만으로 속도를 개선할 수 있다. (약간 빠르다..)**

```cpp
void dizplay(vector<int> &vec)
{
    for(int ix=0; ix<vec.size(); ++ix)
        cout << vec[ix] << ' ';
    cout << endl;
}
```

#### 레퍼런스와 포인터의 차이점 (사실 두가지 차이가 유의미할 만큼의 성능의 차이는 없다.. 하지만 교양으로 알아두자)

* 포인터 : 데이터의 주소를 가리킨다. \
  \-> 데이터가 없을 수도 있기 때문에, 역참조 이전에 항상 데이터의 유무를 확인해야한다.&#x20;
* 레퍼런스 : 레퍼런스는 기본적으로 데이터가 있기 때문에, 데이터의 유무를 확인하지 않아도 된다.&#x20;

## 2-4. 지역 정적 개체(Local Static Object) 의 사용

* 피보나치 수열을 구현하는 다음 메서드를 보자
* 한번 크기가 큰 피보나치 수열을 위해 메모리를 할당한다면, 이후 작은 피보나치 수열의 구현을 위해 메모리를 하지 않아도 되지 않을까? (정답은 아니다..)
* **정적 개체는 라이프사이클이 프로세스와 동일하기 때문에, 다음과 같이 코드를 만들어준다면, 함수 호출마다 메모리를 할당 받지 않게 된다!**

```cpp
fibon_seq(24);
fibon_seq(8);
fibon_seq(18);

const vector<int>* fibon_seq(int size)
{
    static vector<int> elems;
    
    // 프로그램 시작 
    
    return &elems;
    
}
```

