# 개체지향 프로그래밍3

#### 상속

* 부모클래스의 속성과 기능을 자식클래스에서 사용하는 방식으로 다음과 같이 사용할 수 있다. &#x20;
  * 자식클래스는 멤버 변수 및 메서드를 추가할 수 있다.&#x20;

```cpp
// Animal.h
class Animal
{
public:
    Animal(int age);
private:
    int mAge;
};

// Cat.h
class Cat : public Animal
{
public:
    Cat(int age, const char* name);
private:
    char* name;
};

// Cat.cpp
// 부모의 생성자를 초기화하고 생성자 구현부에서 자식에 추가된 부분만 신경쓴다.
Cat::Cat(int age, const char* name)
    :Animal(age)
{
    size_t size = strlen(name) + 1;
    mName = new char[size];
    strcpy(mName, name);
}
```

* 위 클래스를 자바에서 사용한다면 다음과 같이 사용할 수 있다.&#x20;

```java
public class Cat extends Animal{
    private String Name;
    public Cat(int age, String name){
        super(age);    // c++ 은 Animal(age) 를 호출
        this.Name = name;
    }
}
```

* Java 와 달리 상속 시 베이스 클래스 멤버의 접근수준을 결정할 수 있다. \
  \-> 부모와 자식 클래스 중 제한 수준이 더 높은 것으로 사용하게 된다. \
  \-> 대부분 public 을 사용하게 된다.
  * public&#x20;
  * private
  * protected

#### 상속시 메모리는 어떻게 작동할까?

*   무조건 적으로 상속받은 부모가 먼저 호출되고 그 다음 자식이 호출된다.\
    \-> _**부모와 자식간의 메모리는 연속적이고, 언제나 부모 메모리부터 쓰여진다.**_&#x20;

    <figure><img src="../../.gitbook/assets/스크린샷 2023-11-05 20.20.44.png" alt="" width="563"><figcaption></figcaption></figure>

#### 생성자 호출 순서, 소멸자 호출 순서

* 부모클래스의 생성자가 먼저 호출되고, 그 다음으로 자식클래스의 생성자가 호출된다.&#x20;
* 부모 클래스의 특정 생성자 호출시, _**초기화 리스트**_를 사용해야 한다!\
  **-> const, & 키워드가 붙은 변수들은 생성과 동시에 초기화가 되어야 하기 때문이다!**

```cpp
Cat::Cat(int legs, int age, const string& callingName)
    :Animal(legs, age)    // 명시적 호출
    , mCallingName(callingName)
{
}
```

* 호출 사례.1 \
  \-> 매개변수 없는 생성자가 있는 베이스 클래스
  * 자식 생성자에서 부모생성자를 호출하지 않는다면, 암시적으로 Animal() 과 같이 부모의 기본생성자를 호출하게 된다.

```cpp
// Animal.cpp
Animal::Animal()
    :mAge(0)
{
}

// Cat.cpp
// 부모의 생성자를 명시적으로 호출하지 않으면, 부모의 기본생성자를 호출한다.
Cat::Cat(int age, const char* name)
{
    size_t size = strlen(name) + 1;
    mName = new char[size];
    strcpy(mName, name);
}

// main.cpp
Cat* myCat = new Cat(2, "Mew");
```

<figure><img src="../../.gitbook/assets/스크린샷 2023-11-05 20.32.01.png" alt="" width="563"><figcaption></figcaption></figure>

* 호출 사례.2 \
  \-> 매개변수 없는 생성자가 없는 베이스 클래스&#x20;
  * **다음의 경우 부모 생성자에 기본생성자가 존재하지 않기 때문에, **_**컴파일 에러**_**가 발생한다!**

```cpp
// Animal.cpp
Animal::Animal(int age)
    :mAge(age)
{
}

// Cat.cpp
// 부모의 생성자를 초기화하고 생성자 구현부에서 자식에 추가된 부분만 신경쓴다.
Cat::Cat(int age, const char* name)
{
    size_t size = strlen(name) + 1;
    mName = new char[size];
    strcpy(mName, name);
}

// main.cpp
Cat* myCat = new Cat(2, "Mew");
```

* 소멸자는 어떤 순서로 작동할까?
  * _**자식의 소멸자가 호출되고, 부모의 소멸자가 호출된다!**_\
    (생성자의 순서와 반대이다!)

#### 다형성(Polymorphism)

*   다형성 이전에 멤버함수는 메모리 어디에 위치하고 있을까?

    <figure><img src="../../.gitbook/assets/스크린샷 2023-11-05 20.45.23.png" alt="" width="563"><figcaption></figcaption></figure>
* 멤버 함수도 메모리 어딘가에 위치하고 있다.\
  \-> 모든 것이 메모리 어디엔가 위치해야만 한다.
* 그런데 각 개체마다 멤버 함수의 메모리가 잡혀 있을까?\
  \-> 같은 클래스를 사용해 개체를 만들시 두 개체 함수의 동작은 완전하게 일치한다.&#x20;
* _**때문에, 멤버 함수는 컴파일 시에 딱 한번만 메모리에 "할당" 된다!**_
* 함수 오버라이딩?
  * 부모의 함수를 자식이 새롭게 정의하는 문법으로 다음 코드를 통해서 확인해보자.

```cpp
void Animal::Speak()
{
    std::cout << "Animal Speaking" << std::endl;
}

void Cat::Speak()
{
    std::cout << "Meow" << std::endl;
}

void Dog::Speak()
{
    std::cout << "Woof" << std::endl;
}
```

* 그렇다면 위와 같이 오버라이딩된 함수를 호출할 때 Java 와는 무엇이 다를까?
  * Java : 실제 개체의 함수를 호출한다.&#x20;
  * C++ : 변수의 자료형을 따라 함수를 호출한다.

<figure><img src="../../.gitbook/assets/스크린샷 2023-11-05 20.59.14.png" alt="" width="563"><figcaption></figcaption></figure>

#### 정적 바인딩

* 왜 위코드와 같이 동작이 일어날까?\
  \-> C++ 에서는 정적 바인딩을 사용하기 때문이다!
* 정적 바인딩
  * 변수의 자료형을 따라서 호출하는 형태를 의미한다.&#x20;

```cpp
Animal* yourCat = new Cat(5, "Mocha");
```

<figure><img src="../../.gitbook/assets/스크린샷 2023-11-05 21.03.24.png" alt="" width="563"><figcaption></figcaption></figure>

#### 동적 바인딩&#x20;

* 그렇다면, Java와 같이 실제 사용하는 개체의 함수를 사용하고 싶다면 어떻게 할까?\
  \-> 가상 함수를 만들면 된다.
* **다음과 같이 virtual 키워드를 붙여서 실제 개체의 함수를 사용하겠다고 선언을 하면 된다!**\
  (Java 와 같은 방법 : Java 모든 함수가 기본적으로 가상 함수이다!)\
  \-> Java 프로그래머는 final 키워드를 쓸 수 있다!\
  \-> 이것은 정적 바인딩을 하겠다는 것을 의미하고, \
  **-> 이걸 까먹으면, 비 가상함수보다 언제나 느리다!** \
  **(가상함수는 실제 개체를 따라가 호출해야하기 때문에, 느리다..)**
* _**C++ 에서 virtual 키워드를 생략하면 정말 개판난다!**_
*   _**이러한 방식을 실행중에 어떤 함수를 설정할지 결정한다고 해서 동적 바인딩이라고 부른다.**_\
    \-> 당연히 정적 바인딩보다 느리다!

    <figure><img src="../../.gitbook/assets/스크린샷 2023-11-05 21.14.05.png" alt="" width="563"><figcaption></figcaption></figure>
*   동적 바인딩은 어떻게 실행될까?

    * 가상 테이블이라는 별도의 장치를 메모리에 할당해서 가상 함수를 찾게된다.&#x20;
    *   가상 테이블에는 해당 개체의 가상 함수의 주소를 가리키는 정보들이 들어있다!

        <figure><img src="../../.gitbook/assets/스크린샷 2023-11-05 21.23.17.png" alt="" width="232"><figcaption></figcaption></figure>
    * **그렇다면, 가상 테이블은 클래스마다 있을까? 개체마다 있을까?**\
      _**-> 가상 테이블은 클래스마다 한개씩 존재한다!**_\
      _**-> 개체를 생성할 때, 해당 클래스의 가상 테이블 주소가 함께 저장된다!**_\
      _**(시점이 중요하다!)**_

    <figure><img src="../../.gitbook/assets/스크린샷 2023-11-05 21.27.09.png" alt="" width="375"><figcaption></figcaption></figure>



#### 정적 바인딩과 동적 바인딩의 메모리를 사용하는 방식을 살펴보자!

* 정적 바인딩은 컴파일 타임에 이루어진다.&#x20;
* 동적 바인딩은 런타임에 이루어진다.&#x20;
* _**동적 바인딩이 다형성의 핵심이지만, 런타임에 가상 테이블을 통해 멤버 함수를 호출하기에 느릴 수 밖에 없다!**_

<figure><img src="../../.gitbook/assets/스크린샷 2023-11-05 21.32.39.png" alt=""><figcaption></figcaption></figure>

<figure><img src="../../.gitbook/assets/스크린샷 2023-11-05 21.30.47.png" alt=""><figcaption></figcaption></figure>

#### 가상 소멸자&#x20;

* 다음의 코드를 보고 생각을 해보자\
  \-> 얼핏 보면 문제가 없어보인다.&#x20;

```cpp
// Animal.h
class Animal
{
public:
    ~Animal();
private:
    int mAge;
}

// Cat.h
class Cat : public Animal
{
public:
    ~Cat();
private:
    char* mName;
}

// Cat.cpp
Cat::~Cat()
{
    delete mName;
}

// Main.cpp
Cat* myCat = new Cat(2, "nabi");
delete myCat;
```

* 하지만, 다음의 코드로 변경한다면 어떻게 될까?\
  \-> 기본적으로 C++ 코드는 정적바인딩을 사용하기 때문에, Cat 의 메모리를 해제하지 않고 Animal 의 메모리만 해제하는, 메모리 누수가 발생하게 된다.

```cpp
// Main.cpp
Animal* myCat = new Cat(2, "nabi");
delete myCat;
```

* 때문에, 소멸자에서도 동적 바인딩을 사용할 수 있도록 다음과 같이 virtual 키워드를 사용해야 한다!

```cpp
// Animal.h
class Animal
{
public:
    virtual ~Animal();
private:
    int mAge;
}

// Cat.h
class Cat : public Animal
{
public:
    // 부모에서 virtual 키워드를 사용하면 자식 클래스는 자동적으로 동적 바인딩을 사용하지만,
    // 명시적으로 보여지기 위해서 자식 클래스에도 virtual 키워드를 사용하자. 
    virtual ~Cat();
private:
    char* mName;
}

// Cat.cpp
Cat::~Cat()
{
    delete mName;
}
```

* 이전에 설명했듯 동적 바인딩은 가상테이블을 사용한다고 말했었는데, 아래와 같이 myCat 을 delete 하는 순간 Cat 클래스의 가상테이블에서 소멸자의 주소를 찾아내 소멸자를 호출하게 된다.&#x20;

<figure><img src="../../.gitbook/assets/스크린샷 2023-11-06 22.30.42.png" alt="" width="563"><figcaption></figcaption></figure>

<figure><img src="../../.gitbook/assets/스크린샷 2023-11-06 22.32.53.png" alt=""><figcaption></figcaption></figure>

* _**가상 소멸자는 모든 클래스마다 하는 것을 권고한다.**_ 하지만 다음과 같은 질문이 있을 수 있다.&#x20;
  * 근데, 가상함수가 느린데,, 가상 소멸자가 있는 클래스를 상속받지 않아도 모든 클래스마다 가상 소멸자를 호출하라고?
* _**모든 클래스를 다른사람에 의해 내가 의도한대로 사용하지 않을 수 있다!**_ \
  \-> 다른 개발자가 가상 소멸자를 사용하지 않으려고 한 클래스를 상속받아 다형성을 구현한다면, 메모리 누수가 생겨버릴 수 있다.\
  \-> 이러한 예기치 못한 상황이 있기 때문에, 우리는 안전한 코딩 습관이 중요하다.&#x20;

#### 다중 상속

*

























