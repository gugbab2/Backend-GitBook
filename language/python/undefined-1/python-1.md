# Python 비동기 프로그래밍 - 왜 필요하고 어떻게 동작하는가

## 파이썬은 원래 동기적이다

파이썬은 태생적으로 동기 방식으로 동작하도록 설계된 언어입니다. 코드가 위에서 아래로 한 줄씩 순차적으로 실행됩니다.

```python
import requests

data_a = requests.get("https://api-a.com")   # 2초 대기
data_b = requests.get("https://api-b.com")   # 1초 대기
data_c = requests.get("https://api-c.com")   # 3초 대기

# 총 소요 시간: 6초 (2 + 1 + 3)
```

위 코드에서 `api-a`의 응답을 기다리는 2초 동안 CPU는 아무것도 하지 않고 멈춰 있습니다. 응답이 돌아온 뒤에야 다음 줄로 넘어갑니다. 이것이 동기 방식의 근본적인 비효율입니다.

웹 서비스에서는 DB 쿼리, 외부 API 호출, 파일 읽기 등 I/O 대기 시간이 전체 처리 시간의 대부분을 차지합니다. 이 대기 시간을 그냥 낭비하고 있다면, 동시에 많은 요청을 처리해야 하는 서버 환경에서는 심각한 성능 문제가 됩니다.

### 기존 해결 방법: 멀티프로세스

파이썬 웹 서비스에서는 전통적으로 Gunicorn 같은 WSGI 서버가 **워커 프로세스를 여러 개** 띄워서 동시성을 확보했습니다.

```
Gunicorn (sync 워커, 기본값)
├── 워커 프로세스 1 (스레드 1개) → 요청 처리
├── 워커 프로세스 2 (스레드 1개) → 요청 처리
├── 워커 프로세스 3 (스레드 1개) → 요청 처리
└── 워커 프로세스 4 (스레드 1개) → 요청 처리
```

이 방식은 동작하지만, 프로세스 컨텍스트 스위칭(TLB 플러시 등)의 오버헤드가 크고, 워커 하나가 I/O를 기다리는 동안 해당 워커는 완전히 놀고 있습니다. 그래서 권장 워커 수가 `(2 × CPU 코어 수) + 1`로, 코어 수보다 훨씬 많아야 합니다.

이 문제를 근본적으로 해결하기 위해 파이썬은 Python 3.4부터 `asyncio`를 표준 비동기 라이브러리로 도입했습니다.

***

## 비동기의 핵심 개념 이해하기

비동기 프로그래밍을 이해하려면 세 가지 핵심 개념을 알아야 합니다.

### 1. 코루틴 (Coroutine) — 멈췄다 다시 시작할 수 있는 함수

일반 함수는 호출되면 끝날 때까지 멈출 수 없습니다. 코루틴은 다릅니다. 실행 도중 `await`를 만나면 스스로 실행을 일시 중지하고, 나중에 다시 이어서 실행할 수 있습니다.

```python
async def fetch_data(name, seconds):
    print(f"[{name}] 요청 시작")
    await asyncio.sleep(seconds)    # 여기서 멈추고 제어권을 넘김
    print(f"[{name}] 요청 완료")    # 나중에 여기서 다시 시작
    return f"{name} 결과"
```

`async def`로 정의된 함수가 바로 코루틴입니다.&#x20;

`await`는 `async def` 안에서만 사용할 수 있으며, 이것이 **async 전파(contagion)**&#xB97C; 만듭니다. `await`를 쓰려면 `async def`이어야 하고, 그 함수를 호출하는 쪽도 `await`가 필요하므로 `async def`이어야 합니다.

```
일반 함수:  시작 ──────────────────────→ 끝 (중간에 멈출 수 없음)
코루틴:     시작 ──→ await(멈춤) ──→ 재개 ──→ await(멈춤) ──→ 재개 ──→ 끝
```

코루틴은 멀티스레드와 근본적으로 다릅니다. 멀티스레드는 OS가 강제로 전환하는 **선점형** 방식이지만, 코루틴은 `await`에서 자발적으로 양보하는 **협력적 멀티태스킹** 방식입니다. 싱글 스레드에서 동작하므로 GIL 경합이 발생하지 않습니다.

### 2. 퓨쳐 객체 (Future Object) — 아직 안 끝난 작업의 약속

퓨쳐 객체는 비동기 작업의 결과를 담는 그릇입니다. 작업이 아직 진행 중이면 비어 있고, 완료되면 결과가 채워집니다.

퓨쳐 객체는 세 가지 상태를 가집니다.

```
PENDING   → 작업 진행 중 (아직 결과 없음)
FINISHED  → 작업 완료 (결과 있음)
CANCELLED → 작업 취소됨
```

중요한 것은 `add_done_callback()` 메서드입니다. 이 메서드를 통해 "작업이 끝나면 이 함수를 실행해줘"라고 등록할 수 있습니다. 이 콜백 메커니즘이 이벤트 루프의 핵심 동작 원리에서 중요한 역할을 합니다.

### 3. 태스크 객체 (Task Object) — 코루틴을 실제로 실행하는 단위

태스크는 퓨쳐를 상속받은 객체로, 코루틴을 감싸서 이벤트 루프에서 실행할 수 있게 만듭니다.

```
퓨쳐:    결과를 저장하는 그릇
태스크:   코루틴 + 퓨쳐 = 실행 가능하면서 결과도 저장하는 단위
```

태스크는 생성될 때 코루틴 객체를 `_coro` 필드에 저장하고, 즉시 이벤트 루프에 자신의 `__step()` 메서드 실행을 예약합니다. `__step()` 메서드가 호출되면 코루틴의 `send()` 메서드를 통해 코루틴을 실행합니다.

```
태스크 생성 → __step() 예약 → __step() 호출 → 코루틴.send() → 코루틴 실행
```

***

## 이벤트 루프의 동작 원리

### 이벤트 루프란

이벤트 루프는 이름 그대로 루프를 돌면서 태스크를 실행시키는 장치입니다. 코루틴이 동작하려면 반드시 이벤트 루프가 필요합니다. `await`에서 제어권을 넘겨받고, 완료된 태스크를 다시 깨워주는 것이 이벤트 루프의 역할이기 때문입니다.

### 이벤트 루프가 존재하는 곳

코루틴은 이벤트 루프가 있는 환경에서만 동작합니다. 웹 서버 프로토콜 기준으로 보면, 이벤트 루프는 ASGI에만 존재합니다.

```python
# CGI — 그냥 표준 입출력. 이벤트 루프 없음.
print("Content-Type: text/html")
print()
print("<h1>Hello</h1>")

# WSGI — 동기 함수. 이벤트 루프 없음.
def application(environ, start_response):
    start_response('200 OK', [])
    return [b'Hello']

# ASGI — 비동기 함수. 이벤트 루프 위에서 실행됨.
async def application(scope, receive, send):
    await send({'type': 'http.response.start', 'status': 200})
    await send({'type': 'http.response.body', 'body': b'Hello'})
```

```
CGI:   요청마다 새 프로세스 생성 → 처리 → 프로세스 종료   → 이벤트 루프 없음
WSGI:  요청 들어옴 → 동기 함수 호출 → 응답 반환          → 이벤트 루프 없음
ASGI:  이벤트 루프가 상시 돌고 있음 → 요청이 코루틴으로 처리됨 → 이벤트 루프 있음
```

ASGI의 핸들러가 `async def`이고 `await`를 사용하는 것 자체가, 이 함수가 이벤트 루프 위에서 실행된다는 것을 의미합니다. CGI와 WSGI는 동기 함수이므로 이벤트 루프가 필요하지도 않고 존재하지도 않습니다.

다만 코루틴이 ASGI 전용은 아닙니다. 이벤트 루프는 웹 서버 밖에서도 존재할 수 있습니다.

```
이벤트 루프가 있는 환경:
├── ASGI 웹 서버 (Uvicorn)        → 웹 요청 처리
├── asyncio.run()                  → 일반 파이썬 스크립트
├── asyncio.get_event_loop()       → 소켓 서버, 크롤러 등
└── jupyter notebook               → 자체 이벤트 루프 내장

이벤트 루프가 없는 환경:
├── CGI 핸들러
└── WSGI 핸들러 (Gunicorn sync)
```

WSGI에서 코루틴이 안 되는 이유는 WSGI라서가 아니라, WSGI 핸들러 안에 이벤트 루프가 돌고 있지 않기 때문입니다. 제어권을 넘겨줄 이벤트 루프 자체가 없으니 `await`가 의미를 가질 수 없는 것입니다.

### 전체 흐름 예시 코드

```python
import asyncio

async def fetch_data(name, seconds):
    print(f"[{name}] 요청 시작")
    await asyncio.sleep(seconds)
    print(f"[{name}] 요청 완료")
    return f"{name} 결과"

async def main():
    results = await asyncio.gather(
        fetch_data("A", 2),
        fetch_data("B", 1),
        fetch_data("C", 3),
    )
    print(f"모든 결과: {results}")

asyncio.run(main())
```

### 이벤트 루프 동작 8단계

#### **1단계: 이벤트 루프 생성과 첫 진입**

`asyncio.run(main())`이 호출되면 새로운 이벤트 루프가 생성됩니다. 이것이 비동기 프로그래밍의 시작점입니다. `asyncio.run()`은 프로그램에서 이상적으로 한 번만 호출되어야 합니다.

```
asyncio.run(main())
  → 새 이벤트 루프 생성
  → main 코루틴을 태스크로 감싸서 이벤트 루프에 등록
  → 이벤트 루프 시작
```

#### **2단계: 태스크 실행과 코루틴 체인 형성**

main 태스크의 `__step()`이 호출되면 main 코루틴이 실행됩니다. `asyncio.gather()`는 세 개의 코루틴을 각각 태스크로 만들어 이벤트 루프에 예약합니다.

```
main 태스크 실행
  → gather()가 태스크 A, B, C 생성 및 예약
  → 태스크 A 실행: "[A] 요청 시작" 출력 → await sleep(2) → 멈춤
  → 태스크 B 실행: "[B] 요청 시작" 출력 → await sleep(1) → 멈춤
  → 태스크 C 실행: "[C] 요청 시작" 출력 → await sleep(3) → 멈춤
```

#### **3단계: 코루틴 체인의 종착점 — await에서 멈춤**

각 태스크가 `await asyncio.sleep()`을 만나면, 실행을 중지하고 이벤트 루프에 제어권을 넘깁니다.&#x20;

이때 퓨쳐 객체가 생성됩니다.

실제 I/O 작업의 경우에는 `select()` 시스템 콜을 통해 소켓을 등록하고, 그 소켓에 바인딩된 퓨쳐 객체를 생성하여 await합니다.

#### **4단계: 퓨쳐 객체에 콜백 등록**

태스크는 생성된 퓨쳐 객체를 `_fut_waiter` 필드에 저장하고, `add_done_callback()`으로 "이 퓨쳐가 완료되면 나를 다시 깨워줘"라는 콜백을 등록합니다.

```
태스크 A → 퓨쳐 객체 A 생성 → 콜백 등록: "완료되면 태스크 A의 __step() 호출"
태스크 B → 퓨쳐 객체 B 생성 → 콜백 등록: "완료되면 태스크 B의 __step() 호출"
태스크 C → 퓨쳐 객체 C 생성 → 콜백 등록: "완료되면 태스크 C의 __step() 호출"
```

#### **5단계: 이벤트 루프의 Polling — 완료된 작업 찾기**

예약된 태스크가 없으면 이벤트 루프는 `select()` 메서드로 완료 가능한 I/O 소켓을 확인합니다. 타이머(sleep)의 경우 시간이 만료되었는지 확인합니다.

```
시간 흐름:

0초: 세 태스크 모두 대기 중 → 이벤트 루프 polling
1초: 태스크 B의 sleep(1) 만료 → 퓨쳐 B 완료 → 콜백으로 __step() 예약
2초: 태스크 A의 sleep(2) 만료 → 퓨쳐 A 완료 → 콜백으로 __step() 예약
3초: 태스크 C의 sleep(3) 만료 → 퓨쳐 C 완료 → 콜백으로 __step() 예약
```

#### **6단계: 태스크 실행 재개**

콜백이 실행되면 태스크의 `__step()`이 다시 호출되고, 퓨쳐 객체와의 바인딩을 해제한 뒤, 코루틴의 `send()` 메서드를 호출하여 **중단된 지점부터 실행을 재개**합니다.

```
1초: 태스크 B 재개 → "[B] 요청 완료" 출력 → "B 결과" 반환
2초: 태스크 A 재개 → "[A] 요청 완료" 출력 → "A 결과" 반환
3초: 태스크 C 재개 → "[C] 요청 완료" 출력 → "C 결과" 반환
```

#### **7단계: 최초 코루틴의 return — 태스크 종료**

모든 코루틴 체인이 끝나면 최초 코루틴(main)이 return 하는 시점에 도달합니다. 이때 `__step()` 메서드에서 `StopIteration` 예외가 발생하고, 그 값을 결과로 업데이트하면서 태스크가 종료됩니다.

#### **8단계: 이벤트 루프 종료**

모든 태스크가 완료되면 `loop.close()`로 이벤트 루프를 닫고 남은 데이터를 정리합니다. 완료되지 않은 태스크가 있다면 "Task was destroyed but it is pending!" 메시지가 출력됩니다.

### 전체 흐름 요약

```
asyncio.run(main())
  ↓
이벤트 루프 생성 → main 태스크 생성·실행
  ↓
gather()로 태스크 A, B, C 생성·예약
  ↓
각 태스크 실행 → await 만남 → 퓨쳐 생성 → 콜백 등록 → 이벤트 루프에 제어권 반환
  ↓
이벤트 루프 polling (완료된 작업 확인)
  ↓
퓨쳐 완료 → 콜백 실행 → 태스크 재개 → 코루틴 이어서 실행
  ↓
모든 태스크 완료 → main 코루틴 return → 이벤트 루프 종료
```

***

## 실전에서의 적용과 한계

### 단일 태스크 vs 동시 실행

`asyncio.run()`은 기본적으로 태스크 1개만 생성합니다.&#x20;

여러 코루틴을 동시에 실행하려면 `asyncio.create_task()`로 태스크를 명시적으로 만들거나, `asyncio.gather()`로 한 번에 등록해야 합니다.

```python
# 태스크 1개 — 동시 실행 아님
async def main():
    a = await fetch("A")    # A 끝날 때까지 대기
    b = await fetch("B")    # 그 다음 B 실행

# 태스크 여러 개 — 동시 실행
async def main():
    results = await asyncio.gather(
        fetch("A"),          # A, B 동시에 시작
        fetch("B"),
    )
```

### 동기 함수를 비동기처럼 쓰고 싶을 때

파이썬의 많은 라이브러리(requests 등)는 동기 방식으로 동작합니다. 이런 동기 함수를 비동기 흐름에 넣으면 이벤트 루프를 블로킹합니다.

이때 `loop.run_in_executor()`를 사용하면 동기 함수를 별도의 스레드풀에서 실행하여 이벤트 루프가 멈추지 않게 할 수 있습니다. 완전한 코루틴이 되는 것은 아니지만, 비동기처럼 동작하게 할 수 있습니다.

```python
import asyncio
import requests

async def fetch_async(url):
    loop = asyncio.get_event_loop()
    # requests.get을 별도 스레드에서 실행
    response = await loop.run_in_executor(None, requests.get, url)
    return response.text
```

하지만 근본적인 해결을 위해서는 처음부터 비동기로 설계된 라이브러리(aiohttp, asyncpg 등)를 사용하는 것이 바람직합니다.

### 비동기의 한계 — CPU 바운드 작업

비동기 프로그래밍은 I/O 대기 시간을 겹쳐서 처리하는 것이지, CPU 연산을 병렬로 수행하는 것이 아닙니다. \
싱글 스레드에서 동작하므로 CPU 집약적 작업이 이벤트 루프를 점유하면 모든 코루틴이 멈춥니다.

```python
# 이건 비동기로 해도 빨라지지 않음
async def heavy_calc():
    result = sum(range(100_000_000))  # await 없이 CPU만 사용
    return result

# 이 작업이 5초 걸리면 그 동안 다른 모든 요청이 멈춤
```

### 프로덕션 구조 — Gunicorn + Uvicorn

비동기의 한계(싱글 프로세스, 멀티코어 활용 불가)를 보완하기 위해 프로덕션에서는 Gunicorn과 Uvicorn을 조합합니다.

```
Gunicorn (프로세스 관리자)
├── Uvicorn 워커 1 (이벤트 루프) → 코어 1에서 비동기 요청 처리
├── Uvicorn 워커 2 (이벤트 루프) → 코어 2에서 비동기 요청 처리
├── Uvicorn 워커 3 (이벤트 루프) → 코어 3에서 비동기 요청 처리
└── Uvicorn 워커 4 (이벤트 루프) → 코어 4에서 비동기 요청 처리
```

Gunicorn이 맡는 역할은 프로세스 관리입니다. 워커 생성, 모니터링, 장애 시 재시작, 무중단 배포 등 프로덕션에 필요한 안정성을 제공합니다. Uvicorn 단독으로는 이런 프로세스 관리 기능이 부족합니다.

Uvicorn이 맡는 역할은 각 워커 안에서의 비동기 요청 처리입니다. 이벤트 루프로 I/O 대기 시간을 효율적으로 활용합니다. Uvicorn은 동기/비동기 엔드포인트를 모두 처리할 수 있는데, `async def`은 이벤트 루프에서 직접 실행하고 일반 `def`은 자동으로 스레드풀에 위임합니다.

비동기 워커는 I/O 대기 시간에도 다른 요청을 처리할 수 있으므로, 동기 워커와 달리 워커 수를 코어 수에 맞추거나 그보다 적게 설정하는 것이 일반적입니다.

```
동기 워커 (WSGI):   워커 하나가 I/O 대기 중이면 CPU 낭비
                    → 워커를 많이 띄워야 함 (2 × 코어 수 + 1)

비동기 워커 (ASGI):  워커 하나가 I/O 대기 중에도 다른 요청 처리
                    → 코어 수와 동일하거나 적게도 충분
```

### GIL과 비동기의 관계

파이썬의 GIL은 멀티스레드에서 여러 스레드가 동시에 파이썬 코드를 실행할 수 없게 만드는 제약입니다. 비동기 이벤트 루프는 이 문제를 "해결"한 것이 아니라 "회피"한 것입니다. 싱글 스레드에서 동작하므로 GIL 경합 자체가 발생하지 않습니다.

```
멀티스레드:       GIL 경합 발생    +  멀티코어 활용 불가 (GIL 때문에)
이벤트 루프:      GIL 경합 없음    +  멀티코어 활용 불가 (싱글 프로세스)
멀티프로세스:     GIL 경합 없음    +  멀티코어 활용 가능
Gunicorn+Uvicorn: GIL 경합 없음   +  멀티코어 활용 가능 + I/O 효율적
```

***

## 핵심 정리

파이썬 비동기 프로그래밍의 본질은 **싱글 스레드에서 I/O 대기 시간을 낭비하지 않는 것**입니다. 코루틴이 `await`에서 자발적으로 멈추고, 이벤트 루프가 그 틈에 다른 코루틴을 실행하는 협력적 멀티태스킹 구조입니다.

이 구조가 가능한 이유는 코루틴, 퓨쳐, 태스크라는 세 가지 객체가 이벤트 루프 위에서 유기적으로 동작하기 때문이며, 코루틴이 동작하려면 반드시 이벤트 루프가 필요합니다. 웹 서버 프로토콜 중에서는 ASGI만 이벤트 루프를 내장하고 있으므로, 웹 서비스에서 코루틴을 활용하려면 ASGI 서버(Uvicorn 등)를 사용해야 합니다. 다만 코루틴 자체는 ASGI 전용이 아니며, `asyncio.run()`을 통해 일반 파이썬 스크립트, 크롤러, 소켓 서버 등 이벤트 루프가 있는 어떤 환경에서든 사용할 수 있습니다.

이 모든 것은 "대부분의 서버 작업은 CPU가 아니라 I/O를 기다리는 시간이 지배적이다"라는 현실에 기반합니다.
