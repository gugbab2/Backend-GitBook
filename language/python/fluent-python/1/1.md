# 1장 파이썬 데이터 모델

파이썬 데이터 모델

* 파이썬이라는 언어가 객체를 다루는 표준 규칙(API) 를 의미한다.
* 파이썬을 설명하는 일종의 프레임워크

파이썬 인터프리터는 클래스에 정의된 특별 메서드를 호출해서 기본적인 연산을 수행하는데, 종종 특별 구문에 의해 호출된다.&#x20;

* 특별 메서드의 이름은 언제나 이중 언더바로 시작하고 끝난다.&#x20;

때문에, 정의한 객체(클래스) 를 파이썬 핵심 기능과 결합하려면 해당하는 특별 클래스를 구현해야 한다.&#x20;

* 컬렉션
* 속성 접근&#x20;
* 반복&#x20;
* 연산자 오버로딩&#x20;
* 등등 ..

## 1.2 파이썬 다운 카드 한 벌&#x20;

### 파이썬 데이터 모델에 정의된 특별 메서드를 사용할 때의 장점

1. 클래스 사용자는 표준 연산을 수행하는 메서드 이름을 기억할 필요가 없다.
   1. 만약 특별 메서드가 없다면, 개발자마다 길이를 구하는 메서드 이름을 제각각으로 만들 것이다.&#x20;
      1. A 라는 사람은 `obj.get_length()`&#x20;
      2. B 라는 사람은 `obj.size()`&#x20;
      3. C 라는 사람은 `obj.count()`&#x20;
   2. 이렇게 되면 사용자는 매번 매뉴얼을 찾아보며 "이 객체는 길이를 어떻게 재지?" 라고 고민해야 한다.&#x20;
   3. **하지만 파이썬에서는 `__len__` 이라는 특별 메서드만 클래스 안에 만들어두면, 사용자는 고민 없이 `len(내_객체)` 를 호출하면 된다.**&#x20;
2. `random.choice()` 함수처럼 ,파이썬 표준 라이브러리의 풍부한 기능을 따로 구현할 필요 없이 바로 사용 가능하다.
   1. 파이썬에서는 이미 잘 만들어진 도구(함수) 들이 많다. 내가 만든 클래스에 특별 메서드 몇 개만 넣어두면, 이 강력한 도구들을 내가 만든 클래스에서도 바로 적용할 수 있다.&#x20;
   2. 예를 들어 `random.choice(목록)` 는 목록에서 무작위로 하나를 뽑아주는 함수이다. 원래는 리스트나 튜플에서만 작동하지만, 내가 만든 리스트에 `__getitem__` 이라는 특별 메서드만 정의하면 이 함수를 바로 사용할 수 있다.&#x20;
   3. 만약 특별 메서드를 쓰지 않았다면, `random_pick()` 같은 함수를 클래스 안에 직접 새로 구현해야 했을 것이다. 하지만 파이썬의 규칙을 따름으로써 이미 만들어진 `random.choice` 를 '공짜'로 쓰게 된 것이다.&#x20;

## 1.3 특별 메서드의 용도&#x20;

먼저 **특별 메서드는 우리가 아니라 파이썬 인터프리터가 호출하는 메서드라는 점에 유의해야 한다.**&#x20;

* `my_object` 가 사용자 정의 클래스의 인스턴스이면, 파이썬은 사용자가 구현한 `__len__()` 메서드를 호출한다.&#x20;

그러나 `list`, `str`, `bytearray` 등의 내장형이나 넘파이(`numPy`) 배열 같은 확장형을 다룰 때 파이썬 인터프리터는 지름길을 선택한다.&#x20;

* 예를 들어, C 로 작성한 파이썬 가변 크기 컬렉션은 `PyVarObject` 라는 `struct` 구조체를 가지는데, 이 구조체의 `ob_size` 필드에 컬렉션 항목 수가 들어 있다.&#x20;
* 따라서 `my_object` 가 내장 객체라면 `len(my_object)` 는 `ob_size` 필드를 읽어 반환하므로 메서드를 호출하는 방식보다 훨씬 빠르다.&#x20;

일반적으로 사용자 코드에서는 특별 메서드를 직접 호출하지 않는다. 메타프로그래밍을 하는 경우가 아니라면 사용자 코드는 대부분 특별 메서드를 구현하기는 하지만, 명시적으로 호출하지 않는다.&#x20;

* 다만 클래스를 정의할 때 사용자가 구현한 `__init__()` 코드 안에서 슈퍼클래스의 `__init__()` 초기화 메서드를 직접 호출하는 것은 자주 볼 수 있다.&#x20;

특별 메서드를 직접 호출하고 싶다면 `len()`, `iter()`, `str()` 등 연관된 내장 함수를 호출하는 편이 좋다.&#x20;

* 일반적으로 내장 함수는 연관된 특별 메서드를 호출하지만, 별도의 추가 기능을 제공할 때도 있다.&#x20;
* 특히 내장형에서는 메서드 호출보다 더 빠른 방법을 사용하기도 한다.&#x20;

## 1.5 len() 을 메서드로 만들지 않은 이유

필자가 2013년 핵심 레발자인 레이먼드 헤팅거에게 이 질문을 던졌을 때 돌아온 답의 핵심은 '실용성이 순수성보다 먼저다' 라는 설명이었다.&#x20;

* **"모든 것을 메서드로 만드는 객체지향의 순수성" 을 지키는 것보다, "자주 쓰는 기능은 무조건 가장 빠르게 실행되게 만든다" 라는 실용적인 선택을 했다는 뜻이다.**&#x20;

1.3 '특별 메서드의 용도'에서 `x` 가 내장형 인스턴스일 때 `len(x)` 가 어떻게 빨리 실행되는지 설명했다. CPython 의 내장 객체에 대해서는 메서드를 호출하지 않고, 길이는 단지 C 구조체의 필드를 읽어올 뿐이다. `str`, `list`, `memoryview` 등의 다양한 기본 컬렉션에서 항목 수를 가져오는 연산은 자주 발생하므로 그만큼 효율적으로 실행되어야 한다.&#x20;

다시 말해 `len()` 은 `abs()` 와 마찬가지로 파이썬 데이터 모델의 특별 대우를 받아 메서드라고 부르지 않는다(함수라고 부른다). 그러나 `__len__()` 특별 메서드 덕분에 사용자가 정의한 객체에서도 `len()` 을 사용할 수 있는 것이다.

* `len()` 을 쓰면 인터프리터가 "어? 이건 길이를 나타내는 메타데이터가 없네? 대신 안에 `__len__()` 이라는 특별 메서드를 찾아야 겠다." 라고 판단하고 행동한다.&#x20;
* 내장 객체의 효율성과 언어의 일관성 측면으로 봤을 때 적절한 절충안이라고 할 수 있다.

### 일반 메서드 호출( `x.len()`) & 함수 호출(`len(x)`) 의 속도 차이&#x20;

#### 1. 일반 메서드 호출(`x.len()`) 이 거치는 과정&#x20;

1. 이름 찾기: 객체 `x` 안에 `len`이라는 이름이 있는지 검색합니다.
2. 클래스 확인: 만약 객체에 없으면 부모 클래스로 가서 또 찾습니다.
3. 호출 준비: 함수를 실행하기 위한 별도의 메모리 공간(스택 프레임)을 만듭니다.
4. 인자 전달: `self` 같은 인자들을 넘겨주는 작업을 수행합니다.

**위 과정 하나하나가 컴퓨터의 연산 자원을 소모한다.**&#x20;

#### 2. `len(x)` 가 내장 객체를 처리하는 방식&#x20;

1. `len(x)`를 호출하면 파이썬은 위의 복잡한 1\~4번 과정을 싹 생략합니다.
2. 그저 메모리 주소의 특정 칸에 있는 숫자를 바로 읽어옵니다. (C언어 수준의 직접 접근)

**만약, 내장 객체(리스트 등) 이 아닌 내가 만든 객체일 경우 `len()` 함수가 내부적으로 `__len__()` 메서드를 호출하므로, 일반 메서드 호출과 똑같은 과정을 거친다. (즉, 속도 이득이 없다)**

* **이 내용이 위에서 언급한 절충안의 핵심이다!**

## 1.6 요약&#x20;

특별 메서드를 사용하면 사용자 정의 객체도 내장 객체처럼 작동하므로 파이썬다운 표현력 있는 코딩 스타일을 사용할 수 있다.&#x20;

파이썬 객체는 기본적으로 자신을 문자열 형태로 표현할 수 있어야 하는데, 디버깅 및 로그를 남기기 위한 형태와 사용자에게 보여주기 위한 형태가 있다. 따라서 데이터 모델에 `__repr__()`, `__str__()` 특별 메서드 두 개가 정의된다.&#x20;
