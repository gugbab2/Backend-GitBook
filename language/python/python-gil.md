# Python은 왜 한 번에 하나만 실행할까? - GIL 이해하기

### 들어가며: CPython이란?

우리가 "Python"이라고 부르는 것은 사실 **프로그래밍 언어(문법)**&#xC640; 그 문법을 실행하는 **인터프리터(실행 엔진)** 두 가지를 함께 가리킨다.

Python 코드를 실행하는 인터프리터는 여러 종류가 있는데, 그중 가장 널리 쓰이는 것이 **CPython**이다. C 언어로 작성되어 있어서 CPython이라고 부르며, `python.org`에서 다운로드하는 Python이 바로 이것이다. 별도 설정 없이 Python을 사용하고 있다면 CPython을 쓰고 있다고 보면 된다.

이 글에서 다루는 GIL은 **CPython에만 존재하는 구조**이다. 다른 인터프리터(Jython, PyPy 등)에는 GIL이 없거나 다르게 구현되어 있지만, 실무에서 대부분 CPython을 사용하므로 사실상 "Python의 특성"처럼 다뤄진다.

***

### 1. GIL이란 무엇인가

**전역 인터프리터 잠금(Global Interpreter Lock, GIL)**&#xC740; CPython 인터프리터가 한 번에 하나의 스레드만 Python 바이트코드를 실행할 수 있도록 제어하는 잠금 장치(Mutex)이다.

쉽게 말해, 아무리 스레드를 여러 개 만들어도 **Python 코드를 동시에 실행하는 스레드는 항상 1개뿐**이다.

```
스레드1: [실행] → 잠깐 멈춤 → [실행] → ...
스레드2: 대기... → [실행] → 대기... → ...
스레드3: 대기... → 대기... → [실행] → ...
스레드4: 대기... → 대기... → 대기... → ...

→ 4개를 만들어도 동시에 Python 코드를 실행하는 건 항상 1개
```

***

### 2. GIL은 왜 만들어졌는가

Python은 객체의 수명을 관리하기 위해 **참조 횟수(Reference Counting)** 방식을 사용한다. 변수가 어떤 객체를 가리키면 참조 횟수가 1 증가하고, 더 이상 가리키지 않으면 1 감소한다. 참조 횟수가 0이 되면 메모리에서 해제된다.

```python
a = [1, 2, 3]   # 리스트 객체의 참조 횟수: 1
b = a            # 참조 횟수: 2
del a            # 참조 횟수: 1
del b            # 참조 횟수: 0 → 메모리에서 해제
```

문제는, 여러 스레드가 **동시에** 같은 객체의 참조 횟수를 변경하면 경합 조건(Race Condition)이 발생할 수 있다는 것이다. 참조 횟수가 꼬이면 아직 사용 중인 객체가 해제되거나, 반대로 해제되어야 할 객체가 메모리에 남아 누수가 생긴다.

이를 방지하려면 객체마다 개별 잠금을 걸어야 하는데, 이는 구현이 복잡하고 교착 상태(Deadlock) 위험도 커진다. GIL은 이 문제를 **인터프리터 전체에 잠금 하나**로 해결한 실용적인 선택이었다. 스레드 개념이 지금처럼 중요하지 않았던 초기에는 단일 스레드 성능을 높이고 C 확장 라이브러리를 쉽게 통합하기 위한 합리적인 결정이었다.

***

### 3. GIL의 실제 영향: 모든 상황에서 문제인 것은 아니다

GIL의 영향을 정확히 이해하려면, **작업의 성격을 구분**해야 한다. 이 구분을 모르면 "Python 멀티스레드는 무조건 쓸모없다"는 흔한 오해에 빠지게 된다.

#### CPU 바운드 작업 — GIL의 영향을 크게 받는다

수학 연산, 이미지 처리, 데이터 변환 등 **CPU를 계속 사용하는 작업**이다. 이 경우 스레드를 여러 개 만들어도 한 번에 하나만 실행되므로 병렬 처리가 되지 않는다. 오히려 잠금 획득/해제 오버헤드와 컨텍스트 스위칭 비용으로 **단일 스레드보다 느려질 수 있다.**

```python
# CPU 바운드 — 스레드를 늘려도 빨라지지 않는다
def heavy_calculation():
    return sum(i * i for i in range(10_000_000))
```

#### I/O 바운드 작업 — GIL의 영향이 거의 없다

DB 조회, 외부 API 호출, 파일 읽기/쓰기 등 **대기 시간이 대부분인 작업**이다. Python은 I/O 작업을 시작하면 **GIL을 해제**하고, 그 사이 다른 스레드가 실행될 수 있다. 웹 애플리케이션의 대부분은 I/O 바운드이므로, 이런 경우 스레드 기반 처리도 충분히 효과적이다.

```python
# I/O 바운드 — 네트워크 대기 중 GIL이 해제되므로 스레드가 효과적
import requests

def call_api():
    requests.get("https://api.example.com/data")  # 대기 중 GIL 해제
```

#### 정리

| 작업 유형   | GIL 영향 | 멀티스레드 효과 | 적합한 해결 방법        |
| ------- | ------ | -------- | ---------------- |
| CPU 바운드 | 큼      | 거의 없음    | 멀티프로세싱, C 확장     |
| I/O 바운드 | 거의 없음  | 효과적      | 스레드, async/await |

***

### 4. GIL의 한계

I/O 바운드에서는 문제가 적지만, CPU 집중 작업에서는 뚜렷한 한계가 드러난다.

**멀티 코어 활용 제한**: CPU 바운드 멀티스레드 프로그램은 멀티 코어 시스템에서도 실질적으로 단일 코어만 사용하게 된다.

**과학 계산 및 AI 분야의 병목**: 현대의 AI/ML 워크로드는 수많은 코어를 활용한 병렬 처리가 필수적이지만, GIL은 이를 어렵게 만든다. 이 때문에 핵심 로직을 C/C++로 작성하거나 복잡한 멀티프로세싱을 사용하게 되는 원인이 된다.

**멀티프로세싱의 비용**: GIL을 우회하기 위해 프로세스를 여러 개 띄우는 방식은 프로세스 간 통신(IPC) 오버헤드가 크고, 프로세스마다 독립된 메모리 공간을 가지므로 메모리 사용량이 크게 증가한다.

```
스레드 4개: 메모리 공유 → 예: 100MB
프로세스 4개: 메모리 각각 독립 → 예: 400MB
```

***

### 5. 웹 서버와 GIL의 관계

Gunicorn, uWSGI 같은 WSGI 서버가 **워커를 프로세스 단위로 띄우는 이유**가 바로 GIL 때문이다. 스레드로는 진짜 병렬 실행이 안 되니, 각각 독립된 GIL을 가지는 프로세스를 여러 개 만들어서 멀티 코어를 활용하는 것이다.

```
# Gunicorn 워커 4개 = 독립된 프로세스 4개 = 독립된 GIL 4개
워커1 (프로세스, GIL 1): [요청 처리]  ← 코어 1
워커2 (프로세스, GIL 2): [요청 처리]  ← 코어 2
워커3 (프로세스, GIL 3): [요청 처리]  ← 코어 3
워커4 (프로세스, GIL 4): [요청 처리]  ← 코어 4
```

반면 Uvicorn 같은 ASGI 서버는 async/await 기반 비동기 방식으로 동작한다. I/O 대기 중에 GIL이 해제되는 특성을 활용하여, 단일 프로세스에서도 많은 동시 연결을 효율적으로 처리할 수 있다. 다만 CPU 집약적 작업이 이벤트 루프를 블로킹하면 성능이 저하되므로, 이 경우에는 멀티 워커 구성이 필요해진다.

***

### 6. 최신 기술적 변화: GIL 없는 Python을 향해

Python 커뮤니티는 GIL의 제약을 근본적으로 해결하기 위한 변화를 진행 중이다.

#### 인터프리터별 GIL (Per-Interpreter GIL, PEP 684)

Python 3.12에 도입되었다. 하나의 프로세스 내에서 여러 Python 인터프리터를 실행하고 각각 독립된 GIL을 할당하는 방식이다. 멀티프로세싱보다 가볍게 병렬 실행이 가능해졌으나, 인터프리터 간 데이터 공유에는 제약이 있다.

#### 프리 스레딩 (Free-threading, PEP 703)

Python 3.13부터 실험적으로 도입된 기능으로, 빌드 시 GIL을 완전히 비활성화할 수 있는 옵션(`--disable-gil`)을 제공한다. GIL 없이도 스레드 안전성을 유지하기 위해 다음과 같은 기술이 적용되었다.

* **편향 참조 횟수(Biased Reference Counting)**: 객체를 소유한 스레드와 비소유 스레드의 참조 횟수 계산 방식을 분리하여, 단일 스레드에서의 오버헤드를 최소화하는 방식이다.
* **mimalloc 적용**: 기존 메모리 할당자를 대체하여 스레드 안전하고 효율적인 메모리 관리를 지원한다.
* **객체별 잠금**: GIL이라는 하나의 거대한 잠금 대신, 개별 객체 단위의 미세한 잠금으로 전환하여 병렬성을 높인다.

이러한 변화는 Python이 멀티 코어 하드웨어를 효율적으로 활용할 수 있게 하는 전환점이 되고 있으나, 현재는 실험적 단계로 단일 스레드 성능이 약간 저하될 수 있어 점진적으로 개선되고 있다.

***

### 마치며

GIL은 Python 초기에 메모리 안전성과 구현 단순함을 위해 도입된 설계 결정이었다. 이로 인해 CPU 바운드 작업에서 멀티스레드 병렬 처리가 제한되지만, 웹 개발에서 흔한 I/O 바운드 작업에서는 큰 문제가 되지 않는다. 실무에서는 Gunicorn처럼 프로세스를 여러 개 띄우거나, Uvicorn처럼 비동기 방식을 활용하여 GIL의 제약을 우회하고 있다. 그리고 Python 3.13의 프리 스레딩을 시작으로, GIL 없는 Python을 향한 변화가 본격적으로 진행되고 있다.
