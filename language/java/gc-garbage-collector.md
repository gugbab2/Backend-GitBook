# GC(Garbage Collector)

##

## 5. GC 실행 방식

* JDK7 기준으로 5가지 방식이 있다.&#x20;
  * Serial GC
  * Parallel GC
  * CMS GC(Concurrent Mark & Sweep GC)
  * G1GC(Garbage First GC)&#x20;

### Serial GC

* Old 영역의 GC 는 mark-sweep-compact 알고리즘을 사용한다.
* 이 알고리즘의 첫 단계는 Old 영역에 **살아있는 객체(Mark)를 식별하고,**
* 힙(Heap) 영역의 앞 부분부터 확인하여 **살아있는 객체(Sweep)만 남긴다.**
* 마지막 단계에서는 **각 객체들이 연속되게 쌓이도록 힙의 가장 앞 부분부터 채워서 객체가 존재하는 부분과 객체가 없는 부분으로 나눈다(Compaction).**
* **Serial GC 는 적은 메모리와 CPU 코어 개수가 하나만 있을 때 사용하기 위해서 만든 방식이다.** \
  **-> 운영서버에서 절대로 사용하면 안된다.**&#x20;

### Paralled GC

* Serial GC 와 기본적인 알고리즘은 같지만, Serial GC 는 GC 스레드가 하나인 것에 비해서, \
  Paralled GC 는 GC 를 처리하는 스레드가 여러개이다.
* **때문에, Serial GC 보다 빠르게 객체를 처리할 수 있고, Parallel GC 메모리가 충분하고 CPU 코어 개수가 충분할 때 적합한 방식이다.**

<figure><img src="../../.gitbook/assets/image (13).png" alt=""><figcaption></figcaption></figure>

### CMS GC

<figure><img src="../../.gitbook/assets/스크린샷 2023-06-07 21.44.34.png" alt="" width="375"><figcaption></figcaption></figure>

* CMS GC 는 다음의 과정을 거친다.&#x20;
  * **초기 Initial Mark 단계에서 클래스 로더에서 가장 가까운 객체 중 살아있는 객체만 찾는 것(Mark)으로 끝낸다.** \
    **-> 멈추는 시간(stop the world) 이 상당히 짧다.**&#x20;
  * **그리고 Concurrent Mark 단계에서는 방금 살아있다고 확인한 객체에서 참조하고 있는 객체들을 따라가면서 확인한다.** \
    **-> 이 단계의 특징은 다른 스레드가 실행 중인 상태에서 동시에 진행된다는 것이다.**&#x20;
  * **그 다음 Remark 단계에서 Concurrent Mark 단계에서 새로추가되거나, 참조가 끊긴 객체를 확인한다.**&#x20;
  * **마지막으로 Concurrent Sweep 단계에서 쓰레기를 정리하는 작업을 수행한다.**&#x20;
* 이러한 방식으로 진행되는 GC 방식이기 때문에, stop-the-world 시간이 매우 짧다. 모든 애플리케이션 응답 속도가 중요할 때, CMS  GC 를 사용하며, Low Latency GC 라고 부른다.&#x20;
* 하지만 응답 속도가 빠르지만 다음과 같은 단점이 존재한다.&#x20;
  * **다른 GC 방식보다 메모리와 CPU 를 더 많이 사용한다.**\
    **-> 병렬 처리를 위해 추가적인 CPU 자원을 사용한다.**&#x20;
  * **메모리 사용량 증가** \
    **-> 메모리 단편화를 관리하기 위해서 일부 메모리 공간을 유지해야 한다.**&#x20;
  * **Compaction 단계가 기본적으로 제공되지 않는다.**&#x20;
* 다음과 같은 단점 때문에, 신중히 검토한 후 사용해야 한다. \
  \-> 조각난 메모리가 많아 Compaction 작업을 실행하면 다른 GC 방식의 stop-the-world 시간보다 더 많이 걸린다. \
  \-> 때문에, Compaction 작업이 얼마나 자주, 오랫동안 수행되는지 확인해야 한다.&#x20;

## G1GC

<figure><img src="../../.gitbook/assets/스크린샷 2023-06-07 22.05.51.png" alt="" width="375"><figcaption></figcaption></figure>

* G1GC 는 기존의 Young / Old 영역에 대한 개념이 필요없다.&#x20;
* G1GC 는 다음과 같은 특징을 가지고 있다.&#x20;
  * **영역 기반 GC : G1GC 는 힙을 일정한 크기의 영역으로 분할하고, 각 영역에 GC 를 진행한다.** &#x20;
  * **병렬 및 동시 GC**&#x20;
  * **영역별 기반 수집 GC : G1GC 는 각 영역별로 GC 를 수행하며, 가장 가득 찬 영역에서 GC 를 우선적으로 진행하며, 그 다음으로 가득 찬 영역을 수집하여 GC 를 수행한다.**  \
    **->영역별로 GC 를 진행하는 방식은, GC 대상이 되는 수를 줄여서 전체적인 성능을 향상시킨다.**&#x20;
* G1GC 의 장점은 다음과 같다.&#x20;
  * **힙 공간의 효율적 사용 : G1GC 는 힙 공간을 분할하여 사용하므로, 메모리 단편화 문제를 완화하고 메모리 사용량을 최소화 할 수 있다.**&#x20;
  * **병렬 처리 : G1GC 는 병렬 처리 사용하므로, 다중 스레드를 활용하여 GC 작업을 더 빠르게 수행 가능하다.**&#x20;
  * **예측가능한 stop-the-world 시간**&#x20;
* G1GC 의 단점은 다음과 같다.
  * **추가 오버헤드: G1GC는 세분화된 영역 및 복잡한 로직을 사용하므로, 약간의 추가 오버헤드가 발생할 수 있습니다. 이는 일부 애플리케이션에서 약간의 성능 저하로 이어질 수 있습니다.**
  *   **초기 설정 및 튜닝의 어려움: G1GC는 다양한 구성 요소와 튜닝 옵션을 가지고 있어 초기 설정 및 튜닝이 상대적으로 어려울 수 있습니다. 적절한 구성과 튜닝이 필요하며, 이는 경험과 실험을 통해 파악해야 하는 단점입니다.**

      \


