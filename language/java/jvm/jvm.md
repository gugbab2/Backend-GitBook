# JVM 구조 이해하기

<figure><img src="../../../.gitbook/assets/image (7) (1).png" alt=""><figcaption></figcaption></figure>

* 자바의 코드가 운영체제에서 실행되기 위해서는 아래의 과정을 거친다.
* 자바 소스코드 -> 자바 컴파일러 -> 바이트코드 -> **JVM** -> 기계어 -> 하드웨어 및 OS&#x20;

## 1. 클래스 로더 시스템

* **우리가 컴파일 한 클래스를파일을 읽어들여서 메모리에 적절하게 배치하는 일을 한다.**
* 로딩 : 클래스 파일에서 바이트 코드를 읽고, 적절한 데이터를 메모리에 올린다. \
  \-> ex) 메서드 영역 : 클래스 수준 정보, 힙 영역 : 인스턴스&#x20;
* 링크 : 래퍼런스(참조)를 연결하는 과정.
* 초기화 : static 값을 초기화 및 변수에 할당

## 2. 메모리

### 2-1. 공유하는 자원

* 메소드 : 클래스 수준의 정보(클래스 이름(풀패키지 경로), 부모 클래스 이름, 메소드, 변수 등)를 저장한다.
* 힙 : 객체(실제 인스턴스)를 저장한다.

### 2-2. 쓰레드 단위로 존재하는 자원

* 스택 : 쓰레드마다 런타임 스택을 만들고, 그 안에 메소드 호출을 스택 프레임(콜스택) 이라 부르는 블럭으로 쌓는다.
* PC(Program Counter) 레지스터 : 쓰레드 마다 쓰레드 내 현재 실행할 스택 프레임을 가리키는 포인터가 생성된다.
* 네이티브 메서드 스택 : 네이티브 메서드를 저장한다 (네이티브 메서드 : C, C++ 로 작성된 라이브러리)\
  \-> 네이티브 메서드 인터페이스와 네이티브 메서드 라이브러리와 항상 함께 동작한다.

## 3. 실행엔진

* 인터프리터 : 바이트코드를 이해하고 한줄 씩 실행한다.
* JIT(Just In Time) 컴파일 : 인터프리터를 통해서 반복되는 바이트코드가 발견되며, JIT 컴파일러로 반복되는 코드를 네이티브코드로 바꾸어준다. 그 다음부터 인터프리터는 JIT 컴파일러에 의해서 컴파일 된 코드를 사용한다.\
  \-> **프로그램 속도를 높여준다.**\
  \-> **캐시와 비슷..**
* GC : 더 이상 참조되지 않는 객체들을 모아서 정리한다.

## 4. 그 외..

* JNI(Java Native Interface) : 네이티브 메서드를 호출할 수 있도록 해주는 인터페이스
* JNL(Java Native Library) : 네이티브 메서드를 사용할 수 있는 실제 객체(라이브러리)\
  \-> native 키워드를 사용한다.

<figure><img src="../../../.gitbook/assets/image (4) (2).png" alt=""><figcaption></figcaption></figure>
