# 3. 오브젝트와 의존관계2

## 스프링 컨테이너와 의존관계 주입(Dependency Injection)&#x20;

* 우리는 이미 스프링 의존관계 주입을 위한 구조를 만들어두었다. 우리가 만들어 둔 `ObjectFactory` 가 `BeanFactory` 로 변경되기만 하면 된다.&#x20;
* 여기서 빈은 프로그램을 구성하는 오브젝트라고 생각하면 된다.&#x20;

<figure><img src="../../../.gitbook/assets/스크린샷 2024-12-04 19.35.58.png" alt=""><figcaption></figcaption></figure>

<figure><img src="../../../.gitbook/assets/스크린샷 2024-12-04 19.36.08.png" alt=""><figcaption></figcaption></figure>

* 하지만 스프링의 `BeanFactory` 는 어떤 의존성을 주입해야 하는지 알 수 없다. 때문에 어떤 의존성을 주입해야 하는지를 지정해주는 `ObjectFactory` 를 하나 추가해야 한다.&#x20;
* 여기서 빈은 `PaymentService`, `WebApiExRateProvider` 이고, 어떤 의존성을 주입할 것인지에 대한 구성정보를 `ObjectFactory 에서 설정하게 된다.`

<figure><img src="../../../.gitbook/assets/스크린샷 2024-12-04 19.45.59.png" alt=""><figcaption></figcaption></figure>

* 아래 코드는 위 구조대로 완벽히 스프링으로 변경되었다.&#x20;
  * `beanFactory` 를 통해 빈 정보를 가져왔다.&#x20;
  * `ObjectFactory` 에서 빈 정보를 설정해주었다.&#x20;

```java
package spring.hellospringv3;

import org.springframework.beans.factory.BeanFactory;
import org.springframework.context.annotation.AnnotationConfigApplicationContext;

import java.io.IOException;
import java.math.BigDecimal;
import java.util.concurrent.TimeUnit;

public class Client {
    public static void main(String[] args) throws IOException, InterruptedException {
        BeanFactory beanFactory = new AnnotationConfigApplicationContext(ObjectFactory.class);
        PaymentService paymentService = beanFactory.getBean(PaymentService.class);

        Payment payment1 = paymentService.prepare(100L, "USD", BigDecimal.valueOf(50.7));
        System.out.println("Payment1 : " + payment1);
    }
}
```

```java
package spring.hellospringv3;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class ObjectFactory {

    @Bean
    public PaymentService paymentService() {
        return new PaymentService(cachedExRateProvider());
    }

    @Bean
    public ExRateProvider exRateProvider() {
        return new WebApiExRateProvider();
    }
}
```

### 의존관계 주입(Dependency Injection)&#x20;

* IoC 는 스프링의 동작원리를 정확하게 설명하기에는 너무 일반적인 프레임워크 동작원리를 설명하는 용어이다.&#x20;
* 때문에, **스프링과 같이 오브젝트의 의존관계에 대한 책임을 스프링 컨데이터와 같이 외부 오브젝트가 담당하도록 만드는 것을 설명하는, 의존관계 주입(Dependency Injection) 패턴**을 줄여서 DI 라고 불리는 용어가 마틴 파울러에 의해서 제안되었고, 스프링 개발자들 사이, 또 이 원칙을 따라서 프레임워크를 만들거나 개발 방식을 설명하는 다른 언어와 기술에서 넓게 사용되고 있다.&#x20;
* 스프링이 처음 등장했던 시기에는 IoC 라는 용어를 주로 사용했기 때문에, 이후에 DI 를 사용하면서도 IoC 라는 용어도 같이 쓰이기도 한다.&#x20;

### 컨테이너&#x20;

* **애플리케이션을 구성하는 오브젝트를 만들어서 담아두고 필요할 때 사용하도록 제공하는 기능을 담당하는 것을 컨테이너라고 한다.**&#x20;
* **보통 오브젝트를 보관하는 것 뿐 아니라, 생명주기(lifecycle) 까지 담당한다.**&#x20;
* **스프링 컨테이너는 빈이라고 부르는 오브젝트를 생성하고 의존관계를 설정하는 것까지 담당한다.**&#x20;

## 싱글톤 레지스트리

> #### 싱글톤 패턴(Singleton Pattern)&#x20;
>
> * 싱글톤 패턴은 GoF 가 소개한 디자인패턴 중 하나이다. 디자인 패턴 중에서 가장 자주 활용되는 패턴이기도 하지만, 가장 많은 비판을 갖는 패턴이기도 하다. 심지어 디자인 패턴은 쓴 GoF 멤버조차도 싱글톤 패턴은 매우 조심해서 사용해야 하거나, 피해야 할 패턴이라고 말하기도 한다.&#x20;
> * 싱글톤 패턴은 어떤 클래스 애플리케이션 내에서 제한된 인스턴스 개수, 이름처럼 주로 하나만 존재하도록 강제하는 패턴이다. 이렇게 하나만 만들어지는 클래스의 오브젝트는 애플리케이션 내에서 전역적으로 접근이 가능하다. 이를 애플리케이션의 여러 곳에서 공유하는 경우에 주로 사용한다.&#x20;

#### 싱글톤 패턴의 단점

* `private` 생성자를 가지고 있어 상속할 수 없다.&#x20;
* 싱글톤은 테스트하기 힘들다.&#x20;
* 서버 환경에서는 싱글톤이 하나만 만들어지는 것을 보장하지 못한다. (?)
* 싱글톤의 사용은 전역 상태를 만들 수 있기 때문에 바람직하지 못하다..&#x20;

#### 싱글톤 레지스트리&#x20;

* 스프링은 하나의 오브젝트만 만들어져야 한다는 필요를 충족하면서도 싱글톤 패턴을 사용해서 만들어졌을 때의 단점을 가지지 않도록 코드 레벨이 아닌 컨테이너 레벨에서 하나의 오브젝트만 만들어지는 것을 보장하는 기능을 제공한다.&#x20;
* 이렇게 싱글톤 오브젝트를 만들고 관리하는 스프링 컨테이너를 싱글톤으로 등록하고 관리한다는 의미에서 싱글톤 레지스트리라고 말한다.&#x20;
* 스프링 빈이 생성되고 적용되는 범위를 빈의 스코프(scope) 라고 부른다. 스프링은 기본적으로 빈 오브젝트가 싱글톤 스코프를 가지도록 한다. 필요에 따라 여러 개의 빈 오브젝트가 만들어지도록 할 수 있다.&#x20;

## DI 와 디자인패턴&#x20;

* 일반적으로 디자인 패턴에는 상속보다는 합성을 많이 사용한다.&#x20;
  * 상속의 한계가 있다 ..&#x20;
* 오브젝트 합성을 이용하는 디자인 패턴을 적용할 때 스프링 의존관계 주입(DI) 를 사용한다고 생각하면 된다.&#x20;

<figure><img src="../../../.gitbook/assets/스크린샷 2024-12-05 08.04.48.png" alt=""><figcaption></figcaption></figure>

## 의존성 역전 원칙(DIP)&#x20;

