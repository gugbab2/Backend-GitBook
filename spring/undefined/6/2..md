# 2. 오브젝트와 의존관계

* 스프링의 관심은 오브젝트이다.&#x20;
* 클래스와 오브젝트는 다르다.&#x20;
* 자바의 오브젝트는 클래스의 인스턴스 또는 배열이다.&#x20;

## 의존관계&#x20;

* 의존관계는 반드시 두 개 이상의 대상이 존재하고, 하나가 다른 하나를 사용, 호출, 생성, 인스턴스화, 전송 등을 할 때 의존관계가 있다고 이야기한다.&#x20;
* 클래스 사이에 의존관계가 있을 때 의존 대상이 변경되면 이를 사용하는 클래스의 코드도 영향을 받는다.&#x20;
* 오브젝트 사이에 의존관계는 실행되는 런타임에 의존관계가 만들어지고 실행 기능에 영향을 받지만 클래스 레벨의 의존관계와는 다를 수 있다.&#x20;

#### 예시코드

* 아래 코드는 의존관계가 매우 강하게 연결되어 있다.&#x20;
* `PaymentService.prepare()` 메서드에서 환율정보를 가져오고, 원화로 계산하는 모든 기능을 담당하고 있다.&#x20;

```java
package spring.hellospringv0;

import java.math.BigDecimal;
import java.time.LocalDateTime;

public class Payment {
    private Long orderId;
    private String currency;
    private BigDecimal foreignCurrencyAmount;
    private BigDecimal exRate;
    private BigDecimal convertedAmount;
    private LocalDateTime validUntil;

    public Payment(Long orderId, String currency, BigDecimal foreignCurrencyAmount, BigDecimal exRate, BigDecimal convertedAmount, LocalDateTime validUntil) {
        this.orderId = orderId;
        this.currency = currency;
        this.foreignCurrencyAmount = foreignCurrencyAmount;
        this.exRate = exRate;
        this.convertedAmount = convertedAmount;
        this.validUntil = validUntil;
    }

    // getter, setter, toString
}
```

```java
package spring.hellospringv0;

import com.fasterxml.jackson.annotation.JsonIgnoreProperties;

import java.math.BigDecimal;
import java.util.Map;

@JsonIgnoreProperties(ignoreUnknown = true)
public record ExRateData(String result, Map<String, BigDecimal> rates) {

}
```

```java
package spring.hellospringv0;

import com.fasterxml.jackson.databind.ObjectMapper;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.math.BigDecimal;
import java.net.HttpURLConnection;
import java.net.URL;
import java.time.LocalDateTime;
import java.util.stream.Collectors;

public class PaymentService {
    public Payment prepare(Long orderId, String currency, BigDecimal foreignCurrencyAmount) throws IOException {
        URL url = new URL("https://open.er-api.com/v6/latest/" + currency);
        HttpURLConnection connection = (HttpURLConnection) url.openConnection();
        BufferedReader br = new BufferedReader(new InputStreamReader(connection.getInputStream()));
        String response = br.lines().collect(Collectors.joining());
        br.close();

        ObjectMapper mapper = new ObjectMapper();
        ExRateData data = mapper.readValue(response, ExRateData.class);
        BigDecimal exRate = data.rates().get("KRW");

        BigDecimal convertedAmount = foreignCurrencyAmount.multiply(exRate);
        LocalDateTime validUntil = LocalDateTime.now().plusMinutes(30);

        return new Payment(orderId, currency, foreignCurrencyAmount, exRate, convertedAmount, validUntil);
    }
}
```

```java
package spring.hellospringv0;

import java.io.IOException;
import java.math.BigDecimal;

public class Client {
    public static void main(String[] args) throws IOException {
        PaymentService paymentService = new PaymentService();
        Payment payment = paymentService.prepare(100L, "USD", BigDecimal.valueOf(50.7));
        System.out.println(payment);
    }
}
```

## 관심사의 분리 (Separation of concerns)&#x20;

* 관심사는 동일한 이유로 변경되는 코드의 집합&#x20;
* API 를 이용해서 환율정보를 가져오고, JSON 을 오브젝트에 매핑하는 관심과 (관심사1)\
  Payment 를 준비하는 로직 (관심사2) 은 관심이 다르다. 변경의 이유와 시점을 살펴보고 이를 분리한다.&#x20;

> #### 리팩터링&#x20;
>
> * 리팩터링은 기존의 코드를 외부의 동작방식에는 변화 없이 내부 구조를 변경해서 재구성하는 작업 또는 기술을 말한다.&#x20;
> * 리팩토링을 하면 코드 내부의 설계가 개선되어 코드를 이해하기가 더 편해지고, 변화에 효율적으로 대응할 수 있다. 결국, 생산성은 올라가고, 코드의 품질은 높아지며, 유지보수하기 용이해지고, 견고하면서도 유연한 제품을 개발할 수 있다.&#x20;
> * 리팩토링이 필요한 코드의 특징을 나쁜 냄새라고 부르기도 한다. 대표적으로, 중복된 코드는 매우 흔하게 발견되는 나쁜 냄새다.&#x20;

### 메서드 추출(extract method) 리팩터링&#x20;

* `PaymentService.prepare()` 매서드 내 2가지 책임&#x20;
  * API 를 활용해 환율정보를 가져오고, JSON 을 오브젝트에 매핑하는 로직 - 관심사1&#x20;
  * `Payment` 를 준비하는 로직 - 관심사2&#x20;
* 메서드 추출을 통해서 한 메서드 내에 가지고 있는 관심을 분리해주었다.&#x20;

```java
package spring.hellospringv1;
import java.io.IOException;
import java.math.BigDecimal;
import java.time.LocalDateTime;

public class PaymentService {

    public Payment prepare(Long orderId, String currency, BigDecimal foreignCurrencyAmount) throws IOException {
        BigDecimal exRate = getExRate(currency);
        BigDecimal convertedAmount = foreignCurrencyAmount.multiply(exRate);
        LocalDateTime validUntil = LocalDateTime.now().plusMinutes(30);

        return new Payment(orderId, currency, foreignCurrencyAmount, exRate, convertedAmount, validUntil);
    }

    public BigDecimal getExRate(String currency) throws IOException {
        URL url = new URL("https://open.er-api.com/v6/latest/" + currency);
        HttpURLConnection connection = (HttpURLConnection) url.openConnection();
        BufferedReader br = new BufferedReader(new InputStreamReader(connection.getInputStream()));
        String response = br.lines().collect(Collectors.joining());
        br.close();

        ObjectMapper mapper = new ObjectMapper();
        ExRateData data = mapper.readValue(response, ExRateData.class);
        BigDecimal exRate = data.rates().get("KRW");
        return exRate;
    }
}
```

### 상속을 통한 확장&#x20;

* `Payment` 의 변경 없이 환율 정보를 가져오는 방법을 확장하게 만들려면 상속을 사용할 수 있다.&#x20;
* 어떻게 `Payment` 를 준비할 것이냐와 어떻게 환율을 가져올 것인가라는 관심사가 클래스 레벨에서 분리된다.&#x20;
* 객체지향 디자인 패턴에 나오는 팩토리 메서드 패턴을 사용하자.&#x20;

> #### 팩토리 메서드 패턴&#x20;
>
> * 팩토리 메서드 패턴은 상속을 통해 기능을 확장하게 하는 패턴이다. 슈퍼클래스 코드에서는 서브클래스에서 구현할 메서드를 호출해서 필요한 타입의 오브젝트를 가져와 사용한다.&#x20;
> * 이 메서드는 주로 인터페이스 타입으로 오브젝트를 리턴하므로 서브클래스에서 정확히 어떤 클래스의 오브젝트를 만들어 리턴할지는 슈퍼클래스에서는 알지 못한다. 사실 관심도 없다.&#x20;
> * 서브클래스는 다양한 방법으로 오브젝트를 생성하는 메서드를 재정의할 수 있다. 이렇게 서브클래스에서 오브젝트 생성 방법과 클래스를 결정할 수 있도록 미리 정의해둔 메소드를 **펙토리 메서드**라고 하고,&#x20;
> * 이 방식을 통해 오브젝트 생성 방법을 나머지 로직, 즉 슈퍼클래스의 기본 코드에서 독립시키는 방법을 **팩토리 메서드 패턴**이라고 부른다.&#x20;
> * 자바에서 종종 오브젝트를 생성하는 기능을 가진 메서드를 일반적으로 팩토리 메서드라고 부르기도 한다. 이때 말하는 팩토리 메서드와 펙토리 메서드 패턴에서 말하는 팩토리 메서드가 다르기 때문에, 주의가 필요하다.&#x20;





