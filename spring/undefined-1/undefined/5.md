# 객체지향 설계의 5원칙

> **좋은 소프트웨어 설계는 응집도를 높이고 결합도를 낮추어야 한다.**\
> **-> 결합도가 높다는 것은 객체의 변경이 생겼을 때 수정해야 하는 객체가 많다는 것을 의미한다.**\
> **-> 이러한 설계는 결론적으로 유지보수를 쉽게하기 위한 설계이다.**

## 1. SRP(Single Responsibility Principle) : 단일 책임 원칙

* **어떤 클래스를 변경하는 이유는 오직 하나뿐이어야 한다. -> 단일 책임**
* 예를 들어, 남자라는 객체의 다양한 책임(남편, 아들, 직장직원, 예비군) 이라는 다양한 책임이 있을 때에 객체지향의 설계에서는 나쁜 냄시가 난다고 말한다.\
  \-> 이런 경우 책임을 분리하는 것이 단일 책임 원칙이라고 부른다.\
  (위의 경우 책임에 따라서 4개의 클래스로 나눈다)
* 예를들어, 사람 클래스에 군번이라는 속성이 있다면 남자 여자 클래스를 나누어 각 객체에 맞는 책임을 질 수 있도록 조정해야 한다. **(메서드가 두가지 역할을 하고 있다면, 해당 메서드는 리펙토링의 대상이다)**\
  \-> 만약 사람 클래스에 남자와 여자의 공통점이 없다면 사람 클래스를 제거하면 된다
* **단일 책임 원칙은 추상화와 관련이 깊다**\
  **-> 추상화는 각 도메인에 맞도록 객체를 설계하는 즉, 단일 책임 원칙이라고 볼 수 있다.**

## 2. OCP(Open Closed Principle) : 개방 폐쇠 원칙

* **클라이언트의 입장에서 확장에 있어서는 열려있고,**&#x20;
* **서버 입장에서 변화에 있어서는 닫혀 있어야 한다.**
* 예시
  * 차종이 바뀐다고 해서, 운전하는 근본적인 방법이 바뀌는 것은 아니다.
  * JDBC 는 JDBC 인터페이스를 통해서, 데이터페이스가 변경되더라도 문제 없이 연결할 수 있다.
  * Java 는 목적파일(.class) 을 통해서 운영체제가 변경되더라도 문제 없이 실행시킬 수 있다.
  * 편의점에서 직원은 물건 정리와 판매가 주 행동이기 때문에, 사람이 바뀐다고 해서 근본적으로 바뀌는 것은 아니다.\
    \=> **이 공통적인 행동들은 인터페이스를 통해 각 클래스가 상속받을 수 있도록 구현한다.(be able to)**

## 3. LSP(Liskov Substitution Principle) : 리스코프 치환 원칙

* **서브타입은 언제나 기반타입으로 교체 될 수 있어야 한다.**\
  \-> 부모 객체를 호출하는 동작에서 자식 객체가 부모 객체를 완전히 대체할 수 있어야 한다. \
  **-> 부모 클래스와 자식 클래스의 행위의 일관성이 있어야 한다! (Java Collection Framework)**
* 올바른 리스코프 치환 원칙&#x20;
  * 하위 클래스 is a kind of 상위 클래스 - 하위 분류는 상위 분류의 한 종류이다.&#x20;
  * 구현 클래스 is able to 인터페이스 - 구현 분류는 인터페이스 할 수 있어야 한다.&#x20;
  * **분류도와 같은 객체 구조는 리스코프 치환 원칙을 따른다.**
  * ex, `동물 뽀로로 = new 펭귄();`
* 잘못된 리스코프 치환 원칙&#x20;
  * 자식 클래스로 부모 클래스의 내용을 상속하는데, 기존 코드에서 보장 하던 조건을 수정하거나 적용시키지 않아서, 기존 부모 클래스를 사용하는 코드에서 예상하지 않은 오류를 발생 시킨다면 문제다.\
    \-> **부모 클래스와 자식 클래스의 행위의 일관성이 사라졌다..**
  * **계층도/조직도와 같은 객체 구조는 리스코프 치환 원칙을 위반한다.**&#x20;
  * ex, `아버지 춘향이 = new 딸();`&#x20;

## 4. ISP(Interface Segregation Principle) : 인터페이스 분리 원칙

* **클라이언트는 자신이 사용하지 않는 메서드에 의존 관계를 맺어서는 안된다.**\
  **-> 하나의 객체가 다중의 책임을 가져서는 안된다.**
* 다중 책임을 가지는 객체에 대해 각각의 역할에 따른 인터페이스를 제한하고 그 인터페이스를 상속받은 클래스를 사용할 수 있다.\
  \-> 결국적으로 인터페이스 분리 원칙 또한 하나의 책임을 가진 객체를 만들기 위한 방법이다.\
  \-> **하지만, 특별한 경우가 아니라면 단일 책임 원칙(SRP) 를 지키는 것은 좋은 해결책이다.**&#x20;
* **상위 클래스는 풍성할 수록 좋다.**\
  \-> 빈약한 상위 클래스의 경우, **형변환이 계속적으로 발생하며 상속의 장점을 누리지 못한다.** (코드가 더러워진다)
* **인터페이스 작을수록 좋다.**\
  \-> 인터페이스는 그 역할에 충실한 최소한의 기능만 공개하는 것이 중요하다.\
  \-> **그렇지 않을 경우 현실세계에 대입되지 않는 상황이 생겨난다.**\
  ex) 소대장의 군인 남자친구가 사격중에 키스를 할 수는 없다.

## 5. DIP(Dependency Inversion Principle) : 의존 역전 원칙

* **고차원 모듈은 저차원 모듈에 의존하면 안된다.** \
  \-> **추상화(인터페이스)에 의존해야 하지 구체화(클래스)된 것에 의존해서는 안된다.**\
  **-> 자신보다 변하기 쉬운 것에 의존하지 말아라. (상위클래스일수록 구체화 된 클래스에 의존하면 안된다)**
* **예를 들면 자동차가 스노우타이어에 의존하는 것이 아닌 추상화된 타이어의 의존하고,**\
  **타이어의 인스턴스가 스노우타이어가 되는 설계가 옳은 설계이다.**
