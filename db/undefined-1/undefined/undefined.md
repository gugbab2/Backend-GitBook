# 서브쿼리

## 서브쿼리 소개&#x20;

조인을 통해 흩어진 테이블을 연결하는 방법에 대해서 배웠다. 하지만 데이터에 질문을 던지다 보면, JOIN 만으로는 한번에 답하기 어려운, 여러 단계의 사고를 거쳐야 하는 문제들을 만나게 된다.&#x20;

오늘의 문제 상황을 보자. \
&#xNAN;**"우리 쇼핑몰에서 판매하는 상품들은 평균 가격보다 비싼 상품은 무엇이 있을까?"**&#x20;

일반적으로 두 단계로 나누어 생각할 것이다.&#x20;

1. 먼저, 전체 상품의 평균 가격을 구한다.&#x20;
2. 그 평균 가격보다 비싼 상품을 찾는다.&#x20;

각각의 단계마다 쿼리를 날려 원하는 결과를 얻을 수 있다.&#x20;

두 번의 걸쳐 쿼리를 실행하는 방식은 몇 가지 문제점을 가진다.&#x20;

* 번거롭다 : 매번 첫 번쨰 쿼리의 결과를 복사해서 두 번째 쿼리에 붙여 넣어야 한다.&#x20;
* 오류에 취약하다 : 만약 상품 데이터가 실시간으로 추가되거나 가격이 변경된다면 어떨까? 1단계 쿼리를 실행하고 2단계 쿼리를 실행하는 그 짧은 순간에도 평균 가격은 변할 수 있다. 이렇게 되면 잘못된 기준으로 데이터를 조회할 수 있다.&#x20;

우리는 이 두 단계를 논리적으로 완벽한 하나의 작업 단위로 묶고 싶다. 이럴 때 사용하는 기술이 바로 서브쿼리(Subquery) 이다.&#x20;

### 서브쿼리의 개념&#x20;

서브쿼리는 말 그대로 하나의 SQL 쿼리 문 안에 포함된 또 다른 SELECT 쿼리를 의미한다. 바깥쪽의 메인쿼리가 실행되기 전에, 괄호() 안에 있는 서브쿼리가 먼저 실행된다. 그리고 데이터베이스는 서브쿼리의 실행 결과를 바깥쪽 메인 쿼리에 전달하여, 메인쿼리가 그 결과를 사용해서 최종 작업을 수행하게 된다.&#x20;

방금 우리가 두 단계로 풀었던 문제를 서브쿼리를 사용하면 이렇게 하나의 쿼리로 표현할 수 있다.&#x20;

```sql
select name, price 
from products 
where price > (select avg(price) from products);
```

해당 쿼리의 실행 순서는 다음과 같다.&#x20;

1. 데이터베이스는 괄호 안의 서브쿼리, (`select avg(price) from products`) 를 가장 먼저 실행한다.&#x20;
2. 서브쿼리가 실행된 결과인 `167166.67` 이라는 단일 값을 얻는다.&#x20;
3. 이제 원래의 쿼리는 내부적으로 다음과 같이 변한다. \
   `SELECT name, price FROM products WHERE price > 167166.67;`
4. 최종적으로 이 변환된 메인쿼리가 실행되어 우리에게 결과를 보여준다.&#x20;

서브쿼리는 JOIN 과 함께 복잡한 데이터를 분석하는 양대 산맥과 같은 기술이다. JOIN 이 테이블을 수평으로 넓혀 가는 기술이라면, 서브쿼리는 쿼리 내부에 논리적인 단계를 만들어 안으로 깊게 파고드는 기술이라고  할 수 있다.&#x20;

## 스칼라 서브쿼리&#x20;

가장 먼저 배울 것은 **단일 컬럼**, **단일 행** 서브쿼리이다. 서브 쿼리를 실행했을 때 그 결과가 **오직 하나의 행**, **하나의 컬럼**으로 나오는 경우를 말한다.&#x20;

결과가 하나의 값으로 정해지기 때문에, 이 값을 익숙한 단일 행 비교 연산자들(=, >, <, ...) 과 함께 사용할 수 있다.&#x20;

오늘 문제 상황을 통해 단일 행 서브쿼리를 이해해보자.&#x20;

**"특정 주문(order\_id = 1) 을 한 고객과 같은 도시에 사는 모든 고객을 찾고 싶다."**

* **특정 주문(order\_id = 1) 을 한 고객**
* **같은 도시에 사는 모든 고객**

### 단일 행 서브쿼리로 해결하기

```sql
select name, address 
from users 
where address = (select u.address 
                from users u 
                join orders o on u.user_id = o.user_id 
                where o.order_id = 1);
```

#### 쿼리 실행 흐름&#x20;

1. 괄호 안의 서브쿼리가 먼저 실행되어 단일 값 `'서울시 강남구'` 를 반환한다.&#x20;
2. 메인쿼리는 `where address = '서울시 강남구'` 와 동일한 형태로 바뀐다.&#x20;
3. 최종적으로 메인쿼리가 실행되어 우리에게 원하는 결과를 보여준다.&#x20;

이처럼 서브쿼리를 사용하면 여러 번의 쿼리를 하나로 합쳐 코드를 간결하게 만들고, IO 횟수를 줄려 성능상 이점을 얻을 수 있다.&#x20;

### 스칼라 서브쿼리의 치명적 오류&#x20;

단일 행을 반환하는 스칼라 서브쿼리를 사용할 때 가장 주의점은, **서브쿼리가 반드시, 무슨일이 있어도 하나의 행만 반환해야 한다는 것이다.**

만약 서브쿼리를 사용하는 메인 쿼리에서 단일 행 비교연산자를 사용하는데, 다중 행 서브쿼리를 사용한다면 오류가 발생한다.&#x20;

## 다중 행 서브쿼리&#x20;

현실의 문제는 종종 여러 개의 결과를 반환하는 서브쿼리를 필요로 한다. 오늘의 문제 상황을 보자. \
&#xNAN;**"'전자기기' 카테고리에 속한 모든 상품들을 주문한 주문 내역을 전부 다 보고싶다."**

여기서 1단계의 결과는 당연히 여러개일 것이다. 왜냐면 쇼핑몰에는 '전자기기' 카테고리가 여러개일 것이기 때문이다. \
이처럼 **서브쿼리의 결과가 여러 행으로 반환되는 것이 당연할 때, 사용하는 것이 다중 행 서브쿼리이다.**&#x20;

다중 행 서브쿼리의 결과를 처리하기 위해서는 = 같은 단일 행 연산자가 아닌, 목록을 다룰 수 있는 특별한 연산자가 필요하다. 대표적으로 `IN`, `ANY`, `ALL` 이 있다.&#x20;

### IN 연산자 : 목록에 포함된 값과 일치하는지 확인

IN 연산자는 다중 행 서브쿼리와 함꼐 가장 흔하게 사용되는, 가장 직관적인 연산자다. `WHERE 컬럼명 IN (값1, 값2, ... )` 처럼, 특정 컬럼의 값이 괄호 안의 목록 중 하나라도 일치하면 참(true) 을 반환한다.&#x20;

#### 1단계 (서브쿼리) : '전자기기' 상품의 ID 목록 조회&#x20;

먼저 서브쿼리가 될 부분부터 확인해보자.

```sql
select product_id from product where category = '전자기기' 
```

#### 2단계 (메인쿼리) : IN 을 이용해 최종 결과 조회&#x20;

이제 이 서브쿼리로 사용하여 `orders` 테이블에서 `product_id` 가 위 목록에 포함된 주문들만 필터링한다.&#x20;

```sql
SELECT * FROM orders
WHERE product_id IN (SELECT product_id
                FROM products
                WHERE category = '전자기기')
ORDER BY order_id;
```

쿼리 실행 흐름&#x20;

1. 괄호 안의 서브쿼리가 먼저 실행되어 id 값을 반환한다.&#x20;
2. 메인쿼리는 `WHERE product_id IN (1, 2, 3, 6)` 과 동일한 형태로 바뀐다.
3. 최종적으로 메인 쿼리가 실행된다.&#x20;

### ANY, ALL 연산자 : 목록의 모든/일부 값 비교

ANY, ALL 은 특정 조건을 해결하는데는 유용하지만, 사실 실무에서는 IN 연산자나 집계 함수를 사용한 서브쿼리로 대체할 수 있는 경우가 많다. 오히려 집계 함수를 사용하는 것이 더 명확하고 직관적일 때가 많다.&#x20;

## 다중 컬럼 서브쿼리&#x20;

다중 컬럼 서브쿼리는 서브쿼리의 SELECT 절에 두 개 이상의 컬럼이 포함되는 경우를 말한다. \
이 기법은 메인쿼리의 WHERE 절에선 여러 컬럼을 동시에 비교해야 할 때 매우 유용하다.&#x20;

오늘의 문제 상황을 보자. \
&#xNAN;**"우리 쇼핑몰의 고객 '네이트'(`user_id` =2)가 한 주문(`order_id` =3)이 있다. 이 주문과 동일한 고객이면서 주문 처리 상태(`status`)도 같은 모든 주문을 찾아보자."**

이 문제의 핵심은 `user_id`, `status` 라는 두 개의 조건을 동시에 만족하는 주문을 찾는 것이다.&#x20;

### 다중 컬럼 서브쿼리로 문제 해결하기&#x20;

#### 1단계 (서브쿼리) : 비교 기준이 될 고객 ID 와 주문 상태 조회&#x20;

```sql
select user_id, status from orders where odrer_id = 3
```

#### 2단계 (메인쿼리) : 다중 컬럼 비교

이제 이 서브쿼리를 메인쿼리의 WHERE 절로 넣어서 두 개의 컬럼을 한 번에 비교한다. 이때, 메인쿼리는 `WHERE` 절에도 비교할 컬럼들을 괄호로 묶어 (`user_id`, `status`) 와 같은 형태로 작성해주어야 한다.

```sql
SELECT order_id, user_id, status, order_date
FROM orders
WHERE (user_id, status) = (SELECT user_id, status
                                FROM orders 
                                WHERE order_id =3); 
```

쿼리 실행 흐름&#x20;

1. 괄호 안의 서브쿼리가 먼저 실행되어 `(2, 'SHIPPED')` 라는 한 쌍의 값을 반환한다.&#x20;
2. 메인쿼리는 `WHERE(user_id, status) = (2, 'SHIPPED')` 와 동일한 형태로 바뀐다.&#x20;
3. 최종적으로 테이블에서 `user_id` 가 `2`이고 `status` 가 `'SHIPPED'` 인 모든 주문을 찾아 반환한다.&#x20;

#### 주의할 점&#x20;

다중 컬럼 서브쿼리를 `=` 연산자와 함께 사용할 때는, 단일 행 서브쿼리의 결과가 반드시 하나의 행이어야 한다는 점을 잊지 말아야 한다. 만약 서브쿼리가 2개 이상의 행을 반환하면 데이터베이스는 어떤 행과 비교해야 할지 알 수 없으므로 오류를 유발시킨다.&#x20;

### 다중 컬럼 서브쿼리와 IN 연산자

다중 커럼 서브쿼리 역시 결과가 여러 행일 수 있다. 이때는 `=` 대신 `IN` 연산자를 사용해야 한다.&#x20;

## 상관 서브쿼리1&#x20;

이전 시간까지 우리는 WHERE 절에 서브쿼리를 사용하여, 메인쿼리와는 독립적으로 실행된 결과를 필터링 조건으로 사용하는 방법을 배웠다. 즉, 서브쿼리가 먼저 한 번 실행되어 값을 만들어내면, 메인쿼리가 그 값을 이어받아 사용하는 방식이었다.&#x20;

하지만, 이런 질문에는 어떻게 대답할까? \
&#xNAN;**"각 상품별로, 자신이 속한 카테고리의 평균 가격 이상의 상품들을 찾아라"**

이 문제의 핵심은 '전체 평균 가격' 이 아닌, '**자신이 속한 바로 그 카테고리의 평균 가격**' 과 비교해야 한다는 점이다.&#x20;

이처럼 서브쿼리가 메인쿼리에서 현재 처리 중인 행의 특정 값을 알아야만 계산을 수행할 수 있을때, 바로 **상관 서브쿼리**를 사용해야 한다.&#x20;

### 상관 서브쿼리의 개념&#x20;

상관 서브쿼리는 이름 그대로, **메인쿼리와 서브쿼리가 서로 '연관' 관계를 맺고 동작**하는 서브쿼리이다. 서브쿼리가 독립적으로 실행될 수 없고, 메인쿼리의 값을 참조하여 실행되는 것이 특징이다.&#x20;

상관 서브쿼리의 동작 방식은 기존 서브쿼리와 완전히 다르다.&#x20;

* **비상관 서브쿼리** : 서브쿼리가 **단 한 번** 실행 후, 그 결과를 메인쿼리가 사용한다.&#x20;
* **상관 서브쿼리**&#x20;
  * 메인쿼리가 먼저 한 행을 읽는다.&#x20;
  * 일혀진 행의 값을 서브쿼리에 전달하여, 서브쿼리가 **실행**된다.&#x20;
  * 서브쿼리의 결과를 이용해 메인쿼리의 `WHERE` 조건을 판단한다.&#x20;
  * 메인쿼리의 다음 행을 읽고, 2-3번 과정을 **반복**한다.&#x20;

### 상관 서브쿼리로 문제 해결하기&#x20;

"각 상품별로, 자신이 속한 카테고리의 평균 가격 이상의 상품들을 찾아라."

```sql
select 
    product_id, 
    name, 
    category, 
    price 
from products p1
where price >= (select avg(price) 
                from products p2 
                where p2.category = p1.category); 
```

이 쿼리의 가장 중요한 부분은 `where p2.category = p1.category` 이다.\
이 부분을 통해서 메인쿼리와 서브쿼리과 관계를 맺게 된다.&#x20;

## 상관 서브쿼리2

### 한 번이라도 주문된 상품 조회하기&#x20;

```sql
select 
    product_id, 
    name, 
    price
from products
where product_id in (select distinct product_id from orders); 
```

### EXISTS 를 사용한 더 효율적인 방법&#x20;

`IN` 방식은 `orders` 테이블이 매우 클 경우, 즉 주문량이 주백만 건 이상일 경우 성능 문제가 발생할 수 있다.&#x20;

이럴때 `EXISTS` 를 사용하면 효율적으로 쿼리를 실행할 수 있다.\
`EXISTS` 는 서브쿼리가 반환하는 값 자체에는 관심 없고, 오직 서브쿼리의 결과로 행이 하나라도 존재하는지 여부만 체크한다.&#x20;

```sql
select 
    product_id, 
    name, 
    price
from products p 
where exists (
    select 1
    from orders o 
    where p.product_id = o.product_id); 
```

이 방식의 경우 서브쿼리에서 조건을 만족하는 첫 번째 행을 찾자마자 더 이상 테이블을 탐색하지 않고, `true` 를 반환한다.&#x20;

때문에, `orders` 의 데이터가 매우 크더라도 조회와 관련된 오버헤드가 발생한다고 볼수는 없다.&#x20;

### 상관 서브쿼리와 성능&#x20;

상관 서브쿼리는 복잡한 로직을 매우 직관적으로 표현할 수 있도록 해주지만, 성능에 주의해야 한다. 메인쿼리의 행 수만큼 서브쿼리가 반복 실행될 수 있기 때문에, 메인쿼리가 다루는 데이터의 양이많아지면 쿼리 전체의 성능이 급격하게 저하될 수 있다.&#x20;

많은 경우, 상관 서브쿼리는 JOIN 으로 동일한 결과를 얻도록 재작성이 가능하다. 또한 데이터베이스 옵티마이저가 JOIN 더 효율적으로 처리하는 경우가 많다.&#x20;

하지만 `EXISTS` 는 특정 조건에 맞는 데이터가 있는지 '확인만 하고 넘어가는' 특성 덕분에, `IN` 이나 `JOIN` 보다 훨씬 효율적으로 동작하는 상황도 많다.

결론적으로 상관 서브쿼리는 성능 이슈를 인지하고, JOIN 으로 표현하기 너무 복잡하거나, EXISTS 를 통해 더 효율적으로 실행 가능할 때 적절히 사용하는 것이 중요하다.&#x20;

## SELECT 서브쿼리&#x20;

만약 서브쿼리를 `SELECT` 절 안으로 가져온다면 어떻게 될까? 서브쿼리는 더이상 필터가 아닌 컬럼으로 동작하게 된다!&#x20;

참고로 `SELECT` 절에서는 단일 값을 반환하는 스칼라 서브쿼리를 사용해야 한다.&#x20;

### 비상관 서브쿼리&#x20;

**문제 상황** : "모든 상품 목록을 조회하는데, 각 상품의 가격과 함께 **전체 상품의 평균 가격**을 모든 행에 함께 표시해서 개별 상품 가격이 평균과 얼마나 차이 나는지 비교해보고 싶다."

```sql
SELECT
    name,
    price,
    (SELECT AVG(price) FROM products) AS avg_price
FROM products;
```

\[쿼리 실행 흐름]

1. 데이터베이스는 메인쿼리를 실행하기 전, `SELECT` 절의 스칼라 서브쿼리를 단 한 번 먼저 실행한다.&#x20;
2. 데이터베이스는 이 계산된 값을 기억해 둔다.&#x20;
3. 메인쿼리가 실행되고,&#x20;
4. `products` 테이블의 각 행을 가져올 때마다, `avg_price` 컬럼에 미리 계산해 둔 값을 그대로 추가한다.&#x20;

**비상관 서브쿼리의 경우 `SELECT` 에서 사용될 때 캐시 처럼 동작하기 때문에, 성능상 큰 문제가 발생하지 않는다.**&#x20;

### 상관 서브쿼리&#x20;

**문제 상황** : "전체 상품 목록을 조회하면서, 각 상품별로 총 몇 번의 주문이 있었는지 '총 주문 횟수'를 함께 보여주고 싶다."

```sql
SELECT 
    product_id, 
    name,
    price, 
    (select count(*) from orders o where o.product_id = o.product_id) as order_count 
from products p; 
```

여기서 가장 중요한 부분은 서브쿼리 안의 `WHERE o.product_id = p.product_id` 조건이다.\
`p.product_id` 는 메인쿼리(`FROM products p` )가 현재 처리하고 있는 행의 `product_id` 값을 의미한다.

\[쿼리 실행 흐름]&#x20;

1. 메인쿼리가 `products` 테이블의 첫 번째 행, '프리미엄 게이밍 마우스'(`p.product_id` =1)를 읽는다.
2.  이 행의 `order_count` 값을 계산하기 위해 스칼라 서브쿼리가 실행된다. 이때 `p.product_id` 에는 `1` 이 전

    달된다.

    `(SELECT COUNT(*) FROM orders o WHERE o.product_id = 1)`
3. 이 서브쿼리는 `orders` 테이블에서 `product_id` 가 1인 주문을 세어 `3` 이라는 단일 값을 반환한다.
4. 첫 번째 행의 `order_count` 컬럼에는 `3` 이 기록된다.
5. 이 과정을 반복한다.&#x20;

결과를 보면 각 상품별로 정확한 주문 횟수가 새로운 컬럼의 조회된 것을 볼 수 있다. 한 번도 팔리지 않은 상품의 주문 횟수는 0으로 표시된다.&#x20;

### 실무 팁 : 성능에 주의하라&#x20;

스칼라 서브쿼리는 이처럼 `JOIN` 으로 표현하기 복잡한 로직을 직관적으로 표현할 수 있게 해주지만, 강력한 만큼 주의해서 사용해야 한다.&#x20;

가장 큰 단점은 성능 저하의 가능성이다. 특히 상관 서브쿼리는 메인쿼리가 반환하는 행의 수만큼 서브쿼리가 반복 실행되기 때문이다. 만약 `products` 테이블에 100만개의 상품이 있다면, 주문 횟수를 알기 위해서 `COUNT(*)` 쿼리가 100만번이나 실행되는 것이다.&#x20;

사실 오늘의 문제 상황은 `LEFT JOIN` 과 `GROUP BY` 를 사용해서 해결할 수 있으며, 대부분의 경우 데이터베이스 옵티마이저가 `JOIN` 을 더 효율적으로 처리하여 성능이 좋다.&#x20;

그럼에도 불구하고 스칼라 서브쿼리는 `JOIN` 이 너무 복잡해지거나, 완전히 다른 테이블에서 간단한 정보 하나만 조회해 올 때 코드를 훨씬 명료하게 만들어주는 장점이 있어 적재적소에 사용하면 매우 유용하다.

## 테이블 서브쿼리

## 서브쿼리 vs JOIN&#x20;

**문제 상황: "서울에 거주하는 모든 고객들의 주문 목록을 조회해라."**

### 해결 방법 1: 서브쿼리 사용&#x20;

서브쿼리를 이용한 접근법은 우리의 사고 흐름과 매우 유사하다.&#x20;

1. 먼저, 서울에 사는 고객들의 `user_id` 목록을 찾는다 (`users` 테이블).
2. 그다음, 이 `user_id` 목록에 포함된 `order_id` 를 가진 주문들을 찾는다 (`orders` 테이블).

이 논리를 그대로 쿼리로 옮기면 다음과 같다.

```sql
SELECT o.order_id, o.user_id, o.product_id, o.order_date
FROM orders o
WHERE o.user_id IN (SELECT user_id FROM users WHERE address LIKE '서울%');
```

### 해결 방법 2: JOIN 사용&#x20;

`JOIN` 을 이용한 접근법은 필요한 테이블들을 일단 모두 연결한 뒤, 원하는 조건을 필터링하는 방식이다.

```sql
SELECT o.order_id, o.user_id, o.product_id, o.order_date
FROM orders o
JOIN users u ON o.user_id = u.user_id
WHERE u.address LIKE '서울%';
```

### 성능 vs 가독성 : 실무 가이드&#x20;

#### 성능 (Performance)

**일반적으로, 데이터베이스는 `JOIN` 이 서브쿼리보다 성능이 더 좋거나 최소한 동일한 경우가 많다.**

왜 그럴까? 그 비밀은 데이터베이스의 '두뇌' 역할을 하는 **쿼리 옵티마이저(Query Optimizer)**&#xC5D0; 있다.

*   `JOIN` 구문은 옵티마이저에게 더 많은 정보를 제공한다. "A와 B 테이블을 특정 조건으로 연결해야 한다"는 전체

    그림을 미리 보여주기 때문에, 옵티마이저는 인덱스를 어떻게 활용하고 어떤 테이블을 먼저 읽을지 등 가장 효율

    적인 실행 계획을 선택할 수 있는 더 넓은 선택지를 갖는다.
*   반면, 서브쿼리는 (특히 과거의 데이터베이스에서는) 단계적으로 실행되는 경우가 많았다. 서브쿼리를 먼저 실행

    해서 나온 결과를 메모리에 담아두고, 그 다음 메인쿼리가 그 결과를 참조하는 방식으로 동작하여 비효율을 야기

    할 수 있었다.

**하지만!** 요즘 데이터베이스의 옵티마이저는 매우 똑똑해져서, 우리가 작성한 예제처럼 간단한 IN 서브쿼리는 내부적으로 최적의 `JOIN` 구문으로 자동 변환해서 실행하는 경우가 많다. 따라서 위 예제의 두 쿼리는 사실상 동일한 성능을 낼 확률이 높다.

참고로 이런 최적화는 항상 가능한 것은 아니기 때문에 쿼리 실행 계획 등을 확인하는 것이 좋다.

#### 가독성 (Readability)&#x20;

가독성은 주관적인 영역이지만, 쿼리의 유지보수 측면에서 성능만큼이나 중요하다.

* **서브쿼리**는 쿼리의 논리적 단계를 명확하게 구분해 주어, 복잡한 로직을 더 이해하기 쉽게 만들어주는 경우가 많다.
* `JOIN` 은 쿼리에 필요한 모든 데이터 소스를 한눈에 보여주고, 여러 테이블의 컬럼을 함께 조회해야 할 때는 구조적으로 더 깔끔하다.

### 최종 결론 : 언제 무엇을 사용해야 할까?&#x20;

정답은 없다. 하지만 실무에서 적용할 수 있는 가이드라인은 다음과 같다.&#x20;

1. **`JOIN` 을 우선적으로 고려하자.**&#x20;
   1. 일반적인 성능 우위와 범용성을 고려할 때, 문제를 해결할 방법을 `JOIN` 에서 먼저 찾아보는 것이 좋은 출발점이다.&#x20;
2. **`JOIN` 으로 표현하기 너무 복잡하거나, 서브쿼리의 가독성이 훨씬 좋다면 서브쿼리를 사용하라.**
   1.  성능이 아주 중요한 쿼리가 아니라면, 동료가 이해하기 쉬운 코드를 작성하는 것이 장기적으로 더 가치 있을 수 있

       다.&#x20;
   2. 특히 인라인 뷰를 사용해야만 깔끔하게 풀리는 문제는 서브쿼리가 정답이다.
3. **`EXISTS` 를 활용하라.**
   1. `IN` 서브쿼리의 대안으로, `EXISTS` 라는 서브쿼리 연산자도 있다.&#x20;
   2. `EXISTS` 는 서브쿼리의 결과값이 존재하는지 여부만 체크하기 때문에, 특정 상황에서 더 효율적으로 동작하기도 한다.
4. **성능이 의심될 때는 반드시 측정하라.**&#x20;
   1. 가장 중요한 원칙이다. 추측하지 말고, `EXPLAIN` 과 같은 도구를 사용해 데이터베이스가 어떻게 쿼리를 실행하는지 계획을 분석하고, 실제 실행 시간을 측정하여 더 나은 방법을 선택해야 한다.
