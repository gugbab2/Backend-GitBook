# 10회차(2024.12.29)

## 1. 스프링 프레임워크에서 IoC 와 DI 의 차이점은 무엇인가요?&#x20;

#### IoC(Inversion of Control)  - "객체를 누가 관리하는가"에 대한 철학&#x20;

* IoC 는 객체의 생성과 그 객체의 생명주기 관리 책임을 개발자가 아닌 컨테이너(Spring Container) 가 담당하도록 제어의 흐름을 뒤집는 설계 원칙이다.&#x20;
* ex) 일반적인 객체 생성 방식에서는 개발자가 직접 `new` 키워드로 객체를 생성하고, 다른 객체에 주입한다. 하지만 IoC 에서는 객체 생성 및 의존성 설정 작업을 Spring 컨테이너가 맡아 처리한다.&#x20;
* 핵심 포인트&#x20;
  * IoC 는 객체 생성, 의존성 관리, 생명주기 제어를 포함하는 큰 개념이다.&#x20;
  * IoC 는 애플리케이션의 유연성과 확장성을 높이는 데 기여한다.&#x20;

#### DI(Dependency Injection) - "객체를 어떻게 연결하는가"에 대한 방법론

* DI 는 IoC 를 구현하는 한 가지 방법으로, 객체 간의 의존성을 외부에서 주입하는 것을 의미한다.&#x20;
* 동작방식) Spring 컨테이너가 의존성을 가진 객체를 생성한 후, 필요로 하는 곳에 자동으로 주입해 준다.&#x20;
* DI 는 필드, 생성자, 세터 주입을 사용할 수 있다.

> #### 라이브러리&#x20;
>
> * 특정 기능을 구현하기 위해 제공하는 코드 집합으로, 개발자가 직접 호출해서 사용하는 도구&#x20;
>   * 개발자가 필요한 부분만 골라 사용하며, 호출의 주체는 개발자이다.&#x20;
>   * 개발자가 전체 애플리케이션의 흐름을 통제한다.&#x20;
>
> #### 프레임워크&#x20;
>
> * 프레임워크는 애플리케이션의 구조와 흐름을 미리 정의해 둔 틀이다.&#x20;
>   * IoC 를 통해, 프레임워크가 애플리케이션 흐름을 제어한다.&#x20;
>   * 개발자는 프레임워크가 요구하는 방식대로 코드를 작성하며, 특정 부분만 확장하거나 구현한다.&#x20;
>
> #### 프레임워크가 애플리케이션의 흐름을 강제하는 이유?&#x20;
>
> * 프레임워크가 애플리케이션 흐름을 강제하는 이유는 IoC(Inversion of Control) 원칙을 통해 개발자가 비즈니스 로직에 집중할 수 있도록 지원하기 위해서이다.&#x20;
> * 이를 통해 공통 작업은 프레임워크가 관리하고, 개발자는 핵심 로직만 구현할 수 있다.&#x20;
> * 예를 들어, Spring MVC 에서는 요청 처리 흐름을 프레임워크가 담당하므로, 개발자는 컨트롤러와 서비스 계층의 구현에만 집중하면 된다. &#x20;
> * 때문에, 각 프레임워크가 강제하는 내용들에 대해 생각해보다보면, 프레임워크의 철학을 알아갈 수 있다.&#x20;

### 1-1. IoC 컨테이너 내부 동작 원리를 설명해주세요.&#x20;

#### 1. 설정 읽기 및 초기화&#x20;

* IoC 컨테이너는 애플리케이션의 설정 정보를 읽어 어떤 객체를 관리할지 결정한다.&#x20;
* 설정 소스&#x20;
  * XML 설정 (`applicationContext.xml`)&#x20;
  * Java Config 클래스 (`@Configuration` 및 `@Bean`)
  * Component Scanning(`@Component`, `@Controller`, `@Service`, `@Repository`)
* 컨테이너는 설정 파일이나 애노테이션 정보를 통해 BeanDefinition 을 생성한다.&#x20;
  * BeanDefinition : 각 Bean 에 대한 메타데이터(이름, 클래스, 의존성, 라이프사이클 등) 를 포함하는 객체&#x20;

#### 2. BeanDefinition 저장&#x20;

* 컨테이너는 모든 BeanDefinition 을 BeanDefinitionMap 이라는 내부 저장소에 보관한다.&#x20;
* 저장된 메타데이터는 이후 Bean 생성과 주입 과정에서 사용된다.&#x20;

#### 3. Bean 생성 (Lazy vs Eager Instantiation)

* 기본적으로 싱글톤(Singleton) 스코프의 Bean 은 컨테이너 초기화 시점에 즉시 생성(Eager Instantiation) 된다.&#x20;
* 단, `@Lazy` 애노테이션이 분은 Bean 은 필요할 떄까지 지연 생성된다.&#x20;

#### 4. 의존성 주입(Dependency Injection)&#x20;

* 필드 주입, 생성자 주입, 세터 주입을 통해 의존성을 주입할 수 있다.&#x20;

#### 5. 초기화 콜백 호출&#x20;

* `@PostConstruct`

#### 6. 소멸 콜백 호출&#x20;

* `@PreDestroy`

### 1-2. DI 를 구현하는 방법 중 필드 주입, 생성자 주입, 세터 주입의 차이점과 장단점을 설명해주세요.&#x20;

#### 1. 필드 주입(Field injection)&#x20;

* 장점&#x20;
  * 코드가 간결하고, 의존성을 주입할 떄 setter 나 생성자 메서드를 작성할 필요가 없어서 편리하다.&#x20;
* 단점
  * 테스트 어려움 : 필드 주입은 테스트를 하기 어려울 수 있다. 직접 값을 설정할 수 없기 때문에, 테스트를 위한 객체 주입이 번거로울 수 있다 .
  * 불변성 부족 :&#x20;

### 1-3. 스프링에서 Bean 의 생명주기를 설명해주세요.&#x20;

### 1-4. 스프링의 ApplicationContext, BeanFactory 의 차이점은 무엇인가요?&#x20;

### 1-5. 스프링에서 의존성 주입을 통해 순환 참조를 방지하는 방법은 무엇인가요?&#x20;

## 2. POJO 와 스프링 프레임워크의 관계를 설명해주세요.&#x20;

### 2-1. POJO를 사용하는 것이 테스트 코드 작성에 어떤 이점을 제공하나요?

### 2-2. 스프링에서 POJO를 활용한 AOP(Aspect-Oriented Programming) 구현 방법을 설명해주세요.

### 2-3. POJO를 기반으로 한 스프링의 트랜잭션 관리 방식은 무엇인가요?

### 2-4. POJO와 JPA 엔티티의 차이점은 무엇인가요?

### 2-5. POJO를 활용한 스프링의 REST API 설계 원칙을 설명해주세요.

## 3. DDD 에서 도메인 계층과 애플리케이션 계층의 차이점은 무엇인가요?&#x20;

### 3-1. 도메인 계층에서 비즈니스 로직을 구현할 때의 장점과 단점을 설명해주세요.

### 3-2. 애플리케이션 계층에서 도메인 계층을 호출하는 방식의 설계 원칙은 무엇인가요?

### 3-3. 도메인 계층에서 발생하는 이벤트를 애플리케이션 계층에서 처리하는 방법은 무엇인가요?

### 3-4. 도메인 계층과 인프라스트럭처 계층 간의 의존성을 최소화하는 방법은 무엇인가요?

### 3-5. DDD에서 애그리게이트(Aggregate)의 역할과 설계 원칙을 설명해주세요.

## 4. 스프링 MVC 패턴에서 컨트롤러와 서비스 계층의 역할을 구분하여 설명해주세요.

### 4-1. 컨트롤러에서 비즈니스 로직을 처리하지 않는 이유는 무엇인가요?

### 4-2. 서비스 계층에서 트랜잭션 관리를 구현하는 방법은 무엇인가요?

### 4-3. 컨트롤러에서 요청 데이터를 검증하는 방법과 서비스 계층에서 검증하는 방법의 차이점은 무엇인가요?

### 4-4. 서비스 계층에서 발생하는 예외를 컨트롤러에서 처리하는 방법은 무엇인가요?

### 4-5. 컨트롤러와 서비스 계층 간의 의존성을 줄이기 위한 설계 방법은 무엇인가요?

## 5. 테스트 코드 작성 시 통합 테스트와 단위 테스트의 차이점은 무엇인가요?

### 5-1. 통합 테스트에서 목 객체(Mock Object)를 사용하는 이유는 무엇인가요?

### 5-2. 단위 테스트에서 의존성을 최소화하기 위한 방법은 무엇인가요?

### 5-3. 통합 테스트에서 데이터베이스 상태를 초기화하는 방법은 무엇인가요?

### 5-4. 단위 테스트와 통합 테스트의 실행 속도 차이를 줄이기 위한 방법은 무엇인가요?

### 5-5. 테스트 코드 작성 시 TDD(Test-Driven Development)의 장점과 단점을 설명해주세요.
