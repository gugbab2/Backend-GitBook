# 스레드를 많이 쓸수록 항상 성능이 좋아질까?

#### 참고자료&#x20;

* [https://inpa.tistory.com/entry/%F0%9F%91%A9%E2%80%8D%F0%9F%92%BB-Is-more-threads-always-better](https://inpa.tistory.com/entry/%F0%9F%91%A9%E2%80%8D%F0%9F%92%BB-Is-more-threads-always-better)

## 1. 스레드를 많이 쓰면 쓸수록 성능이 높아지는가?&#x20;

프로세스와 스레드를 처음 학습할 때, 스레드는 프로세스 내의 존재하는 실행 단위이며, 이 스레드가 여러개인 덕분에, 우리가 음악을 들으며 웹서핑을 하거나 파일을 다운 받는 '동시 작업' 이 가능하다고 말했다.&#x20;

그래서인지 이러한 질문에 대해 깊게 고민하지 않고, 스레드가 많을 수록 동시 작업 처리수가 늘어난다고 생각해 멀티스레드가 무조건 성능이 좋다고 생각할 수 있다.&#x20;

<figure><img src="../../../.gitbook/assets/스크린샷 2025-08-09 10.48.35.png" alt=""><figcaption></figcaption></figure>

하지만 **모든 상황에 대해 무조건 멀티 스레드가 싱글 스레드보다 무조건 좋다고 말할 순 없다.** 모든 기술에는 트레이드오프가 존재하기 때문이다.&#x20;

지금부터 싱글 스레드와 멀티 스레드 두 가지 모델을 비교하고 언제 어느때에 무엇이 더 좋은지 왜 멀티 스레드가 항상 성능이 좋지 않은지에 대해 알아보자.&#x20;

## 2. 임계 영역에 대한 동기화 비용

멀티 스레드는 자원을 공유하기 때문에 프로세스 생성에 비해 적은 메모리와 자원을 소모하고 컨텍스트 스위칭도 멀티 프로세스에 비해서 빠르다는 장점이 있다. 하지만 여러 개의 스레드가 임계 영역(Critical Section) 의 공유 자원에 접근할 수 있기 때문에, 데이터의 일관성과 정확성을 확보하기 위해서는 **동기화(Synchronized) 기법**을 사용하여야 한다.&#x20;

동기화 기법에는 여러가지가 있는데 대표적인 두가지로 뮤텍스(Mutex), 세마포어(Semaphore) 같은 잠금 기법이 있다. 이들은 한 번에 공유 자원에 접근할 수 있는 스레드 수를 하나 혹은 정해놓아 데이터에 대한 일관성을 유지한다. 그러나 이러한 동기화 기법은 스레드 간의 대기 상황을 발생시키므로, 오히려 성능에 영향을 미칠 수 있다.&#x20;

예를 들어, 뮤텍스나 세마포어와 같은 동기화 기법을 사용하는 경우, 스레드가 데이터에 접근하기 전에 락(lock) 을 획득하고, 데이터에 접근한 후 락을 해제하는데, 이러한 **락 획득 및 해제 작업은 추가적인 시간이 소요되며, 나머지 스레드의 실행을 중지하거나, 대기**하게 만들어야 하므로 프로그램의 성능이 저하될 수 있다.&#x20;

또한 **CPU 캐시와 메모리 사이의 캐시 데이터 일관성 문제**도 발생할 수 있다. 여러 개의 스레드가 동시에 공유하는 메모리나 데이터에 대해 수정을 가할 때 특정 CPU 코어의 캐시에 저장된 데이터와 다른 CPU 코어의 캐시에 저장된 데이터가 일치하지 않는 경우(메모리 가시성)가 발생한다. 이럴 경우, 다른 CPU 코어에서 변경한 데이터가 현재 CPU 코어의 캐시에 반영되지 않은 상태로 사용되어 문제가 발생할 수 있어, **CPU 캐시에서 데이터를 불러오는 비용**이 발생하므로 성능에 영향을 미치게 된다.&#x20;

<figure><img src="../../../.gitbook/assets/스크린샷 2025-08-09 11.08.12.png" alt=""><figcaption></figcaption></figure>

지금까지 이야기를 정리하면, 멀티 스레드 프로그램이 많은 양의 공유 데이터를 사용하는 경우 **동기화 및 캐시 일관성(가시성) 작업으로 인해 병목이 일어나 성능이 떨어진다..**

그럼 반대로 만일 공유 데이터 양이 적고, CPU 와 메모리 사용량이 적은 경우 오히려 싱글 스레드 프로그램이 멀티 스레드보다 더 좋다고 할 수 있을까? 이는 아주 틀린 말은 아니지만, 실제로 대부분의 프로그램에서는 많은 양의 데이터와 복잡한 로직을 처리해야 하고 요즘 CPU 는 기본적으로 다중 코어를 탑재하므로, 이러한 병목 현상이 있더라도 왠만한 상황에서는 멀티 스레드 프로그램이 싱글 스레드 프로그램보다 빠르다.&#x20;

그렇지만 멀티 스레드라고 해서 싱글 스레드보다 성능 상승 곡선이 무조건적으로 가파르지 않다.&#x20;

## 3. 컨텍스트 스위칭 오버헤드&#x20;

컨텍스트 스위칭 오버헤드(context switching overhead) 는 여러개의 프로세스나 스레드가 있을 때, CPU 가 현재 프로세스나 스레드의 상태를 저장하고 다른 프로세스나 스레드로 전환될 때 발생하는 비용을 의미한다. 이 **스위칭 하는 과정에서 CPU 시간과 자원을 소모**하므로 성능에 영향을 미치는 것이다.&#x20;

우리가 멀티 프로세스 대신 멀티 스레드로 프로그램 모델을 구성하는 이유는 프로세스의 컨텍스트 스위칭 오버헤드보다 스레드 컨텍스트 스위칭 오버헤드가 훨씬 작아 병목이 적기 때문이다. **하지만 어디까지나 프로세스에 비해 상대적으로 작다는 것이지 오버헤드 자체 비용은 결코 무시할 수 없다.**&#x20;

즉, 싱글 스레드 모델에서는 스레드가 한개이니 컨텍스트 스위칭 오버헤드가 발생하지 않지만, 멀티 스레드 모델은 스레드가 여러개이니 컨텍스트 스위칭 오버헤드가 발생하게 되고, **스레드가 많으면 많을 수록 스위칭 횟수도 많아지고 덩달아 오버헤드도 많아져** 성능이 저할될 수 있다는 의미이다. 특히, 싱글 코어와 같은 옛날 CPU 와 같이 코어 수는 적은데, 스레드 수를 계속 늘리게 되면, 각 코어에서 경합하는 스레드 수가 점점 많아질것이고, 어느 순간 오버헤드 때문에 성능 한계를 부딪히게 될 수 있다.&#x20;

만일 단순히 CPU 만을 사용하는 계산작업이라면 오히려 멀티 스레드보다 싱글스레드로 프로그래밍하는 것이 더 효율적일 수 있다.&#x20;

예를 들어, 1\~1억개를 순차적으로 더하는 연산이 10초 걸리고, 이 연산을 100번 수행한다고 생각해보자.&#x20;

* 싱글 스레드 : 10초 \* 100 = 1000초&#x20;
* 멀티 스레드 : 100개의 스레드, 10초 = 10초

위와 같은 결과가 나올 것이라 생각하지만, 스레드 컨텍스트 스위칭 오버헤드로 싱글 스레드가 더 느려질 수도 있다.\
(물론 극단적인 예시로 아닐수도 있다)&#x20;

**결론적으로 "스레드가 많을수록 작업을 분리해서 동시에 처리하니까 항상 빠르다" 는 고정 관념을 깰 필요가 있다.**&#x20;

## 4. 잔여 스레드의 리소스 낭비&#x20;

많은 양의 작업을 여러개의 스레드로 빠르게 처리한다는 멀티 스레드 취지는 좋지만, 회사의 서비스 이용률이 24시간 항상 바쁜 상태이지는 않을 것이다. 즉, 멀티 스레드 어플리케이션에서 이용률이 한산하여 스레드를 한두개 밖에 이용하지 않을 때, 나머지 잔여 스레드들이 CPU, 메모리, 네트워크 등의 자원을 불필요하게 점유해서 성능 저하나 오류의 원인이 될 수 있게 된다. 우선 놀고 있는 스레드가 많을 수록 불필요하게 메모리를 차지하고 있는 셈이기 때문에 당연히 **시스템 자원 낭비가 발생한다.**&#x20;

즉, 스레드가 작업을 수행하지 않더라도 존재 자체만으로 여전히 리소스를 소비하기 때문에, 잔여 스레드의 문제는 결코 가볍지 않은 것이다.&#x20;

이러한 문제를 해결하기 위해서, 스레드 풀의 스레드 수를 하드웨어가 감당할 수 있는 수준으로 설정하는 것이 매우 중요하다.&#x20;

## 5. 애플리케이션 성격에 따른 제약&#x20;

#### CPU 바운드 어플리케이션&#x20;

오라클에서 아키텍트로 일하고 있는 Goetz 가 2002, 2006 년에 발표한 자바 병렬 프로그램에 관한 책과 논문에 따르면 CPU 바운드 작업에서 적절한 스레드 수는 **코어 수 + 1** 이라고 주장했다. 이는 위에서 살펴 보았던 컨텍스트 비용 때문이라는 것을 유추할 수 있다. 따라서 CPU 바운드 어플리케이션은 CPU 를 많이 사용하기 때문에, 코어수와 비슷한 수준 이상으로 스레드 수를 늘려봐야 별 이점이 없으며, 오히려 스레드 수가 많아질수록 컨텍스트 스위칭 오버헤드만 심해져 더 성능이 안좋아진다. 그래서 스레드의 개수가 적절하게 설정되어야 최적의 성능을 얻을 수 있는 것이다.&#x20;

#### I/O 바운드 어플리케이션&#x20;

파일 입출력, 네트워크 통신, 데이터베이스 조회와 같은 입출력 작업이 많을 경우 스레드를 늘리는 것이 좋다. 이러한 작업들은 I/O 장치의 응답 속도에 의존하는 것이 큰데, I/O 대기 시간동안 스레드 상태는 Waiting 로 대기하게 된다. 스케줄러는 Waiting 상태의 스레드를 대신해 Runnable 상태에 있는 스레드를 실행하도록 한다.&#x20;

**즉, 멀티스레드 I/O 작업이 처리될 동안 다음에 이행할 작업들을 다른 스레드에게 자원을 할당하여 수행할 수 있도록 한다.**&#x20;

<figure><img src="../../../.gitbook/assets/스크린샷 2025-08-09 14.49.57.png" alt=""><figcaption></figcaption></figure>

때문에 I/O 바운드 어플리케이션의 경우 코어수보다 훨씬 많은 수의 스레드를 할당하는 것이 효율적일 수 있다.&#x20;
