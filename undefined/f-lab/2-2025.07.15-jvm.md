# 2회차 - (2025.07.15 / JVM)

## 1. JVM 은 어떤 구성 요소를 가지고 있는가?&#x20;

### 클래스 로더 시스템&#x20;

### 런타임 메모리&#x20;

### 실행 엔진&#x20;

## 2. JVM 이 메모리를 어떤 식으로 구분하고 있는가?&#x20;

## 3. ClassLoader 란?&#x20;

## 4. class A는 어떤 식으로 로드되는가?&#x20;

```java
// JVM 어떤 구성 요소를 가지고 있는지
// -> ClassLoader: .class를 읽어서 메소드 영역에 저장
// -> Runtime Data Area
// -> EE
//  -> Interpreter
//  -> JIT(C1, C2: 로딩시간과 실행시간)
//  -> GC: Generational based GC(객체는 빨리 죽음, 세대별로 참조가 많이 일어나지 않음, 한번 살아남은 객체들을 오래 살아남음)
// JVM이 메모리를 어떤 식으로 구분하고 있는지
// -> PCR: 스레드별로 어디를 실행하는지 포인터를 저장
// -> Stack: 지역변수 테이블, 반환 참조 테이블
// -> Native Stack: 자바 메소드 말고, 네이티브 메소드들을 저장하는
// -> Heap: 인스턴스를 저장하는 영역. 하드웨어 자원이 허락하는 한 사용할 수 있음
// -> Method Area: PermGen(JDK 7이전의 구현체), Metaspace(JDK 8이후의 구현체, native memory에 저장), 클래스 정보를 저장
// -> Constant pool: 문자열은 heap, 그 밖은 method area
// -> NIO를 위한 메모리: Off heap
// class A는 어떤 식으로 로드되는지에 대해서 
// classloader란?
// -> Bootstrap(가장 기본이 되는 클래스들) -> Platform(확장이 되는 클래스들을) -> Application classloader(개발자가 실제 정의하고만드는 클래스들)
// -> 로딩
// -> 링킹
//  -> 검증: 왜 필요할까? bytecode를 실행하는 거라서, 중간에 파일을 변조하거나 할 수 있는 이유가 있을 것 같아요. 중간에 .class를 건드릴 수도 있을 것 같구요.
//  -> 준비: static 변수들을 준비, final은 여기서 할당
//  -> 해석: 심볼릭 참조 -> 직접 참조
// -> 초기화: 메소드 범위 내에서 초기화, 정적 변수, 정적 블록
// #1 -> A -> 0x40000
// #2 -> A.STR -> 0x40004
class A {
  private static final String STR = "ABC"; // STR은 Method area, "ABC"는 RCP
  private static Long l = Long.valueOf(-1L); // heap
  private static int i = -1; // -1은 Method area
  private static C c = new C(); // C가 heap에 저장
  
  private final String a = "ABC";
  private final int ii = 1;
  private C cc = new C();
  
  public static void main(...) {
    // JVM Memory에서 무슨 일이 일어나는지 설명해 봅시다.
    // Stack frame안에 a 변수가 있고, a 는 A의 참조값을 저장
    // A의 인스턴스는 힙에 저장됨
    A a = new A();
    B b = new B();
    
    System.out.println(#2);
    
    System.out.println(A.STR == a.a); // true? false?
    System.out.println(A.l == new Long(-1L)); // true? false?
    System.out.println(A.l == Long.valueOf(-1L)); // true? false?
  }
}

class B extends A {
  // ...
}

class C {
  // ...
}
```

